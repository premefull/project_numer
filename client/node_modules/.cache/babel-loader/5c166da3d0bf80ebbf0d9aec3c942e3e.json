{"ast":null,"code":"// Generated by CoffeeScript 1.12.7\n(function () {\n  var $,\n      ABS,\n      ADD,\n      ADJ,\n      AND,\n      APPROXRATIO,\n      ARCCOS,\n      ARCCOSH,\n      ARCSIN,\n      ARCSINH,\n      ARCTAN,\n      ARCTANH,\n      ARG,\n      ASSUME_REAL_VARIABLES,\n      ATOMIZE,\n      AUTOEXPAND,\n      BAKE,\n      BESSELJ,\n      BESSELY,\n      BINDING,\n      BINOMIAL,\n      BINOM_check_args,\n      BUF,\n      C1,\n      C2,\n      C3,\n      C4,\n      C5,\n      C6,\n      CEILING,\n      CHECK,\n      CHOOSE,\n      CIRCEXP,\n      CLEAR,\n      CLEARALL,\n      CLEARPATTERNS,\n      CLOCK,\n      COEFF,\n      COFACTOR,\n      CONDENSE,\n      CONJ,\n      CONS,\n      CONTRACT,\n      COS,\n      COSH,\n      Condense,\n      DEBUG,\n      DEBUG_ABS,\n      DEBUG_ARG,\n      DEBUG_CLOCKFORM,\n      DEBUG_IMAG,\n      DEBUG_IS,\n      DEBUG_POWER,\n      DEBUG_RECT,\n      DECOMP,\n      DEFINT,\n      DEGREE,\n      DENOMINATOR,\n      DERIVATIVE,\n      DET,\n      DET_check_arg,\n      DIM,\n      DIRAC,\n      DIVISORS,\n      DO,\n      DOT,\n      DOUBLE,\n      DRAW,\n      DRAWX,\n      DSOLVE,\n      E,\n      EIGEN,\n      EIGENVAL,\n      EIGENVEC,\n      EIG_N,\n      EIG_check_arg,\n      EIG_yydd,\n      EIG_yyqq,\n      ERF,\n      ERFC,\n      EVAL,\n      EXP,\n      EXPAND,\n      EXPCOS,\n      EXPSIN,\n      Eval,\n      Eval_Eval,\n      Eval_abs,\n      Eval_add,\n      Eval_adj,\n      Eval_and,\n      Eval_approxratio,\n      Eval_arccos,\n      Eval_arccosh,\n      Eval_arcsin,\n      Eval_arcsinh,\n      Eval_arctan,\n      Eval_arctanh,\n      Eval_arg,\n      Eval_besselj,\n      Eval_bessely,\n      Eval_binding,\n      Eval_binomial,\n      Eval_ceiling,\n      Eval_check,\n      Eval_choose,\n      Eval_circexp,\n      Eval_clear,\n      Eval_clearall,\n      Eval_clearpatterns,\n      Eval_clock,\n      Eval_coeff,\n      Eval_cofactor,\n      Eval_condense,\n      Eval_conj,\n      Eval_cons,\n      Eval_contract,\n      Eval_cos,\n      Eval_cosh,\n      Eval_decomp,\n      Eval_defint,\n      Eval_degree,\n      Eval_denominator,\n      Eval_derivative,\n      Eval_det,\n      Eval_dim,\n      Eval_dirac,\n      Eval_divisors,\n      Eval_do,\n      Eval_dsolve,\n      Eval_eigen,\n      Eval_eigenval,\n      Eval_eigenvec,\n      Eval_erf,\n      Eval_erfc,\n      Eval_exp,\n      Eval_expand,\n      Eval_expcos,\n      Eval_expsin,\n      Eval_factor,\n      Eval_factorial,\n      Eval_factorpoly,\n      Eval_filter,\n      Eval_float,\n      Eval_floor,\n      Eval_for,\n      Eval_function_reference,\n      Eval_gamma,\n      Eval_gcd,\n      Eval_hermite,\n      Eval_hilbert,\n      Eval_imag,\n      Eval_index,\n      _Eval_inner,\n      Eval_integral,\n      Eval_inv,\n      Eval_invg,\n      Eval_isinteger,\n      Eval_isprime,\n      Eval_laguerre,\n      Eval_lcm,\n      Eval_leading,\n      Eval_legendre,\n      Eval_log,\n      Eval_lookup,\n      Eval_mod,\n      Eval_multiply,\n      Eval_noexpand,\n      Eval_not,\n      Eval_nroots,\n      Eval_number,\n      Eval_numerator,\n      Eval_operator,\n      Eval_or,\n      Eval_outer,\n      Eval_pattern,\n      Eval_patternsinfo,\n      Eval_polar,\n      Eval_power,\n      Eval_predicate,\n      Eval_prime,\n      Eval_print,\n      Eval_print2dascii,\n      Eval_printcomputer,\n      Eval_printhuman,\n      Eval_printlatex,\n      Eval_printlist,\n      Eval_product,\n      Eval_quote,\n      Eval_quotient,\n      Eval_rank,\n      Eval_rationalize,\n      Eval_real,\n      Eval_rect,\n      Eval_roots,\n      Eval_round,\n      Eval_setq,\n      Eval_sgn,\n      Eval_shape,\n      Eval_silentpattern,\n      Eval_simfac,\n      Eval_simplify,\n      Eval_sin,\n      Eval_sinh,\n      Eval_sqrt,\n      Eval_stop,\n      Eval_subst,\n      Eval_sum,\n      Eval_sym,\n      Eval_symbolsinfo,\n      Eval_tan,\n      Eval_tanh,\n      Eval_taylor,\n      Eval_tensor,\n      Eval_test,\n      Eval_testeq,\n      Eval_testge,\n      Eval_testgt,\n      Eval_testle,\n      Eval_testlt,\n      Eval_transpose,\n      Eval_unit,\n      Eval_user_function,\n      Eval_zero,\n      Evalpoly,\n      FACTOR,\n      FACTORIAL,\n      FACTORPOLY,\n      FILTER,\n      FLOATF,\n      FLOOR,\n      FOR,\n      FORCE_FIXED_PRINTOUT,\n      FUNCTION,\n      _Find,\n      GAMMA,\n      GCD,\n      HERMITE,\n      HILBERT,\n      IMAG,\n      INDEX,\n      INNER,\n      INTEGRAL,\n      INV,\n      INVG,\n      INV_check_arg,\n      INV_decomp,\n      ISINTEGER,\n      ISPRIME,\n      LAGUERRE,\n      LAST,\n      LAST_2DASCII_PRINT,\n      LAST_FULL_PRINT,\n      LAST_LATEX_PRINT,\n      LAST_LIST_PRINT,\n      LAST_PLAIN_PRINT,\n      LAST_PRINT,\n      LCM,\n      LEADING,\n      LEGENDRE,\n      LOG,\n      LOOKUP,\n      M,\n      MAXDIM,\n      MAXPRIMETAB,\n      MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES,\n      MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE,\n      MAX_FIXED_PRINTOUT_DIGITS,\n      MAX_PROGRAM_SIZE,\n      MEQUAL,\n      METAA,\n      METAB,\n      METAX,\n      MLENGTH,\n      MOD,\n      MSIGN,\n      MULTIPLY,\n      MZERO,\n      N,\n      NIL,\n      NOT,\n      NROOTS,\n      NROOTS_ABS,\n      NROOTS_DELTA,\n      NROOTS_EPSILON,\n      NROOTS_RANDOM,\n      NROOTS_YMAX,\n      NROOTS_divpoly,\n      NSYM,\n      NUM,\n      NUMBER,\n      NUMERATOR,\n      OPERATOR,\n      OR,\n      OUTER,\n      PATTERN,\n      PATTERNSINFO,\n      PI,\n      POLAR,\n      POWER,\n      PRIME,\n      PRINT,\n      PRINT2DASCII,\n      PRINTFULL,\n      PRINTLATEX,\n      PRINTLIST,\n      PRINTMODE_2DASCII,\n      PRINTMODE_COMPUTER,\n      PRINTMODE_HUMAN,\n      PRINTMODE_LATEX,\n      PRINTMODE_LIST,\n      PRINTOUTRESULT,\n      PRINTPLAIN,\n      PRINT_LEAVE_E_ALONE,\n      PRINT_LEAVE_X_ALONE,\n      PRODUCT,\n      QUOTE,\n      QUOTIENT,\n      RANK,\n      RATIONALIZE,\n      REAL,\n      ROOTS,\n      ROUND,\n      SECRETX,\n      SELFTEST,\n      SETQ,\n      SGN,\n      SHAPE,\n      SILENTPATTERN,\n      SIMPLIFY,\n      SIN,\n      SINH,\n      SPACE_BETWEEN_COLUMNS,\n      SPACE_BETWEEN_ROWS,\n      SQRT,\n      STOP,\n      STR,\n      SUBST,\n      SUM,\n      SYM,\n      SYMBOLSINFO,\n      SYMBOL_A,\n      SYMBOL_A_UNDERSCORE,\n      SYMBOL_B,\n      SYMBOL_B_UNDERSCORE,\n      SYMBOL_C,\n      SYMBOL_D,\n      SYMBOL_I,\n      SYMBOL_IDENTITY_MATRIX,\n      SYMBOL_J,\n      SYMBOL_N,\n      SYMBOL_R,\n      SYMBOL_S,\n      SYMBOL_T,\n      SYMBOL_X,\n      SYMBOL_X_UNDERSCORE,\n      SYMBOL_Y,\n      SYMBOL_Z,\n      TAN,\n      TANH,\n      TAYLOR,\n      TENSOR,\n      TEST,\n      TESTEQ,\n      TESTGE,\n      TESTGT,\n      TESTLE,\n      TESTLT,\n      TIMING_DEBUGS,\n      TOS,\n      TRACE,\n      TRANSPOSE,\n      T_DOUBLE,\n      T_EQ,\n      T_FUNCTION,\n      T_GTEQ,\n      T_INTEGER,\n      T_LTEQ,\n      T_NEQ,\n      T_NEWLINE,\n      T_QUOTASSIGN,\n      T_STRING,\n      T_SYMBOL,\n      U,\n      UNIT,\n      USR_SYMBOLS,\n      VERSION,\n      YMAX,\n      YYE,\n      YYRECT,\n      ZERO,\n      __emit_char,\n      __emit_str,\n      __factor_add,\n      __factorial,\n      __is_negative,\n      __is_radical_number,\n      __lcm,\n      __legendre,\n      __legendre2,\n      __legendre3,\n      __normalize_radical_factors,\n      __rationalize_tensor,\n      _print,\n      abs,\n      absValFloat,\n      _absval,\n      absval_tensor,\n      add,\n      addSymbolLeftOfAssignment,\n      addSymbolRightOfAssignment,\n      add_all,\n      add_factor_to_accumulator,\n      add_numbers,\n      add_terms,\n      addf,\n      adj,\n      alloc_tensor,\n      allocatedId,\n      any_denominators,\n      approxAll,\n      approxLogs,\n      approxLogsOfRationals,\n      approxOneRatioOnly,\n      approxRadicals,\n      approxRadicalsOfRationals,\n      approxRationalsOfLogs,\n      approxRationalsOfPowersOfE,\n      approxRationalsOfPowersOfPI,\n      approxRationalsOfRadicals,\n      approxSineOfRationalMultiplesOfPI,\n      approxSineOfRationals,\n      approxTrigonometric,\n      approx_just_an_integer,\n      approx_logarithmsOfRationals,\n      approx_nothingUseful,\n      approx_radicalOfRatio,\n      approx_ratioOfRadical,\n      approx_rationalOfE,\n      approx_rationalOfPi,\n      approx_rationalsOfLogarithms,\n      approx_sine_of_pi_times_rational,\n      approx_sine_of_rational,\n      _approxratioRecursive,\n      arccos,\n      arccosh,\n      arcsin,\n      arcsinh,\n      _arctan,\n      arctanh,\n      areunivarpolysfactoredorexpandedform,\n      arg,\n      arglist,\n      assignmentFound,\n      avoidCalculatingPowersIntoArctans,\n      _bake,\n      bake_poly,\n      bake_poly_term,\n      besselj,\n      bessely,\n      bigInt,\n      bignum_factorial,\n      bignum_float,\n      bignum_power_number,\n      bignum_scan_float,\n      bignum_scan_integer,\n      bignum_truncate,\n      binding,\n      binomial,\n      buffer,\n      build_tensor,\n      caaddr,\n      caadr,\n      caar,\n      cadaddr,\n      cadadr,\n      cadar,\n      caddaddr,\n      caddadr,\n      caddar,\n      caddddr,\n      cadddr,\n      caddr,\n      cadr,\n      called_from_Algebra_block,\n      car,\n      cdaddr,\n      cdadr,\n      cdar,\n      cddaddr,\n      cddar,\n      cdddaddr,\n      cddddr,\n      cdddr,\n      cddr,\n      cdr,\n      ceiling,\n      chainOfUserSymbolsNotFunctionsBeingEvaluated,\n      charTabIndex,\n      chartab,\n      checkFloatHasWorkedOutCompletely,\n      check_esc_flag,\n      check_stack,\n      check_tensor_dimensions,\n      choose,\n      choose_check_args,\n      _circexp,\n      clearAlgebraEnvironment,\n      clearRenamedVariablesToAvoidBindingToExternalScope,\n      clear_symbols,\n      clear_term,\n      clearall,\n      clockform,\n      cmpGlyphs,\n      cmp_args,\n      _cmp_expr,\n      cmp_terms,\n      cmp_terms_count,\n      codeGen,\n      coeff,\n      cofactor,\n      collectLatexStringFromReturnValue,\n      _collectUserSymbols,\n      combine_factors,\n      combine_gammas,\n      combine_terms,\n      compareState,\n      compare_numbers,\n      compare_rationals,\n      compare_tensors,\n      compatible,\n      computeDependenciesFromAlgebra,\n      computeResultsAndJavaScriptFromAlgebra,\n      compute_fa,\n      conjugate,\n      cons,\n      consCount,\n      contract,\n      convert_bignum_to_double,\n      convert_rational_to_double,\n      copy_tensor,\n      cosine,\n      cosine_of_angle,\n      cosine_of_angle_sum,\n      _count,\n      _countOccurrencesOfSymbol,\n      count_denominators,\n      counter,\n      countsize,\n      d_scalar_scalar,\n      d_scalar_scalar_1,\n      d_scalar_tensor,\n      d_tensor_scalar,\n      d_tensor_tensor,\n      dabs,\n      darccos,\n      darccosh,\n      darcsin,\n      darcsinh,\n      darctan,\n      darctanh,\n      dbesselj0,\n      dbesseljn,\n      dbessely0,\n      dbesselyn,\n      dcos,\n      dcosh,\n      dd,\n      _decomp,\n      decomp_product,\n      decomp_sum,\n      defineSomeHandyConstants,\n      define_user_function,\n      defn,\n      defn_str,\n      degree,\n      _denominator,\n      derf,\n      derfc,\n      derivative,\n      derivative_of_integral,\n      det,\n      determinant,\n      detg,\n      dfunction,\n      dhermite,\n      dirac,\n      display,\n      display_flag,\n      displaychar,\n      divide,\n      divide_numbers,\n      divisors,\n      divisors_onstack,\n      divpoly,\n      dlog,\n      do_clearPatterns,\n      do_clearall,\n      do_simplify_nested_radicals,\n      dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication,\n      dotprod_unicode,\n      doubleToReasonableString,\n      dpow,\n      dpower,\n      dproduct,\n      draw_flag,\n      draw_stop_return,\n      dsgn,\n      dsin,\n      dsinh,\n      dsum,\n      dtan,\n      dtanh,\n      dupl,\n      eigen,\n      elelmIndex,\n      elem,\n      emit_denominator,\n      emit_denominators,\n      emit_expr,\n      emit_factor,\n      emit_factorial_function,\n      emit_flat_tensor,\n      emit_fraction,\n      emit_function,\n      emit_index_function,\n      emit_multiply,\n      emit_number,\n      emit_numerators,\n      emit_numerical_fraction,\n      emit_power,\n      emit_string,\n      emit_subexpr,\n      emit_symbol,\n      emit_tensor,\n      _emit_tensor_inner,\n      emit_term,\n      emit_top_expr,\n      emit_unsigned_expr,\n      emit_x,\n      equal,\n      equaln,\n      equalq,\n      erfc,\n      errorMessage,\n      esc_flag,\n      evaluatingAsFloats,\n      evaluatingPolar,\n      exec,\n      _expand,\n      expand_get_A,\n      expand_get_AF,\n      expand_get_B,\n      expand_get_C,\n      expand_get_CF,\n      expand_tensor,\n      expanding,\n      expcos,\n      exponential,\n      expr_level,\n      expsin,\n      f1,\n      f10,\n      f2,\n      f3,\n      f4,\n      f5,\n      f9,\n      f_equals_a,\n      factor,\n      factor_a,\n      factor_again,\n      factor_b,\n      factor_number,\n      factor_small_number,\n      factor_term,\n      factorial,\n      factorpoly,\n      factors,\n      factpoly_expo,\n      fill_buf,\n      filter,\n      filter_main,\n      filter_sum,\n      filter_tensor,\n      findDependenciesInScript,\n      _findPossibleClockForm,\n      _findPossibleExponentialForm,\n      findroot,\n      fixup_fraction,\n      fixup_power,\n      flag,\n      floatToRatioRoutine,\n      fmt_index,\n      fmt_level,\n      fmt_x,\n      frame,\n      freeze,\n      functionInvokationsScanningStack,\n      gamma,\n      gamma_of_sum,\n      gammaf,\n      gcd,\n      gcd_main,\n      gcd_numbers,\n      gcd_polys,\n      gcd_powers_with_same_base,\n      gcd_product_product,\n      gcd_product_sum,\n      gcd_sum,\n      gcd_sum_product,\n      gcd_sum_sum,\n      _gen,\n      getSimpleRoots,\n      getStateHash,\n      get_binding,\n      get_factor_from_complex_root,\n      get_factor_from_real_root,\n      _get_innerprod_factors,\n      get_next_token,\n      get_printname,\n      get_size,\n      get_token,\n      getdisplaystr,\n      glyph,\n      gp,\n      guess,\n      hasImaginaryCoeff,\n      hasNegativeRationalExponent,\n      hash_addition,\n      hash_function,\n      hash_multiplication,\n      hash_power,\n      hashcode_values,\n      hashed_itab,\n      hermite,\n      hilbert,\n      i1,\n      imag,\n      imaginaryunit,\n      index_function,\n      init,\n      initNRoots,\n      inited,\n      _inner,\n      inner_f,\n      input_str,\n      integral,\n      integral_of_form,\n      integral_of_product,\n      integral_of_sum,\n      _inv,\n      inverse,\n      invert_number,\n      invg,\n      isNumberOneOverSomething,\n      isNumericAtom,\n      _isNumericAtomOrTensor,\n      isSimpleRoot,\n      isSmall,\n      isSymbolLeftOfAssignment,\n      isSymbolReclaimable,\n      isZeroAtom,\n      isZeroAtomOrTensor,\n      isZeroLikeOrNonZeroLikeOrUndetermined,\n      isZeroTensor,\n      is_denominator,\n      is_factor,\n      is_small_integer,\n      is_square_matrix,\n      is_usr_symbol,\n      isadd,\n      isalnumorunderscore,\n      isalpha,\n      isalphaOrUnderscore,\n      iscomplexnumber,\n      iscomplexnumberdouble,\n      iscons,\n      isdenominator,\n      isdigit,\n      isdouble,\n      iseveninteger,\n      isfactor,\n      isfactorial,\n      _isfloating,\n      isfraction,\n      isidentitymatrix,\n      isimaginarynumber,\n      isimaginarynumberdouble,\n      isimaginaryunit,\n      isinnerordot,\n      isinteger,\n      isintegerfactor,\n      isintegerorintegerfloat,\n      isinv,\n      iskeyword,\n      isminusone,\n      isminusoneoversqrttwo,\n      isminusoneovertwo,\n      ismultiply,\n      isnegative,\n      isnegativenumber,\n      isnegativeterm,\n      isnonnegativeinteger,\n      isnpi,\n      isone,\n      isoneover,\n      isoneoversqrttwo,\n      isoneovertwo,\n      isplusone,\n      isplustwo,\n      ispolyexpandedform,\n      ispolyexpandedform_expr,\n      ispolyexpandedform_factor,\n      ispolyexpandedform_term,\n      ispolyfactoredorexpandedform,\n      ispolyfactoredorexpandedform_factor,\n      ispolyfactoredorexpandedform_power,\n      isposint,\n      ispositivenumber,\n      ispower,\n      isquarterturn,\n      isrational,\n      isspace,\n      isstr,\n      issymbol,\n      _issymbolic,\n      istensor,\n      istranspose,\n      isunderscore,\n      isunivarpolyfactoredorexpandedform,\n      itab,\n      italu_hashcode,\n      j1,\n      laguerre,\n      laguerre2,\n      lastFoundSymbol,\n      latexErrorSign,\n      lcm,\n      leading,\n      legendre,\n      length,\n      lessp,\n      level,\n      list,\n      listLength,\n      logarithm,\n      logbuf,\n      lookupsTotal,\n      lu_decomp,\n      madd,\n      makePositive,\n      makeSignSameAs,\n      make_hashed_itab,\n      mask,\n      mcmp,\n      mcmpint,\n      mdiv,\n      mdivrem,\n      meta_mode,\n      mgcd,\n      mini_solve,\n      mint,\n      mmod,\n      mmul,\n      mod,\n      monic,\n      move,\n      moveTos,\n      mp_clr_bit,\n      mp_denominator,\n      mp_numerator,\n      mp_set_bit,\n      mpow,\n      mprime,\n      mroot,\n      mshiftright,\n      msub,\n      mtotal,\n      _multinomial_sum,\n      multiply,\n      multiply_all,\n      multiply_all_noexpand,\n      multiply_consecutive_constants,\n      multiply_denominators,\n      multiply_denominators_factor,\n      multiply_denominators_term,\n      multiply_noexpand,\n      multiply_numbers,\n      n_factor_number,\n      negate,\n      negate_expand,\n      negate_noexpand,\n      negate_number,\n      new_string,\n      newline_flag,\n      nil_symbols,\n      normaliseDots,\n      normalisedCoeff,\n      normalize_angle,\n      nroots_a,\n      nroots_b,\n      nroots_c,\n      nroots_df,\n      nroots_dx,\n      nroots_fa,\n      nroots_fb,\n      nroots_x,\n      nroots_y,\n      nterms,\n      nthCadr,\n      _numerator,\n      numericRootOfPolynomial,\n      o,\n      one,\n      oneElement,\n      one_as_double,\n      out_buf,\n      out_count,\n      out_of_memory,\n      outer,\n      p0,\n      p1,\n      p2,\n      p3,\n      p4,\n      p5,\n      p6,\n      p7,\n      p8,\n      p9,\n      parse,\n      parse_internal,\n      parse_p1,\n      parse_p2,\n      parse_time_simplifications,\n      partition,\n      patternHasBeenFound,\n      patternsinfo,\n      peek,\n      performing_roots,\n      polar,\n      _polarRectAMinusOneBase,\n      polycoeff,\n      _polyform,\n      pop,\n      pop_double,\n      pop_frame,\n      pop_integer,\n      power,\n      power_str,\n      power_sum,\n      power_tensor,\n      predefinedSymbolsInGlobalScope_doNotTrackInDependencies,\n      prime,\n      primetab,\n      print2dascii,\n      printMode,\n      print_ABS_latex,\n      print_ARCCOS_codegen,\n      print_ARCSIN_codegen,\n      print_ARCTAN_codegen,\n      print_BINOMIAL_latex,\n      print_COS_codegen,\n      print_DEFINT_latex,\n      print_DOT_codegen,\n      print_DOT_latex,\n      print_DO_codegen,\n      print_FOR_codegen,\n      print_INV_codegen,\n      print_INV_latex,\n      print_PRODUCT_codegen,\n      print_PRODUCT_latex,\n      print_SETQ_codegen,\n      print_SIN_codegen,\n      print_SQRT_latex,\n      print_SUM_codegen,\n      print_SUM_latex,\n      print_TAN_codegen,\n      print_TESTEQ_latex,\n      print_TESTGE_latex,\n      print_TESTGT_latex,\n      print_TESTLE_latex,\n      print_TESTLT_latex,\n      print_TEST_codegen,\n      print_TEST_latex,\n      print_TRANSPOSE_codegen,\n      print_TRANSPOSE_latex,\n      print_UNIT_codegen,\n      print_a_over_b,\n      print_base,\n      print_base_of_denom,\n      print_char,\n      print_denom,\n      print_double,\n      print_expo_of_denom,\n      print_exponent,\n      print_expr,\n      _print_factor,\n      print_factorial_function,\n      print_glyphs,\n      print_index_function,\n      _print_list,\n      print_multiply_sign,\n      print_number,\n      _print_power,\n      print_str,\n      print_subexpr,\n      print_tensor,\n      _print_tensor_inner,\n      _print_tensor_inner_latex,\n      print_tensor_latex,\n      print_term,\n      printchar,\n      printchar_nowrap,\n      printline,\n      program_buf,\n      promote_tensor,\n      push,\n      pushTryNotToDuplicate,\n      push_cars,\n      push_double,\n      push_factor,\n      push_frame,\n      push_identity_matrix,\n      push_integer,\n      push_rational,\n      push_symbol,\n      push_term_factors,\n      push_terms,\n      push_zero_matrix,\n      qadd,\n      qdiv,\n      qmul,\n      qpow,\n      qpowf,\n      quickfactor,\n      quickpower,\n      rational,\n      rationalize,\n      rationalize_coefficients,\n      real,\n      reciprocate,\n      _rect,\n      recursionLevelNestedRadicalsRemoval,\n      _recursiveDependencies,\n      ref,\n      ref1,\n      rememberPrint,\n      remove_negative_exponents,\n      reset_after_error,\n      restore,\n      restoreMetaBindings,\n      _rewrite_args,\n      rewrite_args_tensor,\n      roots,\n      roots2,\n      roots3,\n      run,\n      runUserDefinedSimplifications,\n      save,\n      saveMetaBindings,\n      scalar_times_tensor,\n      scan,\n      scan_error,\n      scan_expression,\n      scan_factor,\n      scan_function_call_with_function_name,\n      scan_function_call_without_function_name,\n      scan_index,\n      scan_meta,\n      scan_power,\n      scan_relation,\n      scan_stmt,\n      scan_str,\n      scan_string,\n      scan_subexpr,\n      scan_symbol,\n      scan_tensor,\n      scan_term,\n      scanned,\n      scanningParameters,\n      setM,\n      setSignTo,\n      set_binding,\n      set_component,\n      setq_indexed,\n      sfac_product,\n      sfac_product_f,\n      sgn,\n      shape,\n      show_power_debug,\n      sign,\n      sign_of_term,\n      simfac,\n      simfac_term,\n      simpleComplexityMeasure,\n      simplify,\n      simplifyForCodeGeneration,\n      simplify_1_in_products,\n      simplify_main,\n      simplify_nested_radicals,\n      simplify_polar,\n      simplify_polarRect,\n      simplify_rational_expressions,\n      simplify_rectToClock,\n      simplify_tensor,\n      simplify_trig,\n      _simplifyfactorials,\n      sine,\n      sine_of_angle,\n      sine_of_angle_sum,\n      skipRootVariableToBeSolved,\n      sort_stack,\n      square,\n      ssqrt,\n      stack,\n      stackAddsCount,\n      std_symbol,\n      step,\n      step2,\n      stop,\n      strcmp,\n      stringsEmittedByUserPrintouts,\n      subf,\n      _subst,\n      subtract,\n      subtract_numbers,\n      swap,\n      symbol,\n      symbolsDependencies,\n      symbolsHavingReassignments,\n      symbolsInExpressionsWithoutAssignments,\n      symbolsLeftOfAssignment,\n      symbolsRightOfAssignment,\n      symbolsinfo,\n      symnum,\n      symtab,\n      _take_care_of_nested_radicals,\n      tangent,\n      taylor,\n      tensor,\n      tensor_plus_tensor,\n      tensor_times_scalar,\n      testApprox,\n      test_flag,\n      text_metric,\n      theRandom,\n      token,\n      token_buf,\n      token_str,\n      top,\n      top_level_eval,\n      tos,\n      _transform,\n      _transpose,\n      transpose_unicode,\n      trigmode,\n      trivial_divide,\n      try_kth_prime,\n      turnErrorMessageToLatex,\n      ucmp,\n      unfreeze,\n      unique,\n      _unique_f,\n      update_token_buf,\n      userSimplificationsInListForm,\n      userSimplificationsInStringForm,\n      usr_symbol,\n      verbosing,\n      version,\n      will_be_displayed_as_fraction,\n      ybinomial,\n      ycosh,\n      ydirac,\n      yerf,\n      yerfc,\n      yfloor,\n      yindex,\n      yround,\n      ysinh,\n      yyarg,\n      yybesselj,\n      yybessely,\n      yyceiling,\n      yycondense,\n      yycontract,\n      yycosh,\n      _yydegree,\n      yydetg,\n      yydivpoly,\n      yyerf,\n      yyerfc,\n      yyexpand,\n      yyfactorpoly,\n      _yyfloat,\n      yyfloor,\n      yyhermite,\n      yyhermite2,\n      yyinvg,\n      yylcm,\n      yylog,\n      yymultiply,\n      yyouter,\n      yypower,\n      yyrationalize,\n      yyround,\n      yysgn,\n      yysimfac,\n      yysinh,\n      yytangent,\n      zero,\n      zzfloat,\n      hasProp = {}.hasOwnProperty,\n      slice = [].slice;\n\n  bigInt = require('big-integer');\n  version = \"1.3.1\";\n  SELFTEST = 1;\n  NSYM = 1000;\n  DEBUG = false;\n  PRINTOUTRESULT = false;\n  PRINTMODE_LATEX = \"PRINTMODE_LATEX\";\n  PRINTMODE_2DASCII = \"PRINTMODE_2DASCII\";\n  PRINTMODE_COMPUTER = \"PRINTMODE_COMPUTER\";\n  PRINTMODE_HUMAN = \"PRINTMODE_HUMAN\";\n  PRINTMODE_LIST = \"PRINTMODE_LIST\";\n  printMode = PRINTMODE_COMPUTER;\n  dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication = true;\n  recursionLevelNestedRadicalsRemoval = 0;\n  do_simplify_nested_radicals = true;\n  avoidCalculatingPowersIntoArctans = true;\n\n  rational = function () {\n    function rational() {}\n\n    rational.prototype.a = null;\n    rational.prototype.b = null;\n    return rational;\n  }();\n\n  U = function () {\n    U.prototype.cons = null;\n    U.prototype.printname = \"\";\n    U.prototype.str = \"\";\n    U.prototype.tensor = null;\n    U.prototype.q = null;\n    U.prototype.d = 0.0;\n    U.prototype.k = 0;\n    U.prototype.tag = 0;\n\n    U.prototype.toString = function () {\n      return print_expr(this);\n    };\n\n    U.prototype.toLatexString = function () {\n      return collectLatexStringFromReturnValue(this);\n    };\n\n    function U() {\n      this.cons = {};\n      this.cons.car = null;\n      this.cons.cdr = null;\n      this.q = new rational();\n    }\n\n    return U;\n  }();\n\n  errorMessage = \"\";\n  CONS = 0;\n  NUM = 1;\n  DOUBLE = 2;\n  STR = 3;\n  TENSOR = 4;\n  SYM = 5;\n  counter = 0;\n  ABS = counter++;\n  ADD = counter++;\n  ADJ = counter++;\n  AND = counter++;\n  APPROXRATIO = counter++;\n  ARCCOS = counter++;\n  ARCCOSH = counter++;\n  ARCSIN = counter++;\n  ARCSINH = counter++;\n  ARCTAN = counter++;\n  ARCTANH = counter++;\n  ARG = counter++;\n  ATOMIZE = counter++;\n  BESSELJ = counter++;\n  BESSELY = counter++;\n  BINDING = counter++;\n  BINOMIAL = counter++;\n  CEILING = counter++;\n  CHECK = counter++;\n  CHOOSE = counter++;\n  CIRCEXP = counter++;\n  CLEAR = counter++;\n  CLEARALL = counter++;\n  CLEARPATTERNS = counter++;\n  CLOCK = counter++;\n  COEFF = counter++;\n  COFACTOR = counter++;\n  CONDENSE = counter++;\n  CONJ = counter++;\n  CONTRACT = counter++;\n  COS = counter++;\n  COSH = counter++;\n  DECOMP = counter++;\n  DEFINT = counter++;\n  DEGREE = counter++;\n  DENOMINATOR = counter++;\n  DERIVATIVE = counter++;\n  DET = counter++;\n  DIM = counter++;\n  DIRAC = counter++;\n  DIVISORS = counter++;\n  DO = counter++;\n  DOT = counter++;\n  DRAW = counter++;\n  DSOLVE = counter++;\n  EIGEN = counter++;\n  EIGENVAL = counter++;\n  EIGENVEC = counter++;\n  ERF = counter++;\n  ERFC = counter++;\n  EVAL = counter++;\n  EXP = counter++;\n  EXPAND = counter++;\n  EXPCOS = counter++;\n  EXPSIN = counter++;\n  FACTOR = counter++;\n  FACTORIAL = counter++;\n  FACTORPOLY = counter++;\n  FILTER = counter++;\n  FLOATF = counter++;\n  FLOOR = counter++;\n  FOR = counter++;\n  FUNCTION = counter++;\n  GAMMA = counter++;\n  GCD = counter++;\n  HERMITE = counter++;\n  HILBERT = counter++;\n  IMAG = counter++;\n  INDEX = counter++;\n  INNER = counter++;\n  INTEGRAL = counter++;\n  INV = counter++;\n  INVG = counter++;\n  ISINTEGER = counter++;\n  ISPRIME = counter++;\n  LAGUERRE = counter++;\n  LCM = counter++;\n  LEADING = counter++;\n  LEGENDRE = counter++;\n  LOG = counter++;\n  LOOKUP = counter++;\n  MOD = counter++;\n  MULTIPLY = counter++;\n  NOT = counter++;\n  NROOTS = counter++;\n  NUMBER = counter++;\n  NUMERATOR = counter++;\n  OPERATOR = counter++;\n  OR = counter++;\n  OUTER = counter++;\n  PATTERN = counter++;\n  PATTERNSINFO = counter++;\n  POLAR = counter++;\n  POWER = counter++;\n  PRIME = counter++;\n  PRINT_LEAVE_E_ALONE = counter++;\n  PRINT_LEAVE_X_ALONE = counter++;\n  PRINT = counter++;\n  PRINT2DASCII = counter++;\n  PRINTFULL = counter++;\n  PRINTLATEX = counter++;\n  PRINTLIST = counter++;\n  PRINTPLAIN = counter++;\n  PRODUCT = counter++;\n  QUOTE = counter++;\n  QUOTIENT = counter++;\n  RANK = counter++;\n  RATIONALIZE = counter++;\n  REAL = counter++;\n  ROUND = counter++;\n  YYRECT = counter++;\n  ROOTS = counter++;\n  SETQ = counter++;\n  SGN = counter++;\n  SILENTPATTERN = counter++;\n  SIMPLIFY = counter++;\n  SIN = counter++;\n  SINH = counter++;\n  SHAPE = counter++;\n  SQRT = counter++;\n  STOP = counter++;\n  SUBST = counter++;\n  SUM = counter++;\n  SYMBOLSINFO = counter++;\n  TAN = counter++;\n  TANH = counter++;\n  TAYLOR = counter++;\n  TEST = counter++;\n  TESTEQ = counter++;\n  TESTGE = counter++;\n  TESTGT = counter++;\n  TESTLE = counter++;\n  TESTLT = counter++;\n  TRANSPOSE = counter++;\n  UNIT = counter++;\n  ZERO = counter++;\n  NIL = counter++;\n  LAST = counter++;\n  LAST_PRINT = counter++;\n  LAST_2DASCII_PRINT = counter++;\n  LAST_FULL_PRINT = counter++;\n  LAST_LATEX_PRINT = counter++;\n  LAST_LIST_PRINT = counter++;\n  LAST_PLAIN_PRINT = counter++;\n  AUTOEXPAND = counter++;\n  BAKE = counter++;\n  ASSUME_REAL_VARIABLES = counter++;\n  TRACE = counter++;\n  FORCE_FIXED_PRINTOUT = counter++;\n  MAX_FIXED_PRINTOUT_DIGITS = counter++;\n  YYE = counter++;\n  DRAWX = counter++;\n  METAA = counter++;\n  METAB = counter++;\n  METAX = counter++;\n  SECRETX = counter++;\n  VERSION = counter++;\n  PI = counter++;\n  SYMBOL_A = counter++;\n  SYMBOL_B = counter++;\n  SYMBOL_C = counter++;\n  SYMBOL_D = counter++;\n  SYMBOL_I = counter++;\n  SYMBOL_J = counter++;\n  SYMBOL_N = counter++;\n  SYMBOL_R = counter++;\n  SYMBOL_S = counter++;\n  SYMBOL_T = counter++;\n  SYMBOL_X = counter++;\n  SYMBOL_Y = counter++;\n  SYMBOL_Z = counter++;\n  SYMBOL_IDENTITY_MATRIX = counter++;\n  SYMBOL_A_UNDERSCORE = counter++;\n  SYMBOL_B_UNDERSCORE = counter++;\n  SYMBOL_X_UNDERSCORE = counter++;\n  C1 = counter++;\n  C2 = counter++;\n  C3 = counter++;\n  C4 = counter++;\n  C5 = counter++;\n  C6 = counter++;\n  USR_SYMBOLS = counter++;\n  E = YYE;\n  TOS = 100000;\n  BUF = 10000;\n  MAX_PROGRAM_SIZE = 100001;\n  MAXPRIMETAB = 10000;\n  MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES = 5;\n  MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE = 10;\n  MAXDIM = 24;\n  symbolsDependencies = {};\n  symbolsHavingReassignments = [];\n  symbolsInExpressionsWithoutAssignments = [];\n  patternHasBeenFound = false;\n  predefinedSymbolsInGlobalScope_doNotTrackInDependencies = [\"rationalize\", \"abs\", \"e\", \"i\", \"pi\", \"sin\", \"ceiling\", \"cos\", \"roots\", \"integral\", \"derivative\", \"defint\", \"sqrt\", \"eig\", \"cov\", \"deig\", \"dcov\", \"float\", \"floor\", \"product\", \"root\", \"round\", \"sum\", \"test\", \"unit\"];\n  parse_time_simplifications = true;\n  chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n  stringsEmittedByUserPrintouts = \"\";\n  called_from_Algebra_block = false;\n\n  tensor = function () {\n    tensor.prototype.ndim = 0;\n    tensor.prototype.dim = null;\n    tensor.prototype.nelem = 0;\n    tensor.prototype.elem = null;\n\n    function tensor() {\n      this.dim = function () {\n        var o, ref, results;\n        results = [];\n\n        for (o = 0, ref = MAXDIM; 0 <= ref ? o <= ref : o >= ref; 0 <= ref ? o++ : o--) {\n          results.push(0);\n        }\n\n        return results;\n      }();\n\n      this.elem = [];\n    }\n\n    return tensor;\n  }();\n\n  display = function () {\n    function display() {}\n\n    display.prototype.h = 0;\n    display.prototype.w = 0;\n    display.prototype.n = 0;\n    display.prototype.a = [];\n    return display;\n  }();\n\n  text_metric = function () {\n    function text_metric() {}\n\n    text_metric.prototype.ascent = 0;\n    text_metric.prototype.descent = 0;\n    text_metric.prototype.width = 0;\n    return text_metric;\n  }();\n\n  tos = 0;\n  expanding = 0;\n  evaluatingAsFloats = 0;\n  evaluatingPolar = 0;\n  fmt_x = 0;\n  fmt_index = 0;\n  fmt_level = 0;\n  verbosing = 0;\n\n  primetab = function () {\n    var ceil, i, j, primes;\n    primes = [2];\n    i = 3;\n\n    while (primes.length < MAXPRIMETAB) {\n      j = 0;\n      ceil = Math.sqrt(i);\n\n      while (j < primes.length && primes[j] <= ceil) {\n        if (i % primes[j] === 0) {\n          j = -1;\n          break;\n        }\n\n        j++;\n      }\n\n      if (j !== -1) {\n        primes.push(i);\n      }\n\n      i += 2;\n    }\n\n    primes[MAXPRIMETAB] = 0;\n    return primes;\n  }();\n\n  esc_flag = 0;\n  draw_flag = 0;\n  mtotal = 0;\n  trigmode = 0;\n  logbuf = \"\";\n  program_buf = \"\";\n  symtab = [];\n  binding = [];\n  isSymbolReclaimable = [];\n  arglist = [];\n  stack = [];\n  frame = 0;\n  p0 = null;\n  p1 = null;\n  p2 = null;\n  p3 = null;\n  p4 = null;\n  p5 = null;\n  p6 = null;\n  p7 = null;\n  p8 = null;\n  p9 = null;\n  zero = null;\n  one = null;\n  one_as_double = null;\n  imaginaryunit = null;\n  out_buf = \"\";\n  out_count = 0;\n  test_flag = 0;\n  codeGen = false;\n  draw_stop_return = null;\n  userSimplificationsInListForm = [];\n  userSimplificationsInStringForm = [];\n  transpose_unicode = 7488;\n  dotprod_unicode = 183;\n\n  symbol = function symbol(x) {\n    return symtab[x];\n  };\n\n  iscons = function iscons(p) {\n    return p.k === CONS;\n  };\n\n  isrational = function isrational(p) {\n    return p.k === NUM;\n  };\n\n  isdouble = function isdouble(p) {\n    return p.k === DOUBLE;\n  };\n\n  isNumericAtom = function isNumericAtom(p) {\n    return isrational(p) || isdouble(p);\n  };\n\n  isstr = function isstr(p) {\n    return p.k === STR;\n  };\n\n  istensor = function istensor(p) {\n    if (p == null) {\n      debugger;\n    } else {\n      return p.k === TENSOR;\n    }\n  };\n\n  _isNumericAtomOrTensor = function isNumericAtomOrTensor(p) {\n    var a, i, n, o, ref;\n\n    if (isNumericAtom(p) || p === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      return 1;\n    }\n\n    if (!istensor(p) && !isNumericAtom(p)) {\n      return 0;\n    }\n\n    n = p.tensor.nelem;\n    a = p.tensor.elem;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (!_isNumericAtomOrTensor(a[i])) {\n        return 0;\n      }\n    }\n\n    return 1;\n  };\n\n  issymbol = function issymbol(p) {\n    return p.k === SYM;\n  };\n\n  iskeyword = function iskeyword(p) {\n    return issymbol(p) && symnum(p) < NIL;\n  };\n\n  car = function car(p) {\n    if (iscons(p)) {\n      return p.cons.car;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  cdr = function cdr(p) {\n    if (iscons(p)) {\n      return p.cons.cdr;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  caar = function caar(p) {\n    return car(car(p));\n  };\n\n  cadr = function cadr(p) {\n    return car(cdr(p));\n  };\n\n  cdar = function cdar(p) {\n    return cdr(car(p));\n  };\n\n  cddr = function cddr(p) {\n    return cdr(cdr(p));\n  };\n\n  caadr = function caadr(p) {\n    return car(car(cdr(p)));\n  };\n\n  caddr = function caddr(p) {\n    return car(cdr(cdr(p)));\n  };\n\n  cadar = function cadar(p) {\n    return car(cdr(car(p)));\n  };\n\n  cdadr = function cdadr(p) {\n    return cdr(car(cdr(p)));\n  };\n\n  cddar = function cddar(p) {\n    return cdr(cdr(car(p)));\n  };\n\n  cdddr = function cdddr(p) {\n    return cdr(cdr(cdr(p)));\n  };\n\n  caaddr = function caaddr(p) {\n    return car(car(cdr(cdr(p))));\n  };\n\n  cadadr = function cadadr(p) {\n    return car(cdr(car(cdr(p))));\n  };\n\n  caddar = function caddar(p) {\n    return car(cdr(cdr(car(p))));\n  };\n\n  cdaddr = function cdaddr(p) {\n    return cdr(car(cdr(cdr(p))));\n  };\n\n  cadddr = function cadddr(p) {\n    return car(cdr(cdr(cdr(p))));\n  };\n\n  cddddr = function cddddr(p) {\n    return cdr(cdr(cdr(cdr(p))));\n  };\n\n  caddddr = function caddddr(p) {\n    return car(cdr(cdr(cdr(cdr(p)))));\n  };\n\n  cadaddr = function cadaddr(p) {\n    return car(cdr(car(cdr(cdr(p)))));\n  };\n\n  cddaddr = function cddaddr(p) {\n    return cdr(cdr(car(cdr(cdr(p)))));\n  };\n\n  caddadr = function caddadr(p) {\n    return car(cdr(cdr(car(cdr(p)))));\n  };\n\n  cdddaddr = function cdddaddr(p) {\n    return cdr(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  caddaddr = function caddaddr(p) {\n    return car(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  listLength = function listLength(p) {\n    var startCount;\n    startCount = -1;\n\n    while (iscons(p)) {\n      p = cdr(p);\n      startCount++;\n    }\n\n    return startCount;\n  };\n\n  nthCadr = function nthCadr(p, n) {\n    var startCount;\n    startCount = 0;\n\n    while (startCount <= n) {\n      p = cdr(p);\n      startCount++;\n    }\n\n    return car(p);\n  };\n\n  isadd = function isadd(p) {\n    return car(p) === symbol(ADD);\n  };\n\n  ismultiply = function ismultiply(p) {\n    return car(p) === symbol(MULTIPLY);\n  };\n\n  ispower = function ispower(p) {\n    return car(p) === symbol(POWER);\n  };\n\n  isfactorial = function isfactorial(p) {\n    return car(p) === symbol(FACTORIAL);\n  };\n\n  isinnerordot = function isinnerordot(p) {\n    return car(p) === symbol(INNER) || car(p) === symbol(DOT);\n  };\n\n  istranspose = function istranspose(p) {\n    return car(p) === symbol(TRANSPOSE);\n  };\n\n  isinv = function isinv(p) {\n    return car(p) === symbol(INV);\n  };\n\n  isidentitymatrix = function isidentitymatrix(p) {\n    return p === symbol(SYMBOL_IDENTITY_MATRIX);\n  };\n\n  MSIGN = function MSIGN(p) {\n    if (p.isPositive()) {\n      return 1;\n    } else if (p.isZero()) {\n      return 0;\n    } else {\n      return -1;\n    }\n  };\n\n  MLENGTH = function MLENGTH(p) {\n    return p.toString().length;\n  };\n\n  MZERO = function MZERO(p) {\n    return p.isZero();\n  };\n\n  MEQUAL = function MEQUAL(p, n) {\n    if (p == null) {\n      debugger;\n    }\n\n    return p.equals(n);\n  };\n\n  reset_after_error = function reset_after_error() {\n    moveTos(0);\n    esc_flag = 0;\n    draw_flag = 0;\n    frame = TOS;\n    evaluatingAsFloats = 0;\n    return evaluatingPolar = 0;\n  };\n\n  $ = typeof exports !== \"undefined\" && exports !== null ? exports : this;\n  $.version = version;\n  $.isadd = isadd;\n  $.ismultiply = ismultiply;\n  $.ispower = ispower;\n  $.isfactorial = isfactorial;\n  $.car = car;\n  $.cdr = cdr;\n  $.caar = caar;\n  $.cadr = cadr;\n  $.cdar = cdar;\n  $.cddr = cddr;\n  $.caadr = caadr;\n  $.caddr = caddr;\n  $.cadar = cadar;\n  $.cdadr = cdadr;\n  $.cddar = cddar;\n  $.cdddr = cdddr;\n  $.caaddr = caaddr;\n  $.cadadr = cadadr;\n  $.caddar = caddar;\n  $.cdaddr = cdaddr;\n  $.cadddr = cadddr;\n  $.cddddr = cddddr;\n  $.caddddr = caddddr;\n  $.cadaddr = cadaddr;\n  $.cddaddr = cddaddr;\n  $.caddadr = caddadr;\n  $.cdddaddr = cdddaddr;\n  $.caddaddr = caddaddr;\n  $.symbol = symbol;\n  $.iscons = iscons;\n  $.isrational = isrational;\n  $.isdouble = isdouble;\n  $.isNumericAtom = isNumericAtom;\n  $.isstr = isstr;\n  $.istensor = istensor;\n  $.issymbol = issymbol;\n  $.iskeyword = iskeyword;\n  $.CONS = CONS;\n  $.NUM = NUM;\n  $.DOUBLE = DOUBLE;\n  $.STR = STR;\n  $.TENSOR = TENSOR;\n  $.SYM = SYM;\n  /* abs =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the absolute value of a real number, the magnitude of a complex number, or the vector length.\n   */\n\n  /*\n   Absolute value of a number,or magnitude of complex z, or norm of a vector\n  \n    z    abs(z)\n    -    ------\n  \n    a    a\n  \n    -a    a\n  \n    (-1)^a    1\n  \n    exp(a + i b)  exp(a)\n  \n    a b    abs(a) abs(b)\n  \n    a + i b    sqrt(a^2 + b^2)\n  \n  Notes\n  \n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n  \n    2. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n  \n      abs(numerator(z)) / abs(denominator(z))\n  \n       must be used to get the correct answer. Now the operation is\n       automatic.\n   */\n\n  DEBUG_ABS = false;\n\n  Eval_abs = function Eval_abs() {\n    push(cadr(p1));\n    Eval();\n    return abs();\n  };\n\n  absValFloat = function absValFloat() {\n    Eval();\n\n    _absval();\n\n    Eval();\n    return zzfloat();\n  };\n\n  abs = function abs() {\n    var theArgument;\n    theArgument = top();\n\n    if (DEBUG_ABS) {\n      console.trace(\">>>>  ABS of \" + theArgument);\n    }\n\n    _numerator();\n\n    if (DEBUG_ABS) {\n      console.log(\"ABS numerator \" + stack[tos - 1]);\n    }\n\n    _absval();\n\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL numerator: \" + stack[tos - 1]);\n    }\n\n    push(theArgument);\n\n    _denominator();\n\n    if (DEBUG_ABS) {\n      console.log(\"ABS denominator: \" + stack[tos - 1]);\n    }\n\n    _absval();\n\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL denominator: \" + stack[tos - 1]);\n    }\n\n    divide();\n\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL divided: \" + stack[tos - 1]);\n    }\n\n    if (DEBUG_ABS) {\n      return console.log(\"<<<<<<<  ABS\");\n    }\n  };\n\n  _absval = function absval() {\n    var anyFactorsYet, input;\n    save();\n    p1 = pop();\n    input = p1;\n\n    if (DEBUG_ABS) {\n      console.log(\"ABS of \" + p1);\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just zero\");\n      }\n\n      push(zero);\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (isnegativenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a negative\");\n      }\n\n      push(p1);\n      negate();\n      restore();\n      return;\n    }\n\n    if (ispositivenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a positive\");\n      }\n\n      push(p1);\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (p1 === symbol(PI)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" of PI\");\n      }\n\n      push(p1);\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(ADD) && (_findPossibleClockForm(p1) || _findPossibleExponentialForm(p1) || _Find(p1, imaginaryunit))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a sum\");\n      }\n\n      if (DEBUG_ABS) {\n        console.log(\"abs of a sum\");\n      }\n\n      push(p1);\n\n      _rect();\n\n      p1 = pop();\n      push(p1);\n      real();\n      push_integer(2);\n      power();\n      push(p1);\n      imag();\n      push_integer(2);\n      power();\n      add();\n      push_rational(1, 2);\n      power();\n      simplify_trig();\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is -1 to any power\");\n      }\n\n      if (evaluatingAsFloats) {\n        if (DEBUG_ABS) {\n          console.log(\" abs: numeric, so result is 1.0\");\n        }\n\n        push_double(1.0);\n      } else {\n        if (DEBUG_ABS) {\n          console.log(\" abs: symbolic, so result is 1\");\n        }\n\n        push_integer(1);\n      }\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER) && ispositivenumber(caddr(p1))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is something to the power of a positive number\");\n      }\n\n      push(cadr(p1));\n      abs();\n      push(caddr(p1));\n      power();\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is an exponential\");\n      }\n\n      push(caddr(p1));\n      real();\n      exponential();\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a product\");\n      }\n\n      anyFactorsYet = false;\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _absval();\n\n        if (anyFactorsYet) {\n          multiply();\n        }\n\n        anyFactorsYet = true;\n        p1 = cdr(p1);\n      }\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(ABS)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is abs of a abs\");\n      }\n\n      push_symbol(ABS);\n      push(cadr(p1));\n      list(2);\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n    /*\n     * Evaluation via zzfloat()\n     * ...while this is in theory a powerful mechanism, I've commented it\n     * out because I've refined this method enough to not need this.\n     * Evaling via zzfloat() is in principle more problematic because it could\n     * require further evaluations which could end up in further \"abs\" which\n     * would end up in infinite loops. Better not use it if not necessary.\n    \n     * we look directly at the float evaluation of the argument\n     * to see if we end up with a number, which would mean that there\n     * is no imaginary component and we can just return the input\n     * (or its negation) as the result.\n    push p1\n    zzfloat()\n    floatEvaluation = pop()\n    \n    if (isnegativenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a negative\"\n      push(p1)\n      negate()\n      restore()\n      return\n    \n    if (ispositivenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a positive\"\n      push(p1)\n      if DEBUG_ABS then console.log \" --> ABS of \" + input + \" : \" + stack[tos-1]\n      restore()\n      return\n     */\n\n\n    if (istensor(p1)) {\n      absval_tensor();\n      restore();\n      return;\n    }\n\n    if (isnegativeterm(p1) || car(p1) === symbol(ADD) && isnegativeterm(cadr(p1))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n\n    if (DEBUG_ABS) {\n      console.log(\" abs: \" + p1 + \" is nothing decomposable\");\n    }\n\n    push_symbol(ABS);\n    push(p1);\n    list(2);\n\n    if (DEBUG_ABS) {\n      console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n    }\n\n    return restore();\n  };\n\n  absval_tensor = function absval_tensor() {\n    if (p1.tensor.ndim !== 1) {\n      stop(\"abs(tensor) with tensor rank > 1\");\n    }\n\n    push(p1);\n    push(p1);\n    conjugate();\n\n    _inner();\n\n    push_rational(1, 2);\n    power();\n    simplify();\n    return Eval();\n  };\n  /*\n   Symbolic addition\n  \n    Terms in a sum are combined if they are identical modulo rational\n    coefficients.\n  \n    For example, A + 2A becomes 3A.\n  \n    However, the sum A + sqrt(2) A is not modified.\n  \n    Combining terms can lead to second-order effects.\n  \n    For example, consider the case of\n  \n      1/sqrt(2) A + 3/sqrt(2) A + sqrt(2) A\n  \n    The first two terms are combined to yield 2 sqrt(2) A.\n  \n    This result can now be combined with the third term to yield\n  \n      3 sqrt(2) A\n   */\n\n\n  flag = 0;\n\n  Eval_add = function Eval_add() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p2 = pop();\n      push_terms(p2);\n      p1 = cdr(p1);\n    }\n\n    return add_terms(tos - h);\n  };\n\n  stackAddsCount = 0;\n\n  add_terms = function add_terms(n) {\n    var h, i, i1, j1, o, ref, ref1, results, s, subsetOfStack;\n    stackAddsCount++;\n    i = 0;\n    h = tos - n;\n    s = h;\n\n    if (DEBUG) {\n      console.log(\"stack before adding terms #\" + stackAddsCount);\n    }\n\n    if (DEBUG) {\n      for (i = o = 0, ref = tos; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        console.log(_print_list(stack[i]));\n      }\n    }\n\n    for (i = i1 = 0; i1 < 10; i = ++i1) {\n      if (n < 2) {\n        break;\n      }\n\n      flag = 0;\n      subsetOfStack = stack.slice(h, h + n);\n      subsetOfStack.sort(cmp_terms);\n      stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n\n      if (flag === 0) {\n        break;\n      }\n\n      n = combine_terms(h, n);\n    }\n\n    moveTos(h + n);\n\n    switch (n) {\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n\n        break;\n\n      case 1:\n        break;\n\n      default:\n        list(n);\n        p1 = pop();\n        push_symbol(ADD);\n        push(p1);\n        cons();\n    }\n\n    if (DEBUG) {\n      console.log(\"stack after adding terms #\" + stackAddsCount);\n    }\n\n    if (DEBUG) {\n      results = [];\n\n      for (i = j1 = 0, ref1 = tos; 0 <= ref1 ? j1 < ref1 : j1 > ref1; i = 0 <= ref1 ? ++j1 : --j1) {\n        results.push(console.log(_print_list(stack[i])));\n      }\n\n      return results;\n    }\n  };\n\n  cmp_terms_count = 0;\n\n  cmp_terms = function cmp_terms(p1, p2) {\n    var i, o, ref, t;\n    cmp_terms_count++;\n    i = 0;\n\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      flag = 1;\n      return 0;\n    }\n\n    if (istensor(p1) && istensor(p2)) {\n      if (p1.tensor.ndim < p2.tensor.ndim) {\n        return -1;\n      }\n\n      if (p1.tensor.ndim > p2.tensor.ndim) {\n        return 1;\n      }\n\n      for (i = o = 0, ref = p1.tensor.ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n          return -1;\n        }\n\n        if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n          return 1;\n        }\n      }\n\n      flag = 1;\n      return 0;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      if (isNumericAtom(car(p1))) {\n        p1 = cdr(p1);\n\n        if (cdr(p1) === symbol(NIL)) {\n          p1 = car(p1);\n        }\n      }\n    }\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n\n      if (isNumericAtom(car(p2))) {\n        p2 = cdr(p2);\n\n        if (cdr(p2) === symbol(NIL)) {\n          p2 = car(p2);\n        }\n      }\n    }\n\n    t = _cmp_expr(p1, p2);\n\n    if (t === 0) {\n      flag = 1;\n    }\n\n    return t;\n  };\n  /*\n   Compare adjacent terms in s[] and combine if possible.\n  \n    Returns the number of terms remaining in s[].\n  \n    n  number of terms in s[] initially\n   */\n\n\n  combine_terms = function combine_terms(s, n) {\n    var i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t;\n    i = 0;\n\n    while (i < n - 1) {\n      check_esc_flag();\n      p3 = stack[s + i];\n      p4 = stack[s + i + 1];\n\n      if (istensor(p3) && istensor(p4)) {\n        push(p3);\n        push(p4);\n        tensor_plus_tensor();\n        p1 = pop();\n\n        if (p1 !== symbol(NIL)) {\n          stack[s + i] = p1;\n\n          for (j = o = ref = i + 1, ref1 = n - 1; ref <= ref1 ? o < ref1 : o > ref1; j = ref <= ref1 ? ++o : --o) {\n            stack[s + j] = stack[s + j + 1];\n          }\n\n          n--;\n          i--;\n        }\n\n        i++;\n        continue;\n      }\n\n      if (istensor(p3) || istensor(p4)) {\n        i++;\n        continue;\n      }\n\n      if (isNumericAtom(p3) && isNumericAtom(p4)) {\n        push(p3);\n        push(p4);\n        add_numbers();\n        p1 = pop();\n\n        if (isZeroAtomOrTensor(p1)) {\n          for (j = i1 = ref2 = i, ref3 = n - 2; ref2 <= ref3 ? i1 < ref3 : i1 > ref3; j = ref2 <= ref3 ? ++i1 : --i1) {\n            stack[s + j] = stack[s + j + 2];\n          }\n\n          n -= 2;\n        } else {\n          stack[s + i] = p1;\n\n          for (j = j1 = ref4 = i + 1, ref5 = n - 1; ref4 <= ref5 ? j1 < ref5 : j1 > ref5; j = ref4 <= ref5 ? ++j1 : --j1) {\n            stack[s + j] = stack[s + j + 1];\n          }\n\n          n--;\n        }\n\n        i--;\n        i++;\n        continue;\n      }\n\n      if (isNumericAtom(p3) || isNumericAtom(p4)) {\n        i++;\n        continue;\n      }\n\n      if (evaluatingAsFloats) {\n        p1 = one_as_double;\n        p2 = one_as_double;\n      } else {\n        p1 = one;\n        p2 = one;\n      }\n\n      t = 0;\n\n      if (car(p3) === symbol(MULTIPLY)) {\n        p3 = cdr(p3);\n        t = 1;\n\n        if (isNumericAtom(car(p3))) {\n          p1 = car(p3);\n          p3 = cdr(p3);\n\n          if (cdr(p3) === symbol(NIL)) {\n            p3 = car(p3);\n            t = 0;\n          }\n        }\n      }\n\n      if (car(p4) === symbol(MULTIPLY)) {\n        p4 = cdr(p4);\n\n        if (isNumericAtom(car(p4))) {\n          p2 = car(p4);\n          p4 = cdr(p4);\n\n          if (cdr(p4) === symbol(NIL)) {\n            p4 = car(p4);\n          }\n        }\n      }\n\n      if (!equal(p3, p4)) {\n        i++;\n        continue;\n      }\n\n      push(p1);\n      push(p2);\n      add_numbers();\n      p1 = pop();\n\n      if (isZeroAtomOrTensor(p1)) {\n        for (j = l1 = ref6 = i, ref7 = n - 2; ref6 <= ref7 ? l1 < ref7 : l1 > ref7; j = ref6 <= ref7 ? ++l1 : --l1) {\n          stack[s + j] = stack[s + j + 2];\n        }\n\n        n -= 2;\n        i--;\n        i++;\n        continue;\n      }\n\n      push(p1);\n\n      if (t) {\n        push(symbol(MULTIPLY));\n        push(p3);\n        cons();\n      } else {\n        push(p3);\n      }\n\n      multiply();\n      stack[s + i] = pop();\n\n      for (j = m1 = ref8 = i + 1, ref9 = n - 1; ref8 <= ref9 ? m1 < ref9 : m1 > ref9; j = ref8 <= ref9 ? ++m1 : --m1) {\n        stack[s + j] = stack[s + j + 1];\n      }\n\n      n--;\n      i--;\n      i++;\n    }\n\n    return n;\n  };\n\n  push_terms = function push_terms(p) {\n    var results;\n\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else if (!isZeroAtom(p)) {\n      return push(p);\n    }\n  };\n\n  add = function add() {\n    var h;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push_terms(p1);\n    push_terms(p2);\n    add_terms(tos - h);\n    return restore();\n  };\n\n  add_all = function add_all(k) {\n    var h, i, o, ref, s;\n    i = 0;\n    save();\n    s = tos - k;\n    h = tos;\n\n    for (i = o = 0, ref = k; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push_terms(stack[s + i]);\n    }\n\n    add_terms(tos - h);\n    p1 = pop();\n    moveTos(tos - k);\n    push(p1);\n    return restore();\n  };\n\n  subtract = function subtract() {\n    negate();\n    return add();\n  };\n  /* adj =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m\n  \n  General description\n  -------------------\n  Returns the adjunct of matrix m. The inverse of m is equal to adj(m) divided by det(m).\n   */\n\n\n  Eval_adj = function Eval_adj() {\n    push(cadr(p1));\n    Eval();\n    return adj();\n  };\n\n  adj = function adj() {\n    var doNothing, i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p1 = pop();\n\n    if (istensor(p1) && p1.tensor.ndim === 2 && p1.tensor.dim[0] === p1.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"adj: square matrix expected\");\n    }\n\n    n = p1.tensor.dim[0];\n    p2 = alloc_tensor(n * n);\n    p2.tensor.ndim = 2;\n    p2.tensor.dim[0] = n;\n    p2.tensor.dim[1] = n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        cofactor(p1, n, i, j);\n        p2.tensor.elem[n * j + i] = pop();\n      }\n    }\n\n    push(p2);\n    return restore();\n  };\n  /*\n   Guesses a rational for each float in the passed expression\n   */\n\n\n  Eval_approxratio = function Eval_approxratio() {\n    var theArgument;\n    theArgument = cadr(p1);\n    push(theArgument);\n    return _approxratioRecursive();\n  };\n\n  _approxratioRecursive = function approxratioRecursive() {\n    var i, i1, o, ref, ref1;\n    i = 0;\n    save();\n    p1 = pop();\n\n    if (istensor(p1)) {\n      p4 = alloc_tensor(p1.tensor.nelem);\n      p4.tensor.ndim = p1.tensor.ndim;\n\n      for (i = o = 0, ref = p1.tensor.ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        p4.tensor.dim[i] = p1.tensor.dim[i];\n      }\n\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n\n        _approxratioRecursive();\n\n        p4.tensor.elem[i] = pop();\n        check_tensor_dimensions(p4);\n      }\n\n      push(p4);\n    } else if (p1.k === DOUBLE) {\n      push(p1);\n      approxOneRatioOnly();\n    } else if (iscons(p1)) {\n      push(car(p1));\n\n      _approxratioRecursive();\n\n      push(cdr(p1));\n\n      _approxratioRecursive();\n\n      cons();\n    } else {\n      push(p1);\n    }\n\n    return restore();\n  };\n\n  approxOneRatioOnly = function approxOneRatioOnly() {\n    var numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot, supposedlyTheFloat, theFloat, theRatio;\n    zzfloat();\n    supposedlyTheFloat = pop();\n\n    if (supposedlyTheFloat.k === DOUBLE) {\n      theFloat = supposedlyTheFloat.d;\n      splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n      if (splitBeforeAndAfterDot.length === 2) {\n        numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n        precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n        theRatio = floatToRatioRoutine(theFloat, precision);\n        push_rational(theRatio[0], theRatio[1]);\n      } else {\n        push_integer(theFloat);\n      }\n\n      return;\n    }\n\n    push_symbol(APPROXRATIO);\n    push(theArgument);\n    return list(2);\n  };\n\n  floatToRatioRoutine = function floatToRatioRoutine(decimal, AccuracyFactor) {\n    var DecimalSign, FractionDenominator, FractionNumerator, PreviousDenominator, ScratchValue, Z, ret;\n    FractionNumerator = void 0;\n    FractionDenominator = void 0;\n    DecimalSign = void 0;\n    Z = void 0;\n    PreviousDenominator = void 0;\n    ScratchValue = void 0;\n    ret = [0, 0];\n\n    if (isNaN(decimal)) {\n      return ret;\n    }\n\n    if (decimal === 2e308) {\n      ret[0] = 1;\n      ret[1] = 0;\n      return ret;\n    }\n\n    if (decimal === -2e308) {\n      ret[0] = -1;\n      ret[1] = 0;\n      return ret;\n    }\n\n    if (decimal < 0.0) {\n      DecimalSign = -1.0;\n    } else {\n      DecimalSign = 1.0;\n    }\n\n    decimal = Math.abs(decimal);\n\n    if (Math.abs(decimal - Math.floor(decimal)) < AccuracyFactor) {\n      FractionNumerator = decimal * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n\n    if (decimal < 1.0e-19) {\n      FractionNumerator = DecimalSign;\n      FractionDenominator = 9999999999999999999.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n\n    if (decimal > 1.0e19) {\n      FractionNumerator = 9999999999999999999.0 * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n\n    Z = decimal;\n    PreviousDenominator = 0.0;\n    FractionDenominator = 1.0;\n\n    while (true) {\n      Z = 1.0 / (Z - Math.floor(Z));\n      ScratchValue = FractionDenominator;\n      FractionDenominator = FractionDenominator * Math.floor(Z) + PreviousDenominator;\n      PreviousDenominator = ScratchValue;\n      FractionNumerator = Math.floor(decimal * FractionDenominator + 0.5);\n\n      if (!(Math.abs(decimal - FractionNumerator / FractionDenominator) > AccuracyFactor && Z !== Math.floor(Z))) {\n        break;\n      }\n    }\n\n    FractionNumerator = DecimalSign * FractionNumerator;\n    ret[0] = FractionNumerator;\n    ret[1] = FractionDenominator;\n    return ret;\n  };\n\n  approx_just_an_integer = 0;\n  approx_sine_of_rational = 1;\n  approx_sine_of_pi_times_rational = 2;\n  approx_rationalOfPi = 3;\n  approx_radicalOfRatio = 4;\n  approx_nothingUseful = 5;\n  approx_ratioOfRadical = 6;\n  approx_rationalOfE = 7;\n  approx_logarithmsOfRationals = 8;\n  approx_rationalsOfLogarithms = 9;\n\n  approxRationalsOfRadicals = function approxRationalsOfRadicals(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n\n      for (j = i1 = 1; i1 <= 10; j = ++i1) {\n        hypothesis = Math.sqrt(i) / j;\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sqrt( \" + i + \" ) / \" + j;\n            bestResultSoFar = [result, approx_ratioOfRadical, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxRadicalsOfRationals = function approxRadicalsOfRationals(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, len1, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, ref1, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [1, 2, 3, 5, 6, 7, 8, 10];\n\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [1, 2, 3, 5, 6, 7, 8, 10];\n\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n        hypothesis = Math.sqrt(i / j);\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (sqrt( \" + i + \" / \" + j + \" )\";\n            bestResultSoFar = [result, approx_radicalOfRatio, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxRadicals = function approxRadicals(theFloat) {\n    var approxRadicalsOfRationalsResult, approxRationalsOfRadicalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    approxRationalsOfRadicalsResult = approxRationalsOfRadicals(theFloat);\n\n    if (approxRationalsOfRadicalsResult != null) {\n      return approxRationalsOfRadicalsResult;\n    }\n\n    approxRadicalsOfRationalsResult = approxRadicalsOfRationals(theFloat);\n\n    if (approxRadicalsOfRationalsResult != null) {\n      return approxRadicalsOfRationalsResult;\n    }\n\n    return null;\n  };\n\n  approxLogs = function approxLogs(theFloat) {\n    var approxLogsOfRationalsResult, approxRationalsOfLogsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    approxRationalsOfLogsResult = approxRationalsOfLogs(theFloat);\n\n    if (approxRationalsOfLogsResult != null) {\n      return approxRationalsOfLogsResult;\n    }\n\n    approxLogsOfRationalsResult = approxLogsOfRationals(theFloat);\n\n    if (approxLogsOfRationalsResult != null) {\n      return approxLogsOfRationalsResult;\n    }\n\n    return null;\n  };\n\n  approxRationalsOfLogs = function approxRationalsOfLogs(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 2; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        hypothesis = Math.log(i) / j;\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (likelyMultiplier !== 1 && Math.abs(Math.floor(likelyMultiplier / j)) === Math.abs(likelyMultiplier / j)) {\n          continue;\n        }\n\n        if (error < 2.2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" ) / \" + j;\n            bestResultSoFar = [result, approx_rationalsOfLogarithms, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxLogsOfRationals = function approxLogsOfRationals(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        hypothesis = Math.log(i / j);\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 1.96 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" / \" + j + \" )\";\n            bestResultSoFar = [result, approx_logarithmsOfRationals, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfE = function approxRationalsOfPowersOfE(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 1; o <= 2; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        hypothesis = Math.pow(Math.E, i) / j;\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (e ^ \" + i + \" ) / \" + j;\n            bestResultSoFar = [result, approx_rationalOfE, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfPI = function approxRationalsOfPowersOfPI(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        hypothesis = Math.pow(Math.PI, i) / j;\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (pi ^ \" + i + \" ) / \" + j + \" )\";\n            bestResultSoFar = [result, approx_rationalOfPi, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxTrigonometric = function approxTrigonometric(theFloat) {\n    var approxSineOfRationalMultiplesOfPIResult, approxSineOfRationalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    approxSineOfRationalsResult = approxSineOfRationals(theFloat);\n\n    if (approxSineOfRationalsResult != null) {\n      return approxSineOfRationalsResult;\n    }\n\n    approxSineOfRationalMultiplesOfPIResult = approxSineOfRationalMultiplesOfPI(theFloat);\n\n    if (approxSineOfRationalMultiplesOfPIResult != null) {\n      return approxSineOfRationalMultiplesOfPIResult;\n    }\n\n    return null;\n  };\n\n  approxSineOfRationals = function approxSineOfRationals(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 1; o <= 4; i = ++o) {\n      for (j = i1 = 1; i1 <= 4; j = ++i1) {\n        fraction = i / j;\n        hypothesis = Math.sin(fraction);\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" )\";\n            bestResultSoFar = [result, approx_sine_of_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxSineOfRationalMultiplesOfPI = function approxSineOfRationalMultiplesOfPI(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 1; o <= 13; i = ++o) {\n      for (j = i1 = 1; i1 <= 13; j = ++i1) {\n        fraction = i / j;\n        hypothesis = Math.sin(Math.PI * fraction);\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 23 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" * pi )\";\n            bestResultSoFar = [result, approx_sine_of_pi_times_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxAll = function approxAll(theFloat) {\n    var LOG_EXPLANATIONS, approxLogsResult, approxRadicalsResult, approxRationalsOfPowersOfEResult, approxRationalsOfPowersOfPIResult, approxTrigonometricResult, bestApproxSoFar, constantsSum, constantsSumMin, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    constantsSumMin = Number.MAX_VALUE;\n    constantsSum = 0;\n    bestApproxSoFar = null;\n    LOG_EXPLANATIONS = true;\n    approxRadicalsResult = approxRadicals(theFloat);\n\n    if (approxRadicalsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRadicalsResult);\n\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRadicalsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n\n    approxLogsResult = approxLogs(theFloat);\n\n    if (approxLogsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxLogsResult);\n\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxLogsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n\n    approxRationalsOfPowersOfEResult = approxRationalsOfPowersOfE(theFloat);\n\n    if (approxRationalsOfPowersOfEResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfEResult);\n\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfEResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n\n    approxRationalsOfPowersOfPIResult = approxRationalsOfPowersOfPI(theFloat);\n\n    if (approxRationalsOfPowersOfPIResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfPIResult);\n\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfPIResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n\n    approxTrigonometricResult = approxTrigonometric(theFloat);\n\n    if (approxTrigonometricResult != null) {\n      constantsSum = simpleComplexityMeasure(approxTrigonometricResult);\n\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxTrigonometricResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n\n    return bestApproxSoFar;\n  };\n\n  simpleComplexityMeasure = function simpleComplexityMeasure(aResult, b, c) {\n    var theSum;\n    theSum = null;\n\n    if (aResult instanceof Array) {\n      switch (aResult[1]) {\n        case approx_sine_of_pi_times_rational:\n          theSum = 4;\n          break;\n\n        case approx_rationalOfPi:\n          theSum = Math.pow(4, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n\n        case approx_rationalOfE:\n          theSum = Math.pow(3, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n\n        default:\n          theSum = 0;\n      }\n\n      theSum += Math.abs(aResult[2]) * (Math.abs(aResult[3]) + Math.abs(aResult[4]));\n    } else {\n      theSum += Math.abs(aResult) * (Math.abs(b) + Math.abs(c));\n    }\n\n    if (aResult[2] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n\n    if (aResult[3] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n\n    if (aResult[4] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n\n    if (theSum < 0) {\n      theSum = 0;\n    }\n\n    return theSum;\n  };\n\n  testApprox = function testApprox() {\n    var error, fraction, i, i1, i2, i3, j, j1, j2, j3, k3, l1, l2, l3, len, len1, len2, len3, len4, len5, len6, len7, m1, m2, m3, n1, n2, o, o1, o2, originalValue, q1, q2, r1, r2, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, returned, returnedFraction, returnedValue, s1, s2, t1, t2, u1, u2, v1, v2, value, x1, x2, z1, z2;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [2, 3, 5, 6, 7, 8, 10];\n\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n\n        if (i === j) {\n          continue;\n        }\n\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.sqrt(i) / j;\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    ref2 = [2, 3, 5, 6, 7, 8, 10];\n\n    for (j1 = 0, len2 = ref2.length; j1 < len2; j1++) {\n      i = ref2[j1];\n      ref3 = [2, 3, 5, 6, 7, 8, 10];\n\n      for (l1 = 0, len3 = ref3.length; l1 < len3; l1++) {\n        j = ref3[l1];\n\n        if (i === j) {\n          continue;\n        }\n\n        console.log(\"testapproxRadicals testing with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.sqrt(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    ref4 = [2, 3, 5, 6, 7, 8, 10];\n\n    for (m1 = 0, len4 = ref4.length; m1 < len4; m1++) {\n      i = ref4[m1];\n      ref5 = [2, 3, 5, 6, 7, 8, 10];\n\n      for (n1 = 0, len5 = ref5.length; n1 < len5; n1++) {\n        j = ref5[n1];\n\n        if (i === j) {\n          continue;\n        }\n\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.sqrt(i / j);\n        returned = approxRadicals(value);\n\n        if (returned != null) {\n          returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n\n          if (returned[1] === approx_radicalOfRatio && Math.abs(value - returnedValue) > 1e-15) {\n            console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n          }\n        }\n      }\n    }\n\n    ref6 = [1, 2, 3, 5, 6, 7, 8, 10];\n\n    for (o1 = 0, len6 = ref6.length; o1 < len6; o1++) {\n      i = ref6[o1];\n      ref7 = [1, 2, 3, 5, 6, 7, 8, 10];\n\n      for (q1 = 0, len7 = ref7.length; q1 < len7; q1++) {\n        j = ref7[q1];\n\n        if (i === 1 && j === 1) {\n          continue;\n        }\n\n        console.log(\"testapproxRadicals testing with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sqrt(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n\n        if (returned[1] === approx_radicalOfRatio && Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = r1 = 1; r1 <= 5; i = ++r1) {\n      for (j = s1 = 1; s1 <= 5; j = ++s1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.log(i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = t1 = 1; t1 <= 5; i = ++t1) {\n      for (j = u1 = 1; u1 <= 5; j = ++u1) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.log(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = v1 = 1; v1 <= 5; i = ++v1) {\n      for (j = x1 = 1; x1 <= 5; j = ++x1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.log(i / j);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = z1 = 1; z1 <= 5; i = ++z1) {\n      for (j = i2 = 1; i2 <= 5; j = ++i2) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.log(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = j2 = 1; j2 <= 2; i = ++j2) {\n      for (j = l2 = 1; l2 <= 12; j = ++l2) {\n        console.log(\"testApproxAll testing: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.E, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = m2 = 1; m2 <= 2; i = ++m2) {\n      for (j = n2 = 1; n2 <= 12; j = ++n2) {\n        console.log(\"approxRationalsOfPowersOfE testing with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.E, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfE(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfE with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = o2 = 1; o2 <= 2; i = ++o2) {\n      for (j = q2 = 1; q2 <= 12; j = ++q2) {\n        console.log(\"testApproxAll testing: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.PI, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = r2 = 1; r2 <= 2; i = ++r2) {\n      for (j = s2 = 1; s2 <= 12; j = ++s2) {\n        console.log(\"approxRationalsOfPowersOfPI testing with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.PI, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfPI(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfPI with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = t2 = 1; t2 <= 4; i = ++t2) {\n      for (j = u2 = 1; u2 <= 4; j = ++u2) {\n        console.log(\"testApproxAll testing: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        value = Math.sin(fraction);\n        returned = approxAll(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = v2 = 1; v2 <= 4; i = ++v2) {\n      for (j = x2 = 1; x2 <= 4; j = ++x2) {\n        console.log(\"testApproxAll testing with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(5);\n        returned = approxAll(value);\n\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n\n    for (i = z2 = 1; z2 <= 4; i = ++z2) {\n      for (j = i3 = 1; i3 <= 4; j = ++i3) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n\n    value = 0;\n\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0\");\n    }\n\n    value = 0.0;\n\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0\");\n    }\n\n    value = 0.00;\n\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.00\");\n    }\n\n    value = 0.000;\n\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.000\");\n    }\n\n    value = 0.0000;\n\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0000\");\n    }\n\n    value = 1;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1\");\n    }\n\n    value = 1.0;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0\");\n    }\n\n    value = 1.00;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00\");\n    }\n\n    value = 1.000;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.000\");\n    }\n\n    value = 1.0000;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n\n    value = 1.00000;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00000\");\n    }\n\n    value = Math.sqrt(2);\n\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2)\");\n    }\n\n    value = 1.41;\n\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: 1.41\");\n    }\n\n    value = 1.4;\n\n    if (approxRadicals(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail approxRadicals: 1.4\");\n    }\n\n    value = 0.6;\n\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.6\");\n    }\n\n    value = 0.69;\n\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.69\");\n    }\n\n    value = 0.7;\n\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.7\");\n    }\n\n    value = 1.09;\n\n    if (approxLogs(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxLogs: 1.09\");\n    }\n\n    value = 1.09;\n\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.09\");\n    }\n\n    value = 1.098;\n\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.098\");\n    }\n\n    value = 1.1;\n\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.1\");\n    }\n\n    value = 1.11;\n\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.11\");\n    }\n\n    value = Math.sqrt(3);\n\n    if (approxAll(value)[0] !== \"1 * sqrt( 3 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(3)\");\n    }\n\n    value = 1.0000;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n\n    value = 3.141592;\n\n    if (approxAll(value)[0] !== \"1 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 3.141592\");\n    }\n\n    value = 31.41592;\n\n    if (approxAll(value)[0] !== \"10 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31.41592\");\n    }\n\n    value = 314.1592;\n\n    if (approxAll(value)[0] !== \"100 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 314.1592\");\n    }\n\n    value = 31415926.53589793;\n\n    if (approxAll(value)[0] !== \"10000000 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31415926.53589793\");\n    }\n\n    value = Math.sqrt(2);\n\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/4 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(2)\");\n    }\n\n    value = Math.sqrt(3);\n\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/3 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(3)\");\n    }\n\n    value = (Math.sqrt(6) - Math.sqrt(2)) / 4;\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) - Math.sqrt(2))/4\");\n    }\n\n    value = Math.sqrt(2 - Math.sqrt(2)) / 2;\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/8 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 - Math.sqrt(2))/2\");\n    }\n\n    value = (Math.sqrt(6) + Math.sqrt(2)) / 4;\n\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) + Math.sqrt(2))/4\");\n    }\n\n    value = Math.sqrt(2 + Math.sqrt(3)) / 2;\n\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 + Math.sqrt(3))/2\");\n    }\n\n    value = (Math.sqrt(5) - 1) / 4;\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/10 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(5) - 1)/4\");\n    }\n\n    value = Math.sqrt(10 - 2 * Math.sqrt(5)) / 4;\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/5 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(10 - 2*Math.sqrt(5))/4\");\n    }\n\n    value = Math.sin(Math.PI / 7);\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/7 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/7)\");\n    }\n\n    value = Math.sin(Math.PI / 9);\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/9 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/9)\");\n    }\n\n    value = 1836.15267;\n\n    if (approxRationalsOfPowersOfPI(value)[0] !== \"6 * (pi ^ 5 ) / 1 )\") {\n      console.log(\"fail approxRationalsOfPowersOfPI: 1836.15267\");\n    }\n\n    for (i = j3 = 1; j3 <= 13; i = ++j3) {\n      for (j = k3 = 1; k3 <= 13; j = ++k3) {\n        console.log(\"approxTrigonometric testing: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        value = Math.sin(Math.PI * fraction);\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail approxTrigonometric: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = l3 = 1; l3 <= 13; i = ++l3) {\n      for (j = m3 = 1; m3 <= 13; j = ++m3) {\n        if (i === 5 && j === 11 || i === 6 && j === 11) {\n          continue;\n        }\n\n        console.log(\"approxTrigonometric testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        originalValue = Math.sin(Math.PI * fraction);\n        value = originalValue.toFixed(4);\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n\n        if (error > 1e-14) {\n          console.log(\"fail approxTrigonometric with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n\n    return console.log(\"testApprox done\");\n  };\n\n  $.approxRadicals = approxRadicals;\n  $.approxRationalsOfLogs = approxRationalsOfLogs;\n  $.approxAll = approxAll;\n  $.testApprox = testApprox;\n  /* arccos =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse cosine of x.\n   */\n\n  Eval_arccos = function Eval_arccos() {\n    push(cadr(p1));\n    Eval();\n    return arccos();\n  };\n\n  arccos = function arccos() {\n    var d, errno, n;\n    n = 0;\n    d = 0.0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.acos(p1.d);\n\n      if (errno) {\n        stop(\"arccos function argument is not in the interval [-1,1]\");\n      }\n\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 4.0);\n      } else {\n        push_rational(1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n\n      restore();\n      return;\n    }\n\n    if (isminusoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI * 3.0 / 4.0);\n      } else {\n        push_rational(3, 4);\n        push_symbol(PI);\n        multiply();\n      }\n\n      restore();\n      return;\n    }\n\n    if (!isrational(p1)) {\n      push_symbol(ARCCOS);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push_symbol(PI);\n        }\n\n        break;\n\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI * 2.0 / 3.0);\n        } else {\n          push_rational(2, 3);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 3.0);\n        } else {\n          push_rational(1, 3);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n\n        break;\n\n      default:\n        push_symbol(ARCCOS);\n        push(p1);\n        list(2);\n    }\n\n    return restore();\n  };\n  /* arccosh =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse hyperbolic cosine of x.\n   */\n\n\n  Eval_arccosh = function Eval_arccosh() {\n    push(cadr(p1));\n    Eval();\n    return arccosh();\n  };\n\n  arccosh = function arccosh() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(COSH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = p1.d;\n\n      if (d < 1.0) {\n        stop(\"arccosh function argument is less than 1.0\");\n      }\n\n      d = Math.log(d + Math.sqrt(d * d - 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isplusone(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    push_symbol(ARCCOSH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n  /* arcsin =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse sine of x.\n   */\n\n\n  Eval_arcsin = function Eval_arcsin() {\n    push(cadr(p1));\n    Eval();\n    return arcsin();\n  };\n\n  arcsin = function arcsin() {\n    var d, errno, n;\n    n = 0;\n    d = 0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.asin(p1.d);\n\n      if (errno) {\n        stop(\"arcsin function argument is not in the interval [-1,1]\");\n      }\n\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {\n      push_rational(1, 4);\n      push_symbol(PI);\n      multiply();\n      restore();\n      return;\n    }\n\n    if (isminusoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(-Math.PI / 4.0);\n      } else {\n        push_rational(-1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n\n      restore();\n      return;\n    }\n\n    if (!isrational(p1)) {\n      push_symbol(ARCSIN);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 2.0);\n        } else {\n          push_rational(-1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 6.0);\n        } else {\n          push_rational(-1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n\n        break;\n\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 6.0);\n        } else {\n          push_rational(1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      default:\n        push_symbol(ARCSIN);\n        push(p1);\n        list(2);\n    }\n\n    return restore();\n  };\n  /* arcsinh =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse hyperbolic sine of x.\n   */\n\n\n  Eval_arcsinh = function Eval_arcsinh() {\n    push(cadr(p1));\n    Eval();\n    return arcsinh();\n  };\n\n  arcsinh = function arcsinh() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(SINH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = p1.d;\n      d = Math.log(d + Math.sqrt(d * d + 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    push_symbol(ARCSINH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n  /* arctan =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse tangent of x.\n   */\n\n\n  Eval_arctan = function Eval_arctan() {\n    push(cadr(p1));\n    Eval();\n    return _arctan();\n  };\n\n  _arctan = function arctan() {\n    var d, errno;\n    d = 0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(TAN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.atan(p1.d);\n\n      if (errno) {\n        stop(\"arctan function error\");\n      }\n\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n\n      _arctan();\n\n      negate();\n      restore();\n      return;\n    }\n\n    if (_Find(p1, symbol(SIN)) && _Find(p1, symbol(COS))) {\n      push(p1);\n\n      _numerator();\n\n      p2 = pop();\n      push(p1);\n\n      _denominator();\n\n      p3 = pop();\n\n      if (car(p2) === symbol(SIN) && car(p3) === symbol(COS) && equal(cadr(p2), cadr(p3))) {\n        push(cadr(p2));\n        restore();\n        return;\n      }\n    }\n\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), -1, 2) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 3) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 3) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {\n      push_rational(1, 6);\n\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n\n      multiply();\n      restore();\n      return;\n    }\n\n    if (equaln(p1, 1)) {\n      push_rational(1, 4);\n\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n\n      multiply();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), 1, 2)) {\n      push_rational(1, 3);\n\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n\n      multiply();\n      restore();\n      return;\n    }\n\n    push_symbol(ARCTAN);\n    push(p1);\n    list(2);\n    return restore();\n  };\n  /* arctanh =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse hyperbolic tangent of x.\n   */\n\n\n  Eval_arctanh = function Eval_arctanh() {\n    push(cadr(p1));\n    Eval();\n    return arctanh();\n  };\n\n  arctanh = function arctanh() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(TANH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = p1.d;\n\n      if (d < -1.0 || d > 1.0) {\n        stop(\"arctanh function argument is not in the interval [-1,1]\");\n      }\n\n      d = Math.log((1.0 + d) / (1.0 - d)) / 2.0;\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    push_symbol(ARCTANH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n  /* arg =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  z\n  \n  General description\n  -------------------\n  Returns the angle of complex z.\n   */\n\n  /*\n   Argument (angle) of complex z\n  \n    z    arg(z)\n    -    ------\n  \n    a    0\n  \n    -a    -pi      See note 3 below\n  \n    (-1)^a    a pi\n  \n    exp(a + i b)  b\n  \n    a b    arg(a) + arg(b)\n  \n    a + i b    arctan(b/a)\n  \n  Result by quadrant\n  \n    z    arg(z)\n    -    ------\n  \n    1 + i    1/4 pi\n  \n    1 - i    -1/4 pi\n  \n    -1 + i    3/4 pi\n  \n    -1 - i    -3/4 pi\n  \n  Notes\n  \n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n  \n    2. Symbols in z are assumed to be positive and real.\n  \n    3. Negative direction adds -pi to angle.\n  \n       Example: z = (-1)^(1/3), abs(z) = 1/3 pi, abs(-z) = -2/3 pi\n  \n    4. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n  \n      arg(numerator(z)) - arg(denominator(z))\n  \n       must be used to get the correct answer. Now the operation is\n       automatic.\n   */\n\n\n  DEBUG_ARG = false;\n\n  Eval_arg = function Eval_arg() {\n    push(cadr(p1));\n    Eval();\n    return arg();\n  };\n\n  arg = function arg() {\n    save();\n    p1 = pop();\n    push(p1);\n\n    _numerator();\n\n    yyarg();\n    push(p1);\n\n    _denominator();\n\n    yyarg();\n    subtract();\n    return restore();\n  };\n\n  yyarg = function yyarg() {\n    save();\n    p1 = pop();\n\n    if (ispositivenumber(p1) || p1 === symbol(PI)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(0);\n      } else {\n        push_integer(0);\n      }\n    } else if (isnegativenumber(p1)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n\n      negate();\n    } else if (issymbol(p1)) {\n      push_symbol(ARG);\n      push(p1);\n      list(2);\n    } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      push(caddr(p1));\n      imag();\n    } else if (car(p1) === symbol(POWER) && isoneovertwo(caddr(p1))) {\n      if (DEBUG_ARG) {\n        console.log(\"arg of a sqrt: \" + p1);\n      }\n\n      if (DEBUG_ARG) {\n        debugger;\n      }\n\n      push(cadr(p1));\n      arg();\n\n      if (DEBUG_ARG) {\n        console.log(\" = 1/2 * \" + stack[tos - 1]);\n      }\n\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      push_integer(0);\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        arg();\n        add();\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(ADD)) {\n      push(p1);\n\n      _rect();\n\n      p1 = pop();\n      push(p1);\n      real();\n      p2 = pop();\n      push(p1);\n      imag();\n      p3 = pop();\n\n      if (isZeroAtomOrTensor(p2)) {\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push(symbol(PI));\n        }\n\n        if (isnegative(p3)) {\n          negate();\n        }\n      } else {\n        push(p3);\n        push(p2);\n        divide();\n\n        _arctan();\n\n        if (isnegative(p2)) {\n          if (evaluatingAsFloats) {\n            push_double(Math.PI);\n          } else {\n            push_symbol(PI);\n          }\n\n          if (isnegative(p3)) {\n            subtract();\n          } else {\n            add();\n          }\n        }\n      }\n    } else {\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        push_integer(0);\n      } else {\n        push_symbol(ARG);\n        push(p1);\n        list(2);\n      }\n    }\n\n    return restore();\n  };\n\n  _bake = function bake() {\n    var h, s, t, x, y, z;\n    h = 0;\n    s = 0;\n    t = 0;\n    x = 0;\n    y = 0;\n    z = 0;\n    expanding++;\n    save();\n    p1 = pop();\n    s = ispolyexpandedform(p1, symbol(SYMBOL_S));\n    t = ispolyexpandedform(p1, symbol(SYMBOL_T));\n    x = ispolyexpandedform(p1, symbol(SYMBOL_X));\n    y = ispolyexpandedform(p1, symbol(SYMBOL_Y));\n    z = ispolyexpandedform(p1, symbol(SYMBOL_Z));\n\n    if (s === 1 && t === 0 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_S);\n      bake_poly();\n    } else if (s === 0 && t === 1 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_T);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 1 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_X);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 1 && z === 0) {\n      p2 = symbol(SYMBOL_Y);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 0 && z === 1) {\n      p2 = symbol(SYMBOL_Z);\n      bake_poly();\n    } else if (iscons(p1) && car(p1) !== symbol(FOR)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _bake();\n\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n\n    restore();\n    return expanding--;\n  };\n\n  _polyform = function polyform() {\n    var h;\n    h = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (ispolyexpandedform(p1, p2)) {\n      bake_poly();\n    } else if (iscons(p1)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n\n        _polyform();\n\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n\n    return restore();\n  };\n\n  bake_poly = function bake_poly() {\n    var a, h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    a = tos;\n    push(p1);\n    push(p2);\n    k = coeff();\n    h = tos;\n\n    for (i = o = ref = k - 1; o >= 0; i = o += -1) {\n      p1 = stack[a + i];\n      bake_poly_term(i);\n    }\n\n    n = tos - h;\n\n    if (n > 1) {\n      list(n);\n      push(symbol(ADD));\n      swap();\n      cons();\n    }\n\n    p1 = pop();\n    moveTos(tos - k);\n    return push(p1);\n  };\n\n  bake_poly_term = function bake_poly_term(k) {\n    var h, n;\n    h = 0;\n    n = 0;\n\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n\n    if (k === 0) {\n      if (car(p1) === symbol(ADD)) {\n        p1 = cdr(p1);\n\n        while (iscons(p1)) {\n          push(car(p1));\n          p1 = cdr(p1);\n        }\n      } else {\n        push(p1);\n      }\n\n      return;\n    }\n\n    h = tos;\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else if (!equaln(p1, 1)) {\n      push(p1);\n    }\n\n    if (k === 1) {\n      push(p2);\n    } else {\n      push(symbol(POWER));\n      push(p2);\n      push_integer(k);\n      list(3);\n    }\n\n    n = tos - h;\n\n    if (n > 1) {\n      list(n);\n      push(symbol(MULTIPLY));\n      swap();\n      return cons();\n    }\n  };\n  /* besselj =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x,n\n  \n  General description\n  -------------------\n  \n  Returns a solution to the Bessel differential equation (Bessel function of first kind).\n  \n  Recurrence relation:\n  \n    besselj(x,n) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n-2)\n  \n    besselj(x,1/2) = sqrt(2/pi/x) sin(x)\n  \n    besselj(x,-1/2) = sqrt(2/pi/x) cos(x)\n  \n  For negative n, reorder the recurrence relation as:\n  \n    besselj(x,n-2) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n)\n  \n  Substitute n+2 for n to obtain\n  \n    besselj(x,n) = (2/x) (n+1) besselj(x,n+1) - besselj(x,n+2)\n  \n  Examples:\n  \n    besselj(x,3/2) = (1/x) besselj(x,1/2) - besselj(x,-1/2)\n  \n    besselj(x,-3/2) = -(1/x) besselj(x,-1/2) - besselj(x,1/2)\n   */\n\n\n  Eval_besselj = function Eval_besselj() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return besselj();\n  };\n\n  besselj = function besselj() {\n    save();\n    yybesselj();\n    return restore();\n  };\n\n  yybesselj = function yybesselj() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n\n    if (isdouble(p1) && !isNaN(n)) {\n      d = jn(n, p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1) && isZeroAtomOrTensor(p2)) {\n      push_integer(1);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1) && !isNaN(n)) {\n      push_integer(0);\n      return;\n    }\n\n    if (p2.k === NUM && MEQUAL(p2.q.b, 2)) {\n      if (MEQUAL(p2.q.a, 1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        sine();\n        multiply();\n        return;\n      }\n\n      if (MEQUAL(p2.q.a, -1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        cosine();\n        multiply();\n        return;\n      }\n\n      push_integer(MSIGN(p2.q.a));\n      p3 = pop();\n      push_integer(2);\n      push(p1);\n      divide();\n      push(p2);\n      push(p3);\n      subtract();\n      multiply();\n      push(p1);\n      push(p2);\n      push(p3);\n      subtract();\n      besselj();\n      multiply();\n      push(p1);\n      push(p2);\n      push_integer(2);\n      push(p3);\n      multiply();\n      subtract();\n      besselj();\n      subtract();\n      return;\n    }\n\n    if (isnegativeterm(p1)) {\n      push(p1);\n      negate();\n      push(p2);\n      power();\n      push(p1);\n      push(p2);\n      negate();\n      power();\n      multiply();\n      push_symbol(BESSELJ);\n      push(p1);\n      negate();\n      push(p2);\n      list(3);\n      multiply();\n      return;\n    }\n\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELJ);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n\n    push(symbol(BESSELJ));\n    push(p1);\n    push(p2);\n    return list(3);\n  };\n  /* bessely =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x,n\n  \n  General description\n  -------------------\n  \n  Bessel function of second kind.\n   */\n\n\n  Eval_bessely = function Eval_bessely() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return bessely();\n  };\n\n  bessely = function bessely() {\n    save();\n    yybessely();\n    return restore();\n  };\n\n  yybessely = function yybessely() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n\n    if (isdouble(p1) && !isNaN(n)) {\n      d = yn(n, p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELY);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n\n    push_symbol(BESSELY);\n    push(p1);\n    push(p2);\n    list(3);\n  };\n\n  mint = function mint(a) {\n    return bigInt(a);\n  };\n\n  isSmall = function isSmall(a) {\n    return a.geq(Number.MIN_SAFE_INTEGER) && a.leq(Number.MAX_SAFE_INTEGER);\n  };\n\n  setSignTo = function setSignTo(a, b) {\n    if (a.isPositive()) {\n      if (b < 0) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      if (b > 0) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n\n    return a;\n  };\n\n  makeSignSameAs = function makeSignSameAs(a, b) {\n    if (a.isPositive()) {\n      if (b.isNegative()) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      if (b.isPositive()) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n\n    return a;\n  };\n\n  makePositive = function makePositive(a) {\n    if (a.isNegative()) {\n      return a.multiply(bigInt(-1));\n    }\n\n    return a;\n  };\n  /*\n  mtotal = 0\n  MP_MIN_SIZE = 2\n  MP_MAX_FREE  = 1000\n  \n  mnew = (n) ->\n    if (n < MP_MIN_SIZE)\n      n = MP_MIN_SIZE\n    if (n == MP_MIN_SIZE && mfreecount)\n      p = free_stack[--mfreecount]\n    else\n      p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))\n      #if (p == 0)\n       *  stop(\"malloc failure\")\n    p[0] = n\n    mtotal += n\n    return p[3]\n   */\n\n  /*\n  free_stack = []\n  \n  mfree = (array, p) ->\n    p -= 3\n    mtotal -= array[p]\n    if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)\n      free_stack[mfreecount++] = p\n    else\n      free(p)\n   */\n\n  /*\n  mint = (n) ->\n    p = mnew(1)\n    if (n < 0)\n       * !!! this is FU\n       * MSIGN(p) = -1\n      fu = true\n    else\n       * !!! this is FU\n      #MSIGN(p) = 1\n      fu = true\n     * !!! this is FU\n    #MLENGTH(p) = 1\n    p[0] = Math.abs(n)\n    return p\n   */\n\n  /*\n  mcopy = (a) ->\n    #unsigned int *b\n  \n    b = mnew(MLENGTH(a))\n  \n     * !!! fu\n    #MSIGN(b) = MSIGN(a)\n    #MLENGTH(b) = MLENGTH(a)\n  \n    for i in [0...MLENGTH(a)]\n      b[i] = a[i]\n  \n    return b\n   */\n\n  /*\n   * \n   * ge not invoked from anywhere - is you need ge\n   * just use the bigNum's ge implementation\n   * leaving it here just in case I decide to backport to C\n   *\n   * a >= b ?\n   * and and b arrays of ints, len is an int\n  ge = (a, b, len) ->\n    i = 0\n    for i in [0...len]\n      if (a[i] == b[i])\n        continue\n      else\n        break\n    if (a[i] >= b[i])\n      return 1\n    else\n      return 0\n   */\n\n\n  add_numbers = function add_numbers() {\n    var a, b, theResult;\n    a = 1.0;\n    b = 1.0;\n\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qadd();\n      return;\n    }\n\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n\n    theResult = a + b;\n    push_double(theResult);\n    return restore();\n  };\n\n  subtract_numbers = function subtract_numbers() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qsub();\n      return;\n    }\n\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n\n    push_double(a - b);\n    return restore();\n  };\n\n  multiply_numbers = function multiply_numbers() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qmul();\n      return;\n    }\n\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n\n    push_double(a * b);\n    return restore();\n  };\n\n  divide_numbers = function divide_numbers() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qdiv();\n      return;\n    }\n\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"divide by zero\");\n    }\n\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n\n    push_double(a / b);\n    return restore();\n  };\n\n  invert_number = function invert_number() {\n    var a, b;\n    save();\n    p1 = pop();\n\n    if (isZeroAtomOrTensor(p1)) {\n      stop(\"divide by zero\");\n    }\n\n    if (isdouble(p1)) {\n      push_double(1 / p1.d);\n      restore();\n      return;\n    }\n\n    a = bigInt(p1.q.a);\n    b = bigInt(p1.q.b);\n    b = makeSignSameAs(b, a);\n    a = setSignTo(a, 1);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = b;\n    p1.q.b = a;\n    push(p1);\n    return restore();\n  };\n\n  compare_rationals = function compare_rationals(a, b) {\n    var ab, ba, t;\n    t = 0;\n    ab = mmul(a.q.a, b.q.b);\n    ba = mmul(a.q.b, b.q.a);\n    t = mcmp(ab, ba);\n    return t;\n  };\n\n  compare_numbers = function compare_numbers(a, b) {\n    var x, y;\n    x = 0.0;\n    y = 0.0;\n\n    if (isrational(a) && isrational(b)) {\n      return compare_rationals(a, b);\n    }\n\n    if (isdouble(a)) {\n      x = a.d;\n    } else {\n      x = convert_rational_to_double(a);\n    }\n\n    if (isdouble(b)) {\n      y = b.d;\n    } else {\n      y = convert_rational_to_double(b);\n    }\n\n    if (x < y) {\n      return -1;\n    }\n\n    if (x > y) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  negate_number = function negate_number() {\n    save();\n    p1 = pop();\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    switch (p1.k) {\n      case NUM:\n        p2 = new U();\n        p2.k = NUM;\n        p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));\n        p2.q.b = bigInt(p1.q.b);\n        push(p2);\n        break;\n\n      case DOUBLE:\n        push_double(-p1.d);\n        break;\n\n      default:\n        stop(\"bug caught in mp_negate_number\");\n    }\n\n    return restore();\n  };\n\n  bignum_truncate = function bignum_truncate() {\n    var a;\n    save();\n    p1 = pop();\n    a = mdiv(p1.q.a, p1.q.b);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  mp_numerator = function mp_numerator() {\n    save();\n    p1 = pop();\n\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.a);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  mp_denominator = function mp_denominator() {\n    save();\n    p1 = pop();\n\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.b);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  bignum_power_number = function bignum_power_number(expo) {\n    var a, b, t;\n    save();\n    p1 = pop();\n    a = mpow(p1.q.a, Math.abs(expo));\n    b = mpow(p1.q.b, Math.abs(expo));\n\n    if (expo < 0) {\n      t = a;\n      a = b;\n      b = t;\n      a = makeSignSameAs(a, b);\n      b = setSignTo(b, 1);\n    }\n\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = b;\n    push(p1);\n    return restore();\n  };\n\n  convert_bignum_to_double = function convert_bignum_to_double(p) {\n    return p.toJSNumber();\n  };\n\n  convert_rational_to_double = function convert_rational_to_double(p) {\n    var quotientAndRemainder, result;\n\n    if (p.q == null) {\n      debugger;\n    }\n\n    quotientAndRemainder = p.q.a.divmod(p.q.b);\n    result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p.q.b.toJSNumber();\n    return result;\n  };\n\n  push_integer = function push_integer(n) {\n    if (DEBUG) {\n      console.log(\"pushing integer \" + n);\n    }\n\n    save();\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = bigInt(n);\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  push_double = function push_double(d) {\n    save();\n    p1 = new U();\n    p1.k = DOUBLE;\n    p1.d = d;\n    push(p1);\n    return restore();\n  };\n\n  push_rational = function push_rational(a, b) {\n    /*\n    save()\n    p1 = new U()\n    p1.k = NUM\n    p1.q.a = bigInt(a)\n    p1.q.b = bigInt(b)\n    ## FIXME -- normalize ##\n    push(p1)\n    restore()\n     */\n    var p;\n    p = new U();\n    p.k = NUM;\n    p.q.a = bigInt(a);\n    p.q.b = bigInt(b);\n    return push(p);\n  };\n\n  pop_integer = function pop_integer() {\n    var n;\n    n = 0 / 0;\n    save();\n    p1 = pop();\n\n    switch (p1.k) {\n      case NUM:\n        if (isinteger(p1) && isSmall(p1.q.a)) {\n          n = p1.q.a.toJSNumber();\n        }\n\n        break;\n\n      case DOUBLE:\n        if (DEBUG) {\n          console.log(\"popping integer but double is found\");\n        }\n\n        if (Math.floor(p1.d) === p1.d) {\n          if (DEBUG) {\n            console.log(\"...altough it's an integer\");\n          }\n\n          n = p1.d;\n        }\n\n    }\n\n    restore();\n    return n;\n  };\n\n  print_double = function print_double(p, flag) {\n    var accumulator, buf;\n    accumulator = \"\";\n    buf = doubleToReasonableString(p.d);\n\n    if (flag === 1 && buf === '-') {\n      accumulator += print_str(buf + 1);\n    } else {\n      accumulator += print_str(buf);\n    }\n\n    return accumulator;\n  };\n\n  bignum_scan_integer = function bignum_scan_integer(s) {\n    var a, scounter, sign_;\n    save();\n    scounter = 0;\n    sign_ = s[scounter];\n\n    if (sign_ === '+' || sign_ === '-') {\n      scounter++;\n    }\n\n    a = bigInt(s.substring(scounter));\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n\n    if (sign_ === '-') {\n      negate();\n    }\n\n    return restore();\n  };\n\n  bignum_scan_float = function bignum_scan_float(s) {\n    return push_double(parseFloat(s));\n  };\n\n  print_number = function print_number(p, signed) {\n    var aAsString, accumulator, buf, denominatorString;\n    accumulator = \"\";\n    denominatorString = \"\";\n    buf = \"\";\n\n    switch (p.k) {\n      case NUM:\n        aAsString = p.q.a.toString();\n\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n\n        if (printMode === PRINTMODE_LATEX && isfraction(p)) {\n          aAsString = \"\\\\frac{\" + aAsString + \"}{\";\n        }\n\n        accumulator += aAsString;\n\n        if (isfraction(p)) {\n          if (printMode !== PRINTMODE_LATEX) {\n            accumulator += \"/\";\n          }\n\n          denominatorString = p.q.b.toString();\n\n          if (printMode === PRINTMODE_LATEX) {\n            denominatorString += \"}\";\n          }\n\n          accumulator += denominatorString;\n        }\n\n        break;\n\n      case DOUBLE:\n        aAsString = doubleToReasonableString(p.d);\n\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n\n        accumulator += aAsString;\n    }\n\n    return accumulator;\n  };\n\n  gcd_numbers = function gcd_numbers() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mgcd(p1.q.a, p2.q.a);\n    p3.q.b = mgcd(p1.q.b, p2.q.b);\n    p3.q.a = setSignTo(p3.q.a, 1);\n    push(p3);\n    return restore();\n  };\n\n  pop_double = function pop_double() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n\n    switch (p1.k) {\n      case NUM:\n        d = convert_rational_to_double(p1);\n        break;\n\n      case DOUBLE:\n        d = p1.d;\n        break;\n\n      default:\n        d = 0.0;\n    }\n\n    restore();\n    return d;\n  };\n\n  bignum_float = function bignum_float() {\n    var d;\n    d = 0.0;\n    d = convert_rational_to_double(pop());\n    return push_double(d);\n  };\n\n  bignum_factorial = function bignum_factorial(n) {\n    save();\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = __factorial(n);\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  __factorial = function __factorial(n) {\n    var a, b, i, o, ref, t;\n    i = 0;\n\n    if (n === 0 || n === 1) {\n      a = bigInt(1);\n      return a;\n    }\n\n    a = bigInt(2);\n    b = bigInt(0);\n\n    if (3 <= n) {\n      for (i = o = 3, ref = n; 3 <= ref ? o <= ref : o >= ref; i = 3 <= ref ? ++o : --o) {\n        b = bigInt(i);\n        t = mmul(a, b);\n        a = t;\n      }\n    }\n\n    return a;\n  };\n\n  mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];\n\n  mp_set_bit = function mp_set_bit(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] |= mask[k % 32];\n  };\n\n  mp_clr_bit = function mp_clr_bit(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] &= ~mask[k % 32];\n  };\n\n  mshiftright = function mshiftright(a) {\n    return a = a.shiftRight();\n  };\n\n  Eval_binomial = function Eval_binomial() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return binomial();\n  };\n\n  binomial = function binomial() {\n    save();\n    ybinomial();\n    return restore();\n  };\n\n  ybinomial = function ybinomial() {\n    p2 = pop();\n    p1 = pop();\n\n    if (BINOM_check_args() === 0) {\n      push(zero);\n      return;\n    }\n\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    return divide();\n  };\n\n  BINOM_check_args = function BINOM_check_args() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n  /* ceiling =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  \n  Returns the smallest integer not less than x.\n   */\n\n\n  Eval_ceiling = function Eval_ceiling() {\n    push(cadr(p1));\n    Eval();\n    return ceiling();\n  };\n\n  ceiling = function ceiling() {\n    save();\n    yyceiling();\n    return restore();\n  };\n\n  yyceiling = function yyceiling() {\n    var d, doNothing;\n    d = 0.0;\n    p1 = pop();\n\n    if (!isNumericAtom(p1)) {\n      push_symbol(CEILING);\n      push(p1);\n      list(2);\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.ceil(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n\n    if (isnegativenumber(p1)) {\n      return doNothing = 1;\n    } else {\n      push_integer(1);\n      return add();\n    }\n  };\n  /* choose =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  n,k\n  \n  General description\n  -------------------\n  \n  Returns the number of combinations of n items taken k at a time.\n  \n  For example, the number of five card hands is choose(52,5)\n  \n  ```\n                            n!\n        choose(n,k) = -------------\n                       k! (n - k)!\n  ```\n   */\n\n\n  Eval_choose = function Eval_choose() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return choose();\n  };\n\n  choose = function choose() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (choose_check_args() === 0) {\n      push_integer(0);\n      restore();\n      return;\n    }\n\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    divide();\n    return restore();\n  };\n\n  choose_check_args = function choose_check_args() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n  /* circexp =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  \n  Returns expression x with circular and hyperbolic functions converted to exponential forms. Sometimes this will simplify an expression.\n   */\n\n\n  Eval_circexp = function Eval_circexp() {\n    push(cadr(p1));\n    Eval();\n\n    _circexp();\n\n    return Eval();\n  };\n\n  _circexp = function circexp() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      expcos();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      expsin();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(TAN)) {\n      p1 = cadr(p1);\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      exponential();\n      p2 = pop();\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      negate();\n      exponential();\n      p3 = pop();\n      push(p3);\n      push(p2);\n      subtract();\n      push(imaginaryunit);\n      multiply();\n      push(p2);\n      push(p3);\n      add();\n      divide();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(COSH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      add();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(SINH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      subtract();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(TANH)) {\n      p1 = cadr(p1);\n      push(p1);\n      push_integer(2);\n      multiply();\n      exponential();\n      p1 = pop();\n      push(p1);\n      push_integer(1);\n      subtract();\n      push(p1);\n      push_integer(1);\n      add();\n      divide();\n      restore();\n      return;\n    }\n\n    if (iscons(p1)) {\n      h = tos;\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _circexp();\n\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n      restore();\n      return;\n    }\n\n    if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n\n      for (i = o = 0, ref = p1.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n\n        _circexp();\n\n        p1.tensor.elem[i] = pop();\n      }\n\n      push(p1);\n      restore();\n      return;\n    }\n\n    push(p1);\n    return restore();\n  };\n  /* clearall =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  \n  General description\n  -------------------\n  \n  Completely wipes all variables from the environment.\n   */\n\n\n  Eval_clearall = function Eval_clearall() {\n    do_clearall();\n    return push(symbol(NIL));\n  };\n\n  do_clearall = function do_clearall() {\n    if (test_flag === 0) {\n      clear_term();\n    }\n\n    do_clearPatterns();\n    clear_symbols();\n    defn();\n    return codeGen = false;\n  };\n\n  clearall = function clearall() {\n    return run(\"clearall\");\n  };\n\n  clearRenamedVariablesToAvoidBindingToExternalScope = function clearRenamedVariablesToAvoidBindingToExternalScope() {\n    var i, o, ref, results;\n    results = [];\n\n    for (i = o = 0, ref = symtab.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (symtab[i].printname.indexOf(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\") !== -1) {\n        symtab[i].k = SYM;\n        symtab[i].printname = \"\";\n        binding[i] = symtab[i];\n        results.push(isSymbolReclaimable[i] = true);\n      } else {\n        results.push(void 0);\n      }\n    }\n\n    return results;\n  };\n  /* clear =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  \n  Completely wipes a variable from the environment (while doing x = quote(x) just unassigns it).\n   */\n\n\n  Eval_clear = function Eval_clear() {\n    var indexFound, variableToBeCleared;\n    p2 = cdr(p1);\n\n    while (iscons(p2)) {\n      variableToBeCleared = car(p2);\n\n      if (variableToBeCleared.k !== SYM) {\n        stop(\"symbol error\");\n      }\n\n      indexFound = symtab.indexOf(variableToBeCleared);\n      symtab[indexFound].k = SYM;\n      symtab[indexFound].printname = \"\";\n      binding[indexFound] = symtab[indexFound];\n      isSymbolReclaimable[indexFound] = true;\n      p2 = cdr(p2);\n    }\n\n    return push(symbol(NIL));\n  };\n  /*\n   Convert complex z to clock form\n  \n    Input:    push  z\n  \n    Output:    Result on stack\n  \n    clock(z) = abs(z) * (-1) ^ (arg(z) / pi)\n  \n    For example, clock(exp(i pi/3)) gives the result (-1)^(1/3)\n   */\n\n\n  DEBUG_CLOCKFORM = false;\n\n  Eval_clock = function Eval_clock() {\n    push(cadr(p1));\n    Eval();\n    return clockform();\n  };\n\n  clockform = function clockform() {\n    save();\n    p1 = pop();\n    push(p1);\n    abs();\n\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: abs of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p1);\n    arg();\n\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: arg of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push(symbol(PI));\n    }\n\n    divide();\n\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: divide : \" + stack[tos - 1]);\n    }\n\n    list(3);\n\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: power : \" + stack[tos - 1]);\n    }\n\n    multiply();\n\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: multiply : \" + stack[tos - 1]);\n    }\n    /*\n    p1 = pop()\n    push(p1)\n    abs()\n    push(symbol(E))\n    push(p1)\n    arg()\n    push(imaginaryunit)\n    multiply()\n    power()\n    multiply()\n     */\n\n\n    return restore();\n  };\n  /* coeff =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  p,x,n\n  \n  General description\n  -------------------\n  Returns the coefficient of x^n in polynomial p. The x argument can be omitted for polynomials in x.\n   */\n\n\n  Eval_coeff = function Eval_coeff() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n\n    if (p3 === symbol(NIL)) {\n      p3 = p2;\n      p2 = symbol(SYMBOL_X);\n    }\n\n    push(p1);\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2);\n    return filter();\n  };\n\n  coeff = function coeff() {\n    var h, n, prev_expanding;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n\n    while (1) {\n      push(p1);\n      push(p2);\n      push(zero);\n\n      _subst();\n\n      Eval();\n      p3 = pop();\n      push(p3);\n      push(p1);\n      push(p3);\n      subtract();\n      p1 = pop();\n\n      if (equal(p1, zero)) {\n        n = tos - h;\n        restore();\n        return n;\n      }\n\n      push(p1);\n      push(p2);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      p1 = pop();\n    }\n  };\n  /* cofactor =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m,i,j\n  \n  General description\n  -------------------\n  Cofactor of a matrix component.\n  Let c be the cofactor matrix of matrix m, i.e. tranpose(c) = adj(m).\n  This function returns c[i,j].\n   */\n\n\n  Eval_cofactor = function Eval_cofactor() {\n    var doNothing, i, j, n;\n    i = 0;\n    j = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n\n    if (istensor(p2) && p2.tensor.ndim === 2 && p2.tensor.dim[0] === p2.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"cofactor: 1st arg: square matrix expected\");\n    }\n\n    n = p2.tensor.dim[0];\n    push(caddr(p1));\n    Eval();\n    i = pop_integer();\n\n    if (i < 1 || i > n) {\n      stop(\"cofactor: 2nd arg: row index expected\");\n    }\n\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n\n    if (j < 1 || j > n) {\n      stop(\"cofactor: 3rd arg: column index expected\");\n    }\n\n    return cofactor(p2, n, i - 1, j - 1);\n  };\n\n  cofactor = function cofactor(p, n, row, col) {\n    var i, i1, j, o, ref, ref1;\n    i = 0;\n    j = 0;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i !== row && j !== col) {\n          push(p.tensor.elem[n * i + j]);\n        }\n      }\n    }\n\n    determinant(n - 1);\n\n    if ((row + col) % 2) {\n      return negate();\n    }\n  };\n\n  Eval_condense = function Eval_condense() {\n    push(cadr(p1));\n    Eval();\n    return Condense();\n  };\n\n  Condense = function Condense() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    save();\n    yycondense();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yycondense = function yycondense() {\n    p1 = pop();\n\n    if (car(p1) !== symbol(ADD)) {\n      push(p1);\n      return;\n    }\n\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      multiply_noexpand();\n      add();\n      p3 = cdr(p3);\n    }\n\n    yyexpand();\n    push(p2);\n    return divide();\n  };\n  /* conj =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  z\n  \n  General description\n  -------------------\n  Returns the complex conjugate of z.\n   */\n\n\n  Eval_conj = function Eval_conj() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    push(p1);\n\n    if (!_Find(p1, imaginaryunit)) {\n      polar();\n      conjugate();\n      return clockform();\n    } else {\n      return conjugate();\n    }\n  };\n\n  conjugate = function conjugate() {\n    push(imaginaryunit);\n    push(imaginaryunit);\n    negate();\n\n    _subst();\n\n    return Eval();\n  };\n\n  consCount = 0;\n\n  cons = function cons() {\n    var p;\n    consCount++;\n\n    if (DEBUG) {\n      console.log(\"cons tos: \" + tos + \" # \" + consCount);\n    }\n\n    p = new U();\n    p.k = CONS;\n    p.cons.cdr = pop();\n\n    if (p === p.cons.cdr) {\n      debugger;\n      console.log(\"something wrong p == its cdr\");\n    }\n\n    p.cons.car = pop();\n    /*\n    console.log \"cons new cdr.k = \" + p.cons.cdr.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.cdr\n    console.log \"cons new car.k = \" + p.cons.car.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.car\n     */\n\n    return push(p);\n  };\n  /* contract =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  a,i,j\n  \n  General description\n  -------------------\n  Contract across tensor indices i.e. returns \"a\" summed over indices i and j.\n  If i and j are omitted then 1 and 2 are used.\n  contract(m) is equivalent to the trace of matrix m.\n   */\n\n\n  Eval_contract = function Eval_contract() {\n    push(cadr(p1));\n    Eval();\n\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n\n    return contract();\n  };\n\n  contract = function contract() {\n    save();\n    yycontract();\n    return restore();\n  };\n\n  yycontract = function yycontract() {\n    var a, ai, an, b, h, i, i1, j, j1, k, l, l1, m, m1, n, n1, ndim, nelem, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    n = 0;\n    ndim = 0;\n    nelem = 0;\n    ai = [];\n    an = [];\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"contract: tensor expected, 1st arg is not a tensor\");\n      }\n\n      push(zero);\n      return;\n    }\n\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n    ndim = p1.tensor.ndim;\n\n    if (l < 1 || l > ndim || m < 1 || m > ndim || l === m || p1.tensor.dim[l - 1] !== p1.tensor.dim[m - 1]) {\n      stop(\"contract: index out of range\");\n    }\n\n    l--;\n    m--;\n    n = p1.tensor.dim[l];\n    nelem = 1;\n\n    for (i = o = 0, ref = ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (i !== l && i !== m) {\n        nelem *= p1.tensor.dim[i];\n      }\n    }\n\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim - 2;\n    j = 0;\n\n    for (i = i1 = 0, ref1 = ndim; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      if (i !== l && i !== m) {\n        p2.tensor.dim[j++] = p1.tensor.dim[i];\n      }\n    }\n\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n\n    for (i = j1 = 0, ref2 = ndim; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n\n    for (i = l1 = 0, ref3 = nelem; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n      push(zero);\n\n      for (j = m1 = 0, ref4 = n; 0 <= ref4 ? m1 < ref4 : m1 > ref4; j = 0 <= ref4 ? ++m1 : --m1) {\n        ai[l] = j;\n        ai[m] = j;\n        h = 0;\n\n        for (k = n1 = 0, ref5 = ndim; 0 <= ref5 ? n1 < ref5 : n1 > ref5; k = 0 <= ref5 ? ++n1 : --n1) {\n          h = h * an[k] + ai[k];\n        }\n\n        push(a[h]);\n        add();\n      }\n\n      b[i] = pop();\n\n      for (j = o1 = ref6 = ndim - 1; ref6 <= 0 ? o1 <= 0 : o1 >= 0; j = ref6 <= 0 ? ++o1 : --o1) {\n        if (j === l || j === m) {\n          continue;\n        }\n\n        if (++ai[j] < an[j]) {\n          break;\n        }\n\n        ai[j] = 0;\n      }\n    }\n\n    if (nelem === 1) {\n      return push(b[0]);\n    } else {\n      return push(p2);\n    }\n  };\n  /* cos =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the cosine of x.\n   */\n\n\n  Eval_cos = function Eval_cos() {\n    push(cadr(p1));\n    Eval();\n    return cosine();\n  };\n\n  cosine = function cosine() {\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(ADD)) {\n      cosine_of_angle_sum();\n    } else {\n      cosine_of_angle();\n    }\n\n    return restore();\n  };\n\n  cosine_of_angle_sum = function cosine_of_angle_sum() {\n    p2 = cdr(p1);\n\n    while (iscons(p2)) {\n      p4 = car(p2);\n\n      if (isnpi(p4)) {\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        cosine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        sine();\n        push(p4);\n        sine();\n        multiply();\n        subtract();\n        return;\n      }\n\n      p2 = cdr(p2);\n    }\n\n    return cosine_of_angle();\n  };\n\n  cosine_of_angle = function cosine_of_angle() {\n    var d, n;\n\n    if (car(p1) === symbol(ARCCOS)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.cos(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n\n    if (car(p1) === symbol(ARCTAN)) {\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      return;\n    }\n\n    push(p1);\n    push_integer(180);\n    multiply();\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n\n    divide();\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push(symbol(COS));\n      push(p1);\n      list(2);\n      return;\n    }\n\n    switch (n % 360) {\n      case 90:\n      case 270:\n        return push_integer(0);\n\n      case 60:\n      case 300:\n        return push_rational(1, 2);\n\n      case 120:\n      case 240:\n        return push_rational(-1, 2);\n\n      case 45:\n      case 315:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 135:\n      case 225:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 30:\n      case 330:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 150:\n      case 210:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 0:\n        return push_integer(1);\n\n      case 180:\n        return push_integer(-1);\n\n      default:\n        push(symbol(COS));\n        push(p1);\n        return list(2);\n    }\n  };\n  /* cosh =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the hyperbolic cosine of x\n  \n  ```\n              exp(x) + exp(-x)\n    cosh(x) = ----------------\n                     2\n  ```\n   */\n\n\n  Eval_cosh = function Eval_cosh() {\n    push(cadr(p1));\n    Eval();\n    return ycosh();\n  };\n\n  ycosh = function ycosh() {\n    save();\n    yycosh();\n    return restore();\n  };\n\n  yycosh = function yycosh() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (car(p1) === symbol(ARCCOSH)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.cosh(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n\n    push_symbol(COSH);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_decomp = function Eval_decomp() {\n    var h;\n    save();\n    console.log(\"Eval_decomp is being called!!!!!!!!!!!!!!!!!!!!\");\n    h = tos;\n    push(symbol(NIL));\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n\n    _decomp(false);\n\n    list(tos - h);\n    return restore();\n  };\n\n  pushTryNotToDuplicate = function pushTryNotToDuplicate(toBePushed) {\n    if (tos > 0) {\n      if (DEBUG) {\n        console.log(\"comparing \" + toBePushed + \" to: \" + stack[tos - 1]);\n      }\n\n      if (equal(toBePushed, stack[tos - 1])) {\n        if (DEBUG) {\n          console.log(\"skipping \" + toBePushed + \" because it's already on stack \");\n        }\n\n        return;\n      }\n    }\n\n    return push(toBePushed);\n  };\n\n  _decomp = function decomp(generalTransform) {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (DEBUG) {\n      console.log(\"DECOMPOSING \" + p1);\n    }\n\n    if (generalTransform) {\n      if (!iscons(p1)) {\n        if (DEBUG) {\n          console.log(\" ground thing: \" + p1);\n        }\n\n        pushTryNotToDuplicate(p1);\n        restore();\n        return;\n      }\n    } else {\n      if (_Find(p1, p2) === 0) {\n        if (DEBUG) {\n          console.log(\" entire expression is constant\");\n        }\n\n        pushTryNotToDuplicate(p1);\n        restore();\n        return;\n      }\n    }\n\n    if (isadd(p1)) {\n      decomp_sum(generalTransform);\n      restore();\n      return;\n    }\n\n    if (ismultiply(p1)) {\n      decomp_product(generalTransform);\n      restore();\n      return;\n    }\n\n    if (DEBUG) {\n      console.log(\" naive decomp\");\n    }\n\n    p3 = cdr(p1);\n\n    if (DEBUG) {\n      console.log(\"startig p3: \" + p3);\n    }\n\n    while (iscons(p3)) {\n      if (generalTransform) {\n        push(car(p3));\n      }\n\n      if (DEBUG) {\n        console.log(\"recursive decomposition\");\n      }\n\n      push(car(p3));\n\n      if (DEBUG) {\n        console.log(\"car(p3): \" + car(p3));\n      }\n\n      push(p2);\n\n      if (DEBUG) {\n        console.log(\"p2: \" + p2);\n      }\n\n      _decomp(generalTransform);\n\n      p3 = cdr(p3);\n    }\n\n    return restore();\n  };\n\n  decomp_sum = function decomp_sum(generalTransform) {\n    var h;\n\n    if (DEBUG) {\n      console.log(\" decomposing the sum \");\n    }\n\n    h = 0;\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      if (_Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n\n        _decomp(generalTransform);\n      }\n\n      p3 = cdr(p3);\n    }\n\n    h = tos;\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      if (_Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n\n      p3 = cdr(p3);\n    }\n\n    if (tos - h) {\n      add_all(tos - h);\n      p3 = pop();\n      pushTryNotToDuplicate(p3);\n      push(p3);\n      return negate();\n    }\n  };\n\n  decomp_product = function decomp_product(generalTransform) {\n    var h;\n\n    if (DEBUG) {\n      console.log(\" decomposing the product \");\n    }\n\n    h = 0;\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      if (_Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n\n        _decomp(generalTransform);\n      }\n\n      p3 = cdr(p3);\n    }\n\n    h = tos;\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      if (_Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n\n      p3 = cdr(p3);\n    }\n\n    if (tos - h) {\n      return multiply_all(tos - h);\n    }\n  };\n\n  define_user_function = function define_user_function() {\n    p3 = caadr(p1);\n    p4 = cdadr(p1);\n    p5 = caddr(p1);\n\n    if (!issymbol(p3)) {\n      stop(\"function name?\");\n    }\n\n    if (car(p5) === symbol(EVAL)) {\n      push(cadr(p5));\n      Eval();\n      p5 = pop();\n    }\n\n    push_symbol(FUNCTION);\n    push(p5);\n    push(p4);\n    list(3);\n    p5 = pop();\n    set_binding(p3, p5);\n    return push_symbol(NIL);\n  };\n\n  Eval_function_reference = function Eval_function_reference() {\n    return push(p1);\n  };\n  /* defint =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  f,x,a,b[,y,c,d...]\n  \n  General description\n  -------------------\n  Returns the definite integral of f with respect to x evaluated from \"a\" to b.\n  The argument list can be extended for multiple integrals (or \"iterated\n  integrals\"), for example a double integral (which can represent for\n  example a volume under a surface), or a triple integral, etc. For\n  example, defint(f,x,a,b,y,c,d).\n   */\n\n\n  Eval_defint = function Eval_defint() {\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n    p1 = cddr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p3 = pop();\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p4 = pop();\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p5 = pop();\n      push(p2);\n      push(p3);\n      integral();\n      p2 = pop();\n      push(p2);\n      push(p3);\n      push(p5);\n\n      _subst();\n\n      Eval();\n      push(p2);\n      push(p3);\n      push(p4);\n\n      _subst();\n\n      Eval();\n      subtract();\n      p2 = pop();\n    }\n\n    return push(p2);\n  };\n  /* deg =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  p,x\n  \n  General description\n  -------------------\n  Returns the degree of polynomial p(x).\n   */\n\n\n  Eval_degree = function Eval_degree() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n\n    return degree();\n  };\n\n  degree = function degree() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    p3 = zero;\n\n    _yydegree(p1);\n\n    push(p3);\n    return restore();\n  };\n\n  _yydegree = function yydegree(p) {\n    var results;\n\n    if (equal(p, p2)) {\n      if (isZeroAtomOrTensor(p3)) {\n        return p3 = one;\n      }\n    } else if (car(p) === symbol(POWER)) {\n      if (equal(cadr(p), p2) && isNumericAtom(caddr(p)) && lessp(p3, caddr(p))) {\n        return p3 = caddr(p);\n      }\n    } else if (iscons(p)) {\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        _yydegree(car(p));\n\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    }\n  };\n  /* denominator =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the denominator of expression x.\n   */\n\n\n  Eval_denominator = function Eval_denominator() {\n    push(cadr(p1));\n    Eval();\n    return _denominator();\n  };\n\n  _denominator = function denominator() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      rationalize();\n      theArgument = pop();\n    }\n\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n\n        _denominator();\n\n        theArgument = cdr(theArgument);\n      }\n\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_denominator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      push(theArgument);\n      return reciprocate();\n    } else {\n      return push(one);\n    }\n  };\n\n  Eval_derivative = function Eval_derivative() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    i = 0;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n\n    while (1) {\n      if (isNumericAtom(p5)) {\n        push(p5);\n        n = pop_integer();\n\n        if (isNaN(n)) {\n          stop(\"nth derivative: check n\");\n        }\n      } else {\n        n = 1;\n      }\n\n      push(p3);\n\n      if (n >= 0) {\n        for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          derivative();\n        }\n      } else {\n        n = -n;\n\n        for (i = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          integral();\n        }\n      }\n\n      p3 = pop();\n\n      if (p5 === symbol(NIL)) {\n        break;\n      }\n\n      if (isNumericAtom(p5)) {\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n\n        if (p5 === symbol(NIL)) {\n          break;\n        }\n\n        if (isNumericAtom(p5)) {\n          doNothing = 1;\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop();\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n      }\n    }\n\n    return push(p3);\n  };\n\n  derivative = function derivative() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isNumericAtom(p2)) {\n      stop(\"undefined function\");\n    }\n\n    if (istensor(p1)) {\n      if (istensor(p2)) {\n        d_tensor_tensor();\n      } else {\n        d_tensor_scalar();\n      }\n    } else {\n      if (istensor(p2)) {\n        d_scalar_tensor();\n      } else {\n        d_scalar_scalar();\n      }\n    }\n\n    return restore();\n  };\n\n  d_scalar_scalar = function d_scalar_scalar() {\n    if (issymbol(p2)) {\n      return d_scalar_scalar_1();\n    } else {\n      push(p1);\n      push(p2);\n      push(symbol(SECRETX));\n\n      _subst();\n\n      push(symbol(SECRETX));\n      derivative();\n      push(symbol(SECRETX));\n      push(p2);\n      return _subst();\n    }\n  };\n\n  d_scalar_scalar_1 = function d_scalar_scalar_1() {\n    if (equal(p1, p2)) {\n      push(one);\n      return;\n    }\n\n    if (!iscons(p1)) {\n      push(zero);\n      return;\n    }\n\n    if (isadd(p1)) {\n      dsum();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      dproduct();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER)) {\n      dpower();\n      return;\n    }\n\n    if (car(p1) === symbol(DERIVATIVE)) {\n      dd();\n      return;\n    }\n\n    if (car(p1) === symbol(LOG)) {\n      dlog();\n      return;\n    }\n\n    if (car(p1) === symbol(SIN)) {\n      dsin();\n      return;\n    }\n\n    if (car(p1) === symbol(COS)) {\n      dcos();\n      return;\n    }\n\n    if (car(p1) === symbol(TAN)) {\n      dtan();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCSIN)) {\n      darcsin();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCCOS)) {\n      darccos();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCTAN)) {\n      darctan();\n      return;\n    }\n\n    if (car(p1) === symbol(SINH)) {\n      dsinh();\n      return;\n    }\n\n    if (car(p1) === symbol(COSH)) {\n      dcosh();\n      return;\n    }\n\n    if (car(p1) === symbol(TANH)) {\n      dtanh();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCSINH)) {\n      darcsinh();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCCOSH)) {\n      darccosh();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCTANH)) {\n      darctanh();\n      return;\n    }\n\n    if (car(p1) === symbol(ABS)) {\n      dabs();\n      return;\n    }\n\n    if (car(p1) === symbol(SGN)) {\n      dsgn();\n      return;\n    }\n\n    if (car(p1) === symbol(HERMITE)) {\n      dhermite();\n      return;\n    }\n\n    if (car(p1) === symbol(ERF)) {\n      derf();\n      return;\n    }\n\n    if (car(p1) === symbol(ERFC)) {\n      derfc();\n      return;\n    }\n\n    if (car(p1) === symbol(BESSELJ)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbesselj0();\n      } else {\n        dbesseljn();\n      }\n\n      return;\n    }\n\n    if (car(p1) === symbol(BESSELY)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbessely0();\n      } else {\n        dbesselyn();\n      }\n\n      return;\n    }\n\n    if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {\n      derivative_of_integral();\n      return;\n    }\n\n    return dfunction();\n  };\n\n  dsum = function dsum() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      derivative();\n      p1 = cdr(p1);\n    }\n\n    return add_all(tos - h);\n  };\n\n  dproduct = function dproduct() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = length(p1) - 1;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p3 = cdr(p1);\n\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        push(car(p3));\n\n        if (i === j) {\n          push(p2);\n          derivative();\n        }\n\n        p3 = cdr(p3);\n      }\n\n      multiply_all(n);\n    }\n\n    return add_all(n);\n  };\n\n  dpower = function dpower() {\n    push(caddr(p1));\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    push(cadr(p1));\n    logarithm();\n    push(caddr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    add();\n    push(p1);\n    return multiply();\n  };\n\n  dlog = function dlog() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    return divide();\n  };\n\n  dd = function dd() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    p3 = pop();\n\n    if (car(p3) === symbol(DERIVATIVE)) {\n      push_symbol(DERIVATIVE);\n      push_symbol(DERIVATIVE);\n      push(cadr(p3));\n\n      if (lessp(caddr(p3), caddr(p1))) {\n        push(caddr(p3));\n        list(3);\n        push(caddr(p1));\n      } else {\n        push(caddr(p1));\n        list(3);\n        push(caddr(p3));\n      }\n\n      return list(3);\n    } else {\n      push(p3);\n      push(caddr(p1));\n      return derivative();\n    }\n  };\n\n  dfunction = function dfunction() {\n    p3 = cdr(p1);\n\n    if (p3 === symbol(NIL) || _Find(p3, p2)) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(zero);\n    }\n  };\n\n  dsin = function dsin() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    return multiply();\n  };\n\n  dcos = function dcos() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sine();\n    multiply();\n    return negate();\n  };\n\n  dtan = function dtan() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsin = function darcsin() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccos = function darccos() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    multiply();\n    return negate();\n  };\n\n  darctan = function darctan() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    add();\n    inverse();\n    multiply();\n    return simplify();\n  };\n\n  dsinh = function dsinh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    return multiply();\n  };\n\n  dcosh = function dcosh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ysinh();\n    return multiply();\n  };\n\n  dtanh = function dtanh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsinh = function darcsinh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccosh = function darccosh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darctanh = function darctanh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    inverse();\n    return multiply();\n  };\n\n  dabs = function dabs() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sgn();\n    return multiply();\n  };\n\n  dsgn = function dsgn() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    dirac();\n    multiply();\n    push_integer(2);\n    return multiply();\n  };\n\n  dhermite = function dhermite() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(2);\n    push(caddr(p1));\n    multiply();\n    multiply();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    hermite();\n    return multiply();\n  };\n\n  derf = function derf() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  derfc = function derfc() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(-2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  dbesselj0 = function dbesselj0() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesseljn = function dbesseljn() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    besselj();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    besselj();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  dbessely0 = function dbessely0() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesselyn = function dbesselyn() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    bessely();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    bessely();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  derivative_of_integral = function derivative_of_integral() {\n    return push(cadr(p1));\n  };\n  /* det =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m\n  \n  General description\n  -------------------\n  Returns the determinant of matrix m.\n  Uses Gaussian elimination for numerical matrices.\n  \n  Example:\n  \n    det(((1,2),(3,4)))\n    > -2\n   */\n\n\n  DET_check_arg = function DET_check_arg() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  det = function det() {\n    var a, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    save();\n    p1 = pop();\n\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    n = p1.tensor.nelem;\n    a = p1.tensor.elem;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (!isNumericAtom(a[i])) {\n        break;\n      }\n    }\n\n    if (i === n) {\n      yydetg();\n    } else {\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n      }\n\n      determinant(p1.tensor.dim[0]);\n    }\n\n    return restore();\n  };\n\n  determinant = function determinant(n) {\n    var a, breakFromOutherWhile, h, i, i1, j, k, o, q, ref, ref1, s, sign_, t;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    q = 0;\n    s = 0;\n    sign_ = 0;\n    t = 0;\n    a = [];\n    h = tos - n * n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      a[i] = i;\n      a[i + n] = 0;\n      a[i + n + n] = 1;\n    }\n\n    sign_ = 1;\n    push(zero);\n\n    while (1) {\n      if (sign_ === 1) {\n        push_integer(1);\n      } else {\n        push_integer(-1);\n      }\n\n      for (i = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        k = n * a[i] + i;\n        push(stack[h + k]);\n        multiply();\n      }\n\n      add();\n      j = n - 1;\n      s = 0;\n      breakFromOutherWhile = false;\n\n      while (1) {\n        q = a[n + j] + a[n + n + j];\n\n        if (q < 0) {\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n\n        if (q === j + 1) {\n          if (j === 0) {\n            breakFromOutherWhile = true;\n            break;\n          }\n\n          s++;\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n\n        break;\n      }\n\n      if (breakFromOutherWhile) {\n        break;\n      }\n\n      t = a[j - a[n + j] + s];\n      a[j - a[n + j] + s] = a[j - q + s];\n      a[j - q + s] = t;\n      a[n + j] = q;\n      sign_ = -sign_;\n    }\n\n    stack[h] = stack[tos - 1];\n    return moveTos(h + 1);\n  };\n\n  detg = function detg() {\n    save();\n    p1 = pop();\n\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    yydetg();\n    return restore();\n  };\n\n  yydetg = function yydetg() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n\n    for (i = o = 0, ref = n * n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push(p1.tensor.elem[i]);\n    }\n\n    lu_decomp(n);\n    moveTos(tos - n * n);\n    return push(p1);\n  };\n\n  M = function M(h, n, i, j) {\n    return stack[h + n * i + j];\n  };\n\n  setM = function setM(h, n, i, j, value) {\n    return stack[h + n * i + j] = value;\n  };\n\n  lu_decomp = function lu_decomp(n) {\n    var d, h, i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8;\n    d = 0;\n    h = 0;\n    i = 0;\n    j = 0;\n    h = tos - n * n;\n    p1 = one;\n\n    for (d = o = 0, ref = n - 1; 0 <= ref ? o < ref : o > ref; d = 0 <= ref ? ++o : --o) {\n      if (equal(M(h, n, d, d), zero)) {\n        for (i = i1 = ref1 = d + 1, ref2 = n; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(M(h, n, i, d), zero)) {\n            break;\n          }\n        }\n\n        if (i === n) {\n          p1 = zero;\n          break;\n        }\n\n        for (j = j1 = ref3 = d, ref4 = n; ref3 <= ref4 ? j1 < ref4 : j1 > ref4; j = ref3 <= ref4 ? ++j1 : --j1) {\n          p2 = M(h, n, d, j);\n          setM(h, n, d, j, M(h, n, i, j));\n          setM(h, n, i, j, p2);\n        }\n\n        push(p1);\n        negate();\n        p1 = pop();\n      }\n\n      push(p1);\n      push(M(h, n, d, d));\n      multiply();\n      p1 = pop();\n\n      for (i = l1 = ref5 = d + 1, ref6 = n; ref5 <= ref6 ? l1 < ref6 : l1 > ref6; i = ref5 <= ref6 ? ++l1 : --l1) {\n        push(M(h, n, i, d));\n        push(M(h, n, d, d));\n        divide();\n        negate();\n        p2 = pop();\n        setM(h, n, i, d, zero);\n\n        for (j = m1 = ref7 = d + 1, ref8 = n; ref7 <= ref8 ? m1 < ref8 : m1 > ref8; j = ref7 <= ref8 ? ++m1 : --m1) {\n          push(M(h, n, d, j));\n          push(p2);\n          multiply();\n          push(M(h, n, i, j));\n          add();\n          setM(h, n, i, j, pop());\n        }\n      }\n    }\n\n    push(p1);\n    push(M(h, n, n - 1, n - 1));\n    multiply();\n    return p1 = pop();\n  };\n\n  Eval_dirac = function Eval_dirac() {\n    push(cadr(p1));\n    Eval();\n    return dirac();\n  };\n\n  dirac = function dirac() {\n    save();\n    ydirac();\n    return restore();\n  };\n\n  ydirac = function ydirac() {\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      if (p1.d === 0) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n\n    if (isrational(p1)) {\n      if (MZERO(mmul(p1.q.a, p1.q.b))) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n\n    if (car(p1) === symbol(POWER)) {\n      push_symbol(DIRAC);\n      push(cadr(p1));\n      list(2);\n      return;\n    }\n\n    if (isnegativeterm(p1)) {\n      push_symbol(DIRAC);\n      push(p1);\n      negate();\n      list(2);\n      return;\n    }\n\n    if (isnegativeterm(p1) || car(p1) === symbol(ADD) && isnegativeterm(cadr(p1))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n\n    push_symbol(DIRAC);\n    push(p1);\n    return list(2);\n  };\n\n  divisors = function divisors() {\n    var h, i, n, o, ref, subsetOfStack;\n    i = 0;\n    h = 0;\n    n = 0;\n    save();\n    h = tos - 1;\n    divisors_onstack();\n    n = tos - h;\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(_cmp_expr);\n    stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  divisors_onstack = function divisors_onstack() {\n    var h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    save();\n    p1 = pop();\n    h = tos;\n\n    if (isNumericAtom(p1)) {\n      push(p1);\n      factor_small_number();\n    } else if (car(p1) === symbol(ADD)) {\n      push(p1);\n\n      __factor_add();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      if (isNumericAtom(car(p1))) {\n        push(car(p1));\n        factor_small_number();\n        p1 = cdr(p1);\n      }\n\n      while (iscons(p1)) {\n        p2 = car(p1);\n\n        if (car(p2) === symbol(POWER)) {\n          push(cadr(p2));\n          push(caddr(p2));\n        } else {\n          push(p2);\n          push(one);\n        }\n\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(POWER)) {\n      push(cadr(p1));\n      push(caddr(p1));\n    } else {\n      push(p1);\n      push(one);\n    }\n\n    k = tos;\n    push(one);\n\n    _gen(h, k);\n\n    n = tos - k;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      stack[h + i] = stack[k + i];\n    }\n\n    moveTos(h + n);\n    return restore();\n  };\n\n  _gen = function gen(h, k) {\n    var expo, i, o, ref;\n    expo = 0;\n    i = 0;\n    save();\n    p1 = pop();\n\n    if (h === k) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    p2 = stack[h + 0];\n    p3 = stack[h + 1];\n    push(p3);\n    expo = pop_integer();\n\n    if (!isNaN(expo)) {\n      for (i = o = 0, ref = Math.abs(expo); 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {\n        push(p1);\n        push(p2);\n        push_integer(sign(expo) * i);\n        power();\n        multiply();\n\n        _gen(h + 2, k);\n      }\n    }\n\n    return restore();\n  };\n\n  __factor_add = function __factor_add() {\n    save();\n    p1 = pop();\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n\n    p2 = pop();\n\n    if (isplusone(p2)) {\n      push(p1);\n      push(one);\n      restore();\n      return;\n    }\n\n    if (isNumericAtom(p2)) {\n      push(p2);\n      factor_small_number();\n    } else if (car(p2) === symbol(MULTIPLY)) {\n      p3 = cdr(p2);\n\n      if (isNumericAtom(car(p3))) {\n        push(car(p3));\n        factor_small_number();\n      } else {\n        push(car(p3));\n        push(one);\n      }\n\n      p3 = cdr(p3);\n\n      while (iscons(p3)) {\n        push(car(p3));\n        push(one);\n        p3 = cdr(p3);\n      }\n    } else {\n      push(p2);\n      push(one);\n    }\n\n    push(p2);\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      multiply();\n      add();\n      p3 = cdr(p3);\n    }\n\n    push(one);\n    return restore();\n  };\n\n  dpow = function dpow() {\n    var a, b, base, expo, result, theta;\n    a = 0.0;\n    b = 0.0;\n    base = 0.0;\n    expo = 0.0;\n    result = 0.0;\n    theta = 0.0;\n    expo = pop_double();\n    base = pop_double();\n\n    if (base === 0.0 && expo < 0.0) {\n      stop(\"divide by zero\");\n    }\n\n    if (base >= 0.0 || expo % 1.0 === 0.0) {\n      result = Math.pow(base, expo);\n      push_double(result);\n      return;\n    }\n\n    result = Math.pow(Math.abs(base), expo);\n    theta = Math.PI * expo;\n\n    if (expo % 0.5 === 0.0) {\n      a = 0.0;\n      b = Math.sin(theta);\n    } else {\n      a = Math.cos(theta);\n      b = Math.sin(theta);\n    }\n\n    push_double(a * result);\n    push_double(b * result);\n    push(imaginaryunit);\n    multiply();\n    return add();\n  };\n  /* eigen =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m\n  \n  General description\n  -------------------\n  Compute eigenvalues and eigenvectors. Matrix m must be both numerical and symmetric.\n  The eigenval function returns a matrix with the eigenvalues along the diagonal.\n  The eigenvec function returns a matrix with the eigenvectors arranged as row vectors.\n  The eigen function does not return anything but stores the eigenvalue matrix in D\n  and the eigenvector matrix in Q.\n  \n  Input:    stack[tos - 1]    symmetric matrix\n  \n  Output:    D      diagnonal matrix\n        Q      eigenvector matrix\n  \n  D and Q have the property that\n  \n    A == dot(transpose(Q),D,Q)\n  \n  where A is the original matrix.\n  \n  The eigenvalues are on the diagonal of D.\n  The eigenvectors are row vectors in Q.\n  \n  The eigenvalue relation:\n  \n    A X = lambda X\n  \n  can be checked as follows:\n  \n    lambda = D[1,1]\n    X = Q[1]\n    dot(A,X) - lambda X\n  \n  Example 1. Check the relation AX = lambda X where lambda is an eigenvalue and X is the associated eigenvector.\n  \n  Enter:\n  \n       A = hilbert(3)\n  \n       eigen(A)\n  \n       lambda = D[1,1]\n  \n       X = Q[1]\n  \n       dot(A,X) - lambda X\n  \n  Result:\n  \n       -1.16435e-14\n   \n       -6.46705e-15\n   \n       -4.55191e-15\n  \n  Example 2: Check the relation A = QTDQ.\n  \n  Enter:\n  \n    A - dot(transpose(Q),D,Q)\n  \n  Result: \n  \n    6.27365e-12    -1.58236e-11   1.81902e-11\n   \n    -1.58236e-11   -1.95365e-11   2.56514e-12\n   \n    1.81902e-11    2.56514e-12    1.32627e-11\n   */\n\n\n  EIG_N = 0;\n  EIG_yydd = [];\n  EIG_yyqq = [];\n\n  Eval_eigen = function Eval_eigen() {\n    if (EIG_check_arg() === 0) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n\n    eigen(EIGEN);\n    p1 = usr_symbol(\"D\");\n    set_binding(p1, p2);\n    p1 = usr_symbol(\"Q\");\n    set_binding(p1, p3);\n    return push(symbol(NIL));\n  };\n  /* eigenval =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m\n  \n  General description\n  -------------------\n  Compute eigenvalues of m. See \"eigen\" for more info.\n   */\n\n\n  Eval_eigenval = function Eval_eigenval() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVAL);\n      push(p1);\n      list(2);\n      return;\n    }\n\n    eigen(EIGENVAL);\n    return push(p2);\n  };\n  /* eigenvec =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m\n  \n  General description\n  -------------------\n  Compute eigenvectors of m. See \"eigen\" for more info.\n   */\n\n\n  Eval_eigenvec = function Eval_eigenvec() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVEC);\n      push(p1);\n      list(2);\n      return;\n    }\n\n    eigen(EIGENVEC);\n    return push(p3);\n  };\n\n  EIG_check_arg = function EIG_check_arg() {\n    var i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    push(cadr(p1));\n    Eval();\n\n    _yyfloat();\n\n    Eval();\n    p1 = pop();\n\n    if (!istensor(p1)) {\n      return 0;\n    }\n\n    if (p1.tensor.ndim !== 2 || p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n\n    EIG_N = p1.tensor.dim[0];\n\n    for (i = o = 0, ref = EIG_N; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = EIG_N; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        if (!isdouble(p1.tensor.elem[EIG_N * i + j])) {\n          stop(\"eigen: matrix is not numerical\");\n        }\n      }\n    }\n\n    for (i = j1 = 0, ref2 = EIG_N - 1; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; ref3 <= ref4 ? l1 < ref4 : l1 > ref4; j = ref3 <= ref4 ? ++l1 : --l1) {\n        if (Math.abs(p1.tensor.elem[EIG_N * i + j].d - p1.tensor.elem[EIG_N * j + i].d) > 1e-10) {\n          stop(\"eigen: matrix is not symmetrical\");\n        }\n      }\n    }\n\n    return 1;\n  };\n\n  eigen = function eigen(op) {\n    var i, i1, j, j1, l1, m1, n1, o, o1, q1, r1, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, s1;\n    i = 0;\n    j = 0;\n\n    for (i = o = 0, ref = EIG_N * EIG_N; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      EIG_yydd[i] = 0.0;\n    }\n\n    for (i = i1 = 0, ref1 = EIG_N * EIG_N; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      EIG_yyqq[i] = 0.0;\n    }\n\n    for (i = j1 = 0, ref2 = EIG_N; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      EIG_yydd[EIG_N * i + i] = p1.tensor.elem[EIG_N * i + i].d;\n\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; ref3 <= ref4 ? l1 < ref4 : l1 > ref4; j = ref3 <= ref4 ? ++l1 : --l1) {\n        EIG_yydd[EIG_N * i + j] = p1.tensor.elem[EIG_N * i + j].d;\n        EIG_yydd[EIG_N * j + i] = p1.tensor.elem[EIG_N * i + j].d;\n      }\n    }\n\n    for (i = m1 = 0, ref5 = EIG_N; 0 <= ref5 ? m1 < ref5 : m1 > ref5; i = 0 <= ref5 ? ++m1 : --m1) {\n      EIG_yyqq[EIG_N * i + i] = 1.0;\n\n      for (j = n1 = ref6 = i + 1, ref7 = EIG_N; ref6 <= ref7 ? n1 < ref7 : n1 > ref7; j = ref6 <= ref7 ? ++n1 : --n1) {\n        EIG_yyqq[EIG_N * i + j] = 0.0;\n        EIG_yyqq[EIG_N * j + i] = 0.0;\n      }\n    }\n\n    for (i = o1 = 0; o1 < 100; i = ++o1) {\n      if (step() === 0) {\n        break;\n      }\n    }\n\n    if (i === 100) {\n      printstr(\"\\nnote: eigen did not converge\\n\");\n    }\n\n    if (op === EIGEN || op === EIGENVAL) {\n      push(p1);\n      copy_tensor();\n      p2 = pop();\n\n      for (i = q1 = 0, ref8 = EIG_N; 0 <= ref8 ? q1 < ref8 : q1 > ref8; i = 0 <= ref8 ? ++q1 : --q1) {\n        for (j = r1 = 0, ref9 = EIG_N; 0 <= ref9 ? r1 < ref9 : r1 > ref9; j = 0 <= ref9 ? ++r1 : --r1) {\n          push_double(EIG_yydd[EIG_N * i + j]);\n          p2.tensor.elem[EIG_N * i + j] = pop();\n        }\n      }\n    }\n\n    if (op === EIGEN || op === EIGENVEC) {\n      push(p1);\n      copy_tensor();\n      p3 = pop();\n      results = [];\n\n      for (i = s1 = 0, ref10 = EIG_N; 0 <= ref10 ? s1 < ref10 : s1 > ref10; i = 0 <= ref10 ? ++s1 : --s1) {\n        results.push(function () {\n          var ref11, results1, t1;\n          results1 = [];\n\n          for (j = t1 = 0, ref11 = EIG_N; 0 <= ref11 ? t1 < ref11 : t1 > ref11; j = 0 <= ref11 ? ++t1 : --t1) {\n            push_double(EIG_yyqq[EIG_N * i + j]);\n            results1.push(p3.tensor.elem[EIG_N * i + j] = pop());\n          }\n\n          return results1;\n        }());\n      }\n\n      return results;\n    }\n  };\n\n  step = function step() {\n    var count, i, i1, j, o, ref, ref1, ref2;\n    i = 0;\n    j = 0;\n    count = 0;\n\n    for (i = o = 0, ref = EIG_N - 1; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = ref1 = i + 1, ref2 = EIG_N; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (EIG_yydd[EIG_N * i + j] !== 0.0) {\n          step2(i, j);\n          count++;\n        }\n      }\n    }\n\n    return count;\n  };\n\n  step2 = function step2(p, q) {\n    var c, cc, i1, j1, k, o, ref, ref1, ref2, s, ss, t, theta;\n    k = 0;\n    t = 0.0;\n    theta = 0.0;\n    c = 0.0;\n    cc = 0.0;\n    s = 0.0;\n    ss = 0.0;\n    theta = 0.5 * (EIG_yydd[EIG_N * p + p] - EIG_yydd[EIG_N * q + q]) / EIG_yydd[EIG_N * p + q];\n    t = 1.0 / (Math.abs(theta) + Math.sqrt(theta * theta + 1.0));\n\n    if (theta < 0.0) {\n      t = -t;\n    }\n\n    c = 1.0 / Math.sqrt(t * t + 1.0);\n    s = t * c;\n\n    for (k = o = 0, ref = EIG_N; 0 <= ref ? o < ref : o > ref; k = 0 <= ref ? ++o : --o) {\n      cc = EIG_yydd[EIG_N * p + k];\n      ss = EIG_yydd[EIG_N * q + k];\n      EIG_yydd[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yydd[EIG_N * q + k] = c * ss - s * cc;\n    }\n\n    for (k = i1 = 0, ref1 = EIG_N; 0 <= ref1 ? i1 < ref1 : i1 > ref1; k = 0 <= ref1 ? ++i1 : --i1) {\n      cc = EIG_yydd[EIG_N * k + p];\n      ss = EIG_yydd[EIG_N * k + q];\n      EIG_yydd[EIG_N * k + p] = c * cc + s * ss;\n      EIG_yydd[EIG_N * k + q] = c * ss - s * cc;\n    }\n\n    for (k = j1 = 0, ref2 = EIG_N; 0 <= ref2 ? j1 < ref2 : j1 > ref2; k = 0 <= ref2 ? ++j1 : --j1) {\n      cc = EIG_yyqq[EIG_N * p + k];\n      ss = EIG_yyqq[EIG_N * q + k];\n      EIG_yyqq[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yyqq[EIG_N * q + k] = c * ss - s * cc;\n    }\n\n    EIG_yydd[EIG_N * p + q] = 0.0;\n    return EIG_yydd[EIG_N * q + p] = 0.0;\n  };\n  /* erf =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Authors\n  -------\n  philippe.billet@noos.fr\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Error function erf(x).\n  erf(-x)=erf(x)\n   */\n\n\n  Eval_erf = function Eval_erf() {\n    push(cadr(p1));\n    Eval();\n    return yerf();\n  };\n\n  yerf = function yerf() {\n    save();\n    yyerf();\n    return restore();\n  };\n\n  yyerf = function yyerf() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      d = 1.0 - erfc(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n\n    if (isnegativeterm(p1)) {\n      push_symbol(ERF);\n      push(p1);\n      negate();\n      list(2);\n      negate();\n      return;\n    }\n\n    push_symbol(ERF);\n    push(p1);\n    list(2);\n  };\n\n  Eval_erfc = function Eval_erfc() {\n    push(cadr(p1));\n    Eval();\n    return yerfc();\n  };\n\n  yerfc = function yerfc() {\n    save();\n    yyerfc();\n    return restore();\n  };\n\n  yyerfc = function yyerfc() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      d = erfc(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n\n    push_symbol(ERFC);\n    push(p1);\n    list(2);\n  };\n\n  erfc = function erfc(x) {\n    var ans, t, z;\n\n    if (x === 0) {\n      return 1.0;\n    }\n\n    t = 0.0;\n    z = 0.0;\n    ans = 0.0;\n    z = Math.abs(x);\n    t = 1.0 / (1.0 + 0.5 * z);\n    ans = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));\n\n    if (x >= 0.0) {\n      return ans;\n    } else {\n      return 2.0 - ans;\n    }\n  };\n\n  Eval = function Eval() {\n    var willEvaluateAsFloats;\n    check_esc_flag();\n    save();\n    p1 = pop();\n\n    if (p1 == null) {\n      debugger;\n    }\n\n    if (!evaluatingAsFloats && _isfloating(p1)) {\n      willEvaluateAsFloats = true;\n      evaluatingAsFloats++;\n    }\n\n    switch (p1.k) {\n      case CONS:\n        Eval_cons();\n        break;\n\n      case NUM:\n        if (evaluatingAsFloats) {\n          push_double(convert_rational_to_double(p1));\n        } else {\n          push(p1);\n        }\n\n        break;\n\n      case DOUBLE:\n      case STR:\n        push(p1);\n        break;\n\n      case TENSOR:\n        Eval_tensor();\n        break;\n\n      case SYM:\n        Eval_sym();\n        break;\n\n      default:\n        stop(\"atom?\");\n    }\n\n    if (willEvaluateAsFloats) {\n      evaluatingAsFloats--;\n    }\n\n    return restore();\n  };\n\n  Eval_sym = function Eval_sym() {\n    var cycleString, i, o, positionIfSymbolAlreadyBeingEvaluated, ref, ref1;\n\n    if (iskeyword(p1)) {\n      push(p1);\n      push(symbol(LAST));\n      list(2);\n      Eval();\n      return;\n    } else if (p1 === symbol(PI) && evaluatingAsFloats) {\n      push_double(Math.PI);\n      return;\n    }\n\n    p2 = get_binding(p1);\n\n    if (DEBUG) {\n      console.log(\"looked up: \" + p1 + \" which contains: \" + p2);\n    }\n\n    push(p2);\n\n    if (p1 !== p2) {\n      positionIfSymbolAlreadyBeingEvaluated = chainOfUserSymbolsNotFunctionsBeingEvaluated.indexOf(p1);\n\n      if (positionIfSymbolAlreadyBeingEvaluated !== -1) {\n        cycleString = \"\";\n\n        for (i = o = ref = positionIfSymbolAlreadyBeingEvaluated, ref1 = chainOfUserSymbolsNotFunctionsBeingEvaluated.length; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {\n          cycleString += chainOfUserSymbolsNotFunctionsBeingEvaluated[i].printname + \" -> \";\n        }\n\n        cycleString += p1.printname;\n        stop(\"recursive evaluation of symbols: \" + cycleString);\n        return;\n      }\n\n      chainOfUserSymbolsNotFunctionsBeingEvaluated.push(p1);\n      Eval();\n      return chainOfUserSymbolsNotFunctionsBeingEvaluated.pop();\n    }\n  };\n\n  Eval_cons = function Eval_cons() {\n    var cons_head;\n    cons_head = car(p1);\n\n    if (car(cons_head) === symbol(EVAL)) {\n      Eval_user_function();\n      return;\n    }\n\n    if (!issymbol(cons_head)) {\n      stop(\"cons?\");\n    }\n\n    switch (symnum(cons_head)) {\n      case ABS:\n        return Eval_abs();\n\n      case ADD:\n        return Eval_add();\n\n      case ADJ:\n        return Eval_adj();\n\n      case AND:\n        return Eval_and();\n\n      case ARCCOS:\n        return Eval_arccos();\n\n      case ARCCOSH:\n        return Eval_arccosh();\n\n      case ARCSIN:\n        return Eval_arcsin();\n\n      case ARCSINH:\n        return Eval_arcsinh();\n\n      case ARCTAN:\n        return Eval_arctan();\n\n      case ARCTANH:\n        return Eval_arctanh();\n\n      case ARG:\n        return Eval_arg();\n\n      case ATOMIZE:\n        return Eval_atomize();\n\n      case BESSELJ:\n        return Eval_besselj();\n\n      case BESSELY:\n        return Eval_bessely();\n\n      case BINDING:\n        return Eval_binding();\n\n      case BINOMIAL:\n        return Eval_binomial();\n\n      case CEILING:\n        return Eval_ceiling();\n\n      case CHECK:\n        return Eval_check();\n\n      case CHOOSE:\n        return Eval_choose();\n\n      case CIRCEXP:\n        return Eval_circexp();\n\n      case CLEAR:\n        return Eval_clear();\n\n      case CLEARALL:\n        return Eval_clearall();\n\n      case CLEARPATTERNS:\n        return Eval_clearpatterns();\n\n      case CLOCK:\n        return Eval_clock();\n\n      case COEFF:\n        return Eval_coeff();\n\n      case COFACTOR:\n        return Eval_cofactor();\n\n      case CONDENSE:\n        return Eval_condense();\n\n      case CONJ:\n        return Eval_conj();\n\n      case CONTRACT:\n        return Eval_contract();\n\n      case COS:\n        return Eval_cos();\n\n      case COSH:\n        return Eval_cosh();\n\n      case DECOMP:\n        return Eval_decomp();\n\n      case DEGREE:\n        return Eval_degree();\n\n      case DEFINT:\n        return Eval_defint();\n\n      case DENOMINATOR:\n        return Eval_denominator();\n\n      case DERIVATIVE:\n        return Eval_derivative();\n\n      case DET:\n        return Eval_det();\n\n      case DIM:\n        return Eval_dim();\n\n      case DIRAC:\n        return Eval_dirac();\n\n      case DIVISORS:\n        return Eval_divisors();\n\n      case DO:\n        return Eval_do();\n\n      case DOT:\n        return _Eval_inner();\n\n      case DRAW:\n        return Eval_draw();\n\n      case DSOLVE:\n        return Eval_dsolve();\n\n      case EIGEN:\n        return Eval_eigen();\n\n      case EIGENVAL:\n        return Eval_eigenval();\n\n      case EIGENVEC:\n        return Eval_eigenvec();\n\n      case ERF:\n        return Eval_erf();\n\n      case ERFC:\n        return Eval_erfc();\n\n      case EVAL:\n        return Eval_Eval();\n\n      case EXP:\n        return Eval_exp();\n\n      case EXPAND:\n        return Eval_expand();\n\n      case EXPCOS:\n        return Eval_expcos();\n\n      case EXPSIN:\n        return Eval_expsin();\n\n      case FACTOR:\n        return Eval_factor();\n\n      case FACTORIAL:\n        return Eval_factorial();\n\n      case FACTORPOLY:\n        return Eval_factorpoly();\n\n      case FILTER:\n        return Eval_filter();\n\n      case FLOATF:\n        return Eval_float();\n\n      case APPROXRATIO:\n        return Eval_approxratio();\n\n      case FLOOR:\n        return Eval_floor();\n\n      case FOR:\n        return Eval_for();\n\n      case FUNCTION:\n        return Eval_function_reference();\n\n      case GAMMA:\n        return Eval_gamma();\n\n      case GCD:\n        return Eval_gcd();\n\n      case HERMITE:\n        return Eval_hermite();\n\n      case HILBERT:\n        return Eval_hilbert();\n\n      case IMAG:\n        return Eval_imag();\n\n      case INDEX:\n        return Eval_index();\n\n      case INNER:\n        return _Eval_inner();\n\n      case INTEGRAL:\n        return Eval_integral();\n\n      case INV:\n        return Eval_inv();\n\n      case INVG:\n        return Eval_invg();\n\n      case ISINTEGER:\n        return Eval_isinteger();\n\n      case ISPRIME:\n        return Eval_isprime();\n\n      case LAGUERRE:\n        return Eval_laguerre();\n\n      case LCM:\n        return Eval_lcm();\n\n      case LEADING:\n        return Eval_leading();\n\n      case LEGENDRE:\n        return Eval_legendre();\n\n      case LOG:\n        return Eval_log();\n\n      case LOOKUP:\n        return Eval_lookup();\n\n      case MOD:\n        return Eval_mod();\n\n      case MULTIPLY:\n        return Eval_multiply();\n\n      case NOT:\n        return Eval_not();\n\n      case NROOTS:\n        return Eval_nroots();\n\n      case NUMBER:\n        return Eval_number();\n\n      case NUMERATOR:\n        return Eval_numerator();\n\n      case OPERATOR:\n        return Eval_operator();\n\n      case OR:\n        return Eval_or();\n\n      case OUTER:\n        return Eval_outer();\n\n      case PATTERN:\n        return Eval_pattern();\n\n      case PATTERNSINFO:\n        return Eval_patternsinfo();\n\n      case POLAR:\n        return Eval_polar();\n\n      case POWER:\n        return Eval_power();\n\n      case PRIME:\n        return Eval_prime();\n\n      case PRINT:\n        return Eval_print();\n\n      case PRINT2DASCII:\n        return Eval_print2dascii();\n\n      case PRINTFULL:\n        return Eval_printcomputer();\n\n      case PRINTLATEX:\n        return Eval_printlatex();\n\n      case PRINTLIST:\n        return Eval_printlist();\n\n      case PRINTPLAIN:\n        return Eval_printhuman();\n\n      case PRODUCT:\n        return Eval_product();\n\n      case QUOTE:\n        return Eval_quote();\n\n      case QUOTIENT:\n        return Eval_quotient();\n\n      case RANK:\n        return Eval_rank();\n\n      case RATIONALIZE:\n        return Eval_rationalize();\n\n      case REAL:\n        return Eval_real();\n\n      case ROUND:\n        return Eval_round();\n\n      case YYRECT:\n        return Eval_rect();\n\n      case ROOTS:\n        return Eval_roots();\n\n      case SETQ:\n        return Eval_setq();\n\n      case SGN:\n        return Eval_sgn();\n\n      case SILENTPATTERN:\n        return Eval_silentpattern();\n\n      case SIMPLIFY:\n        return Eval_simplify();\n\n      case SIN:\n        return Eval_sin();\n\n      case SINH:\n        return Eval_sinh();\n\n      case SHAPE:\n        return Eval_shape();\n\n      case SQRT:\n        return Eval_sqrt();\n\n      case STOP:\n        return Eval_stop();\n\n      case SUBST:\n        return Eval_subst();\n\n      case SUM:\n        return Eval_sum();\n\n      case SYMBOLSINFO:\n        return Eval_symbolsinfo();\n\n      case TAN:\n        return Eval_tan();\n\n      case TANH:\n        return Eval_tanh();\n\n      case TAYLOR:\n        return Eval_taylor();\n\n      case TEST:\n        return Eval_test();\n\n      case TESTEQ:\n        return Eval_testeq();\n\n      case TESTGE:\n        return Eval_testge();\n\n      case TESTGT:\n        return Eval_testgt();\n\n      case TESTLE:\n        return Eval_testle();\n\n      case TESTLT:\n        return Eval_testlt();\n\n      case TRANSPOSE:\n        return Eval_transpose();\n\n      case UNIT:\n        return Eval_unit();\n\n      case ZERO:\n        return Eval_zero();\n\n      default:\n        return Eval_user_function();\n    }\n  };\n\n  Eval_binding = function Eval_binding() {\n    return push(get_binding(cadr(p1)));\n  };\n  /* check =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  p\n  \n  General description\n  -------------------\n  Returns whether the predicate p is true/false or unknown:\n  0 if false, 1 if true or remains unevaluated if unknown.\n  Note that if \"check\" is passed an assignment, it turns it into a test,\n  i.e. check(a = b) is turned into check(a==b) \n  so \"a\" is not assigned anything.\n  Like in many programming languages, \"check\" also gives truthyness/falsyness\n  for numeric values. In which case, \"true\" is returned for non-zero values.\n  Potential improvements: \"check\" can't evaluate strings yet.\n   */\n\n\n  Eval_check = function Eval_check() {\n    var checkResult;\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n\n    if (checkResult == null) {\n      return push(p1);\n    } else {\n      return push_integer(checkResult);\n    }\n  };\n\n  Eval_det = function Eval_det() {\n    push(cadr(p1));\n    Eval();\n    return det();\n  };\n  /* dim =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m,n\n  \n  General description\n  -------------------\n  Returns the cardinality of the nth index of tensor \"m\".\n   */\n\n\n  Eval_dim = function Eval_dim() {\n    var n;\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n\n    if (iscons(cddr(p1))) {\n      push(caddr(p1));\n      Eval();\n      n = pop_integer();\n    } else {\n      n = 1;\n    }\n\n    if (!istensor(p2)) {\n      return push_integer(1);\n    } else if (n < 1 || n > p2.tensor.ndim) {\n      return push(p1);\n    } else {\n      return push_integer(p2.tensor.dim[n - 1]);\n    }\n  };\n\n  Eval_divisors = function Eval_divisors() {\n    push(cadr(p1));\n    Eval();\n    return divisors();\n  };\n  /* do =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  a,b,...\n  \n  General description\n  -------------------\n  Evaluates each argument from left to right. Returns the result of the last argument.\n   */\n\n\n  Eval_do = function Eval_do() {\n    var results;\n    push(car(p1));\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      pop();\n      push(car(p1));\n      Eval();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  Eval_dsolve = function Eval_dsolve() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    return dsolve();\n  };\n\n  Eval_Eval = function Eval_Eval() {\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      push(cadr(p1));\n      Eval();\n\n      _subst();\n\n      p1 = cddr(p1);\n    }\n\n    return Eval();\n  };\n\n  Eval_exp = function Eval_exp() {\n    push(cadr(p1));\n    Eval();\n    return exponential();\n  };\n\n  Eval_factorial = function Eval_factorial() {\n    push(cadr(p1));\n    Eval();\n    return factorial();\n  };\n\n  Eval_factorpoly = function Eval_factorpoly() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    factorpoly();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factorpoly();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  Eval_hermite = function Eval_hermite() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return hermite();\n  };\n\n  Eval_hilbert = function Eval_hilbert() {\n    push(cadr(p1));\n    Eval();\n    return hilbert();\n  };\n\n  Eval_index = function Eval_index() {\n    var h, orig, theTensor;\n    h = tos;\n    orig = p1;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    theTensor = stack[tos - 1];\n\n    if (isNumericAtom(theTensor)) {\n      stop(\"trying to access a scalar as a tensor\");\n    }\n\n    if (!istensor(theTensor)) {\n      moveTos(h);\n      push(orig);\n      return;\n    }\n\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n\n      if (!isintegerorintegerfloat(stack[tos - 1])) {\n        moveTos(h);\n        push(orig);\n        return;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    return index_function(tos - h);\n  };\n\n  Eval_inv = function Eval_inv() {\n    push(cadr(p1));\n    Eval();\n    return _inv();\n  };\n\n  Eval_invg = function Eval_invg() {\n    push(cadr(p1));\n    Eval();\n    return invg();\n  };\n\n  Eval_isinteger = function Eval_isinteger() {\n    var n;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n\n    if (isrational(p1)) {\n      if (isinteger(p1)) {\n        push(one);\n      } else {\n        push(zero);\n      }\n\n      return;\n    }\n\n    if (isdouble(p1)) {\n      n = Math.floor(p1.d);\n\n      if (n === p1.d) {\n        push(one);\n      } else {\n        push(zero);\n      }\n\n      return;\n    }\n\n    push_symbol(ISINTEGER);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_number = function Eval_number() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n\n    if (p1.k === NUM || p1.k === DOUBLE) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_operator = function Eval_operator() {\n    var h;\n    h = tos;\n    push_symbol(OPERATOR);\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p1 = cdr(p1);\n    }\n\n    return list(tos - h);\n  };\n\n  Eval_quote = function Eval_quote() {\n    return push(cadr(p1));\n  };\n\n  Eval_rank = function Eval_rank() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n\n    if (istensor(p1)) {\n      return push_integer(p1.tensor.ndim);\n    } else {\n      return push(zero);\n    }\n  };\n\n  Eval_setq = function Eval_setq() {\n    if (caadr(p1) === symbol(INDEX)) {\n      setq_indexed();\n      return;\n    }\n\n    if (iscons(cadr(p1))) {\n      define_user_function();\n      return;\n    }\n\n    if (!issymbol(cadr(p1))) {\n      stop(\"symbol assignment: error in symbol\");\n    }\n\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    set_binding(cadr(p1), p2);\n    return push(symbol(NIL));\n  };\n\n  setq_indexed = function setq_indexed() {\n    var h;\n    p4 = cadadr(p1);\n    console.log(\"p4: \" + p4);\n\n    if (!issymbol(p4)) {\n      stop(\"indexed assignment: expected a symbol name\");\n    }\n\n    h = tos;\n    push(caddr(p1));\n    Eval();\n    p2 = cdadr(p1);\n\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      p2 = cdr(p2);\n    }\n\n    set_component(tos - h);\n    p3 = pop();\n    set_binding(p4, p3);\n    return push(symbol(NIL));\n  };\n\n  Eval_sqrt = function Eval_sqrt() {\n    push(cadr(p1));\n    Eval();\n    push_rational(1, 2);\n    return power();\n  };\n\n  Eval_stop = function Eval_stop() {\n    return stop(\"user stop\");\n  };\n\n  Eval_subst = function Eval_subst() {\n    push(cadddr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadr(p1));\n    Eval();\n\n    _subst();\n\n    return Eval();\n  };\n\n  Eval_unit = function Eval_unit() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    n = pop_integer();\n\n    if (isNaN(n)) {\n      push(p1);\n      return;\n    }\n\n    if (n < 1) {\n      push(p1);\n      return;\n    }\n\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[n * i + i] = one;\n    }\n\n    check_tensor_dimensions(p1);\n    return push(p1);\n  };\n\n  Eval_noexpand = function Eval_noexpand() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  Eval_predicate = function Eval_predicate() {\n    save();\n    p1 = top();\n\n    if (car(p1) === symbol(SETQ)) {\n      pop();\n      push_symbol(TESTEQ);\n      push(cadr(p1));\n      push(caddr(p1));\n      list(3);\n    }\n\n    Eval();\n    return restore();\n  };\n\n  Eval_expand = function Eval_expand() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n\n    return _expand();\n  };\n\n  _expand = function expand() {\n    var prev_expanding;\n    save();\n    p9 = pop();\n    p5 = pop();\n\n    if (istensor(p5)) {\n      expand_tensor();\n      restore();\n      return;\n    }\n\n    if (car(p5) === symbol(ADD)) {\n      push_integer(0);\n      p1 = cdr(p5);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p9);\n\n        _expand();\n\n        add();\n        p1 = cdr(p1);\n      }\n\n      restore();\n      return;\n    }\n\n    push(p5);\n\n    _numerator();\n\n    p3 = pop();\n    push(p5);\n\n    _denominator();\n\n    p2 = pop();\n    remove_negative_exponents();\n    push(p3);\n    push(p2);\n    push(p9);\n\n    if (isone(p3) || isone(p2)) {\n      if (!ispolyexpandedform(p2, p9) || isone(p2)) {\n        pop();\n        pop();\n        pop();\n        push(p5);\n        restore();\n        return;\n      }\n    }\n\n    divpoly();\n    p7 = pop();\n    push(p3);\n    push(p2);\n    push(p7);\n    multiply();\n    subtract();\n    p3 = pop();\n\n    if (isZeroAtomOrTensor(p3)) {\n      push(p7);\n      restore();\n      return;\n    }\n\n    push(p2);\n    push(p9);\n    factorpoly();\n    p2 = pop();\n    expand_get_C();\n    expand_get_B();\n    expand_get_A();\n\n    if (istensor(p4)) {\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n\n      _inv();\n\n      expanding = prev_expanding;\n      push(p3);\n\n      _inner();\n\n      push(p2);\n\n      _inner();\n    } else {\n      push(p3);\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p2);\n      multiply();\n    }\n\n    push(p7);\n    add();\n    return restore();\n  };\n\n  expand_tensor = function expand_tensor() {\n    var i, o, ref;\n    i = 0;\n    push(p5);\n    copy_tensor();\n    p5 = pop();\n\n    for (i = o = 0, ref = p5.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push(p5.tensor.elem[i]);\n      push(p9);\n\n      _expand();\n\n      p5.tensor.elem[i] = pop();\n    }\n\n    return push(p5);\n  };\n\n  remove_negative_exponents = function remove_negative_exponents() {\n    var h, i, j, k, n, o, ref;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    n = 0;\n    h = tos;\n    factors(p2);\n    factors(p3);\n    n = tos - h;\n    j = 0;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p1 = stack[h + i];\n\n      if (car(p1) !== symbol(POWER)) {\n        continue;\n      }\n\n      if (cadr(p1) !== p9) {\n        continue;\n      }\n\n      push(caddr(p1));\n      k = pop_integer();\n\n      if (isNaN(k)) {\n        continue;\n      }\n\n      if (k < j) {\n        j = k;\n      }\n    }\n\n    moveTos(h);\n\n    if (j === 0) {\n      return;\n    }\n\n    push(p2);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    p2 = pop();\n    push(p3);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    return p3 = pop();\n  };\n\n  expand_get_C = function expand_get_C() {\n    var a, h, i, i1, j, n, o, prev_expanding, ref, ref1;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    h = tos;\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      p1 = cdr(p2);\n\n      while (iscons(p1)) {\n        p5 = car(p1);\n        expand_get_CF();\n        p1 = cdr(p1);\n      }\n    } else {\n      p5 = p2;\n      expand_get_CF();\n    }\n\n    n = tos - h;\n\n    if (n === 1) {\n      p4 = pop();\n      return;\n    }\n\n    p4 = alloc_tensor(n * n);\n    p4.tensor.ndim = 2;\n    p4.tensor.dim[0] = n;\n    p4.tensor.dim[1] = n;\n    a = h;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        push(stack[a + j]);\n        push(p9);\n        push_integer(i);\n        power();\n        prev_expanding = expanding;\n        expanding = 1;\n        divide();\n        expanding = prev_expanding;\n        push(p9);\n        filter();\n        p4.tensor.elem[n * i + j] = pop();\n      }\n    }\n\n    return moveTos(tos - n);\n  };\n\n  expand_get_CF = function expand_get_CF() {\n    var d, i, j, n, o, prev_expanding, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n\n    if (!_Find(p5, p9)) {\n      return;\n    }\n\n    prev_expanding = expanding;\n    expanding = 1;\n    trivial_divide();\n    expanding = prev_expanding;\n\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p6 = cadr(p5);\n    } else {\n      n = 1;\n      p6 = p5;\n    }\n\n    push(p6);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      results.push(function () {\n        var i1, ref1, results1;\n        results1 = [];\n\n        for (j = i1 = 0, ref1 = d; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p8);\n          push(p6);\n          push_integer(i);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          expanding = prev_expanding;\n          push(p9);\n          push_integer(j);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          results1.push(expanding = prev_expanding);\n        }\n\n        return results1;\n      }());\n    }\n\n    return results;\n  };\n\n  trivial_divide = function trivial_divide() {\n    var h;\n    h = 0;\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      h = tos;\n      p0 = cdr(p2);\n\n      while (iscons(p0)) {\n        if (!equal(car(p0), p5)) {\n          push(car(p0));\n          Eval();\n        }\n\n        p0 = cdr(p0);\n      }\n\n      multiply_all(tos - h);\n    } else {\n      push_integer(1);\n    }\n\n    return p8 = pop();\n  };\n\n  expand_get_B = function expand_get_B() {\n    var i, n, o, prev_expanding, ref;\n    i = 0;\n    n = 0;\n\n    if (!istensor(p4)) {\n      return;\n    }\n\n    n = p4.tensor.dim[0];\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push(p3);\n      push(p9);\n      push_integer(i);\n      power();\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p9);\n      filter();\n      p8.tensor.elem[i] = pop();\n    }\n\n    return p3 = p8;\n  };\n\n  expand_get_A = function expand_get_A() {\n    var h, i, n, o, ref;\n    h = 0;\n    i = 0;\n    n = 0;\n\n    if (!istensor(p4)) {\n      push(p2);\n      reciprocate();\n      p2 = pop();\n      return;\n    }\n\n    h = tos;\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      p8 = cdr(p2);\n\n      while (iscons(p8)) {\n        p5 = car(p8);\n        expand_get_AF();\n        p8 = cdr(p8);\n      }\n    } else {\n      p5 = p2;\n      expand_get_AF();\n    }\n\n    n = tos - h;\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p8.tensor.elem[i] = stack[h + i];\n    }\n\n    moveTos(h);\n    return p2 = p8;\n  };\n\n  expand_get_AF = function expand_get_AF() {\n    var d, i, j, n, o, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 1;\n\n    if (!_Find(p5, p9)) {\n      return;\n    }\n\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p5 = cadr(p5);\n    }\n\n    push(p5);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n\n    for (i = o = ref = n; ref <= 0 ? o < 0 : o > 0; i = ref <= 0 ? ++o : --o) {\n      results.push(function () {\n        var i1, ref1, results1;\n        results1 = [];\n\n        for (j = i1 = 0, ref1 = d; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p5);\n          push_integer(i);\n          power();\n          reciprocate();\n          push(p9);\n          push_integer(j);\n          power();\n          results1.push(multiply());\n        }\n\n        return results1;\n      }());\n    }\n\n    return results;\n  };\n\n  Eval_expcos = function Eval_expcos() {\n    push(cadr(p1));\n    Eval();\n    return expcos();\n  };\n\n  expcos = function expcos() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    add();\n    return restore();\n  };\n\n  Eval_expsin = function Eval_expsin() {\n    push(cadr(p1));\n    Eval();\n    return expsin();\n  };\n\n  expsin = function expsin() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    subtract();\n    return restore();\n  };\n\n  Eval_factor = function Eval_factor() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n\n    factor();\n    p1 = cdddr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factor_again();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  factor_again = function factor_again() {\n    var h, n;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        factor_term();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      factor_term();\n    }\n\n    n = tos - h;\n\n    if (n > 1) {\n      multiply_all_noexpand(n);\n    }\n\n    return restore();\n  };\n\n  factor_term = function factor_term() {\n    save();\n    factorpoly();\n    p1 = pop();\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n    }\n\n    return restore();\n  };\n\n  factor = function factor() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isinteger(p1)) {\n      push(p1);\n      factor_number();\n    } else {\n      push(p1);\n      push(p2);\n      factorpoly();\n    }\n\n    return restore();\n  };\n\n  factor_small_number = function factor_small_number() {\n    var d, expo, i, n, o, ref;\n    i = 0;\n    save();\n    n = pop_integer();\n\n    if (isNaN(n)) {\n      stop(\"number too big to factor\");\n    }\n\n    if (n < 0) {\n      n = -n;\n    }\n\n    for (i = o = 0, ref = MAXPRIMETAB; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      d = primetab[i];\n\n      if (d > n / d) {\n        break;\n      }\n\n      expo = 0;\n\n      while (n % d === 0) {\n        n /= d;\n        expo++;\n      }\n\n      if (expo) {\n        push_integer(d);\n        push_integer(expo);\n      }\n    }\n\n    if (n > 1) {\n      push_integer(n);\n      push_integer(1);\n    }\n\n    return restore();\n  };\n\n  factorial = function factorial() {\n    var n;\n    n = 0;\n    save();\n    p1 = pop();\n    push(p1);\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push_symbol(FACTORIAL);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    bignum_factorial(n);\n    return restore();\n  };\n\n  _simplifyfactorials = function simplifyfactorials() {\n    var x;\n    x = 0;\n    save();\n    x = expanding;\n    expanding = 0;\n    p1 = pop();\n\n    if (car(p1) === symbol(ADD)) {\n      push(zero);\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _simplifyfactorials();\n\n        add();\n        p1 = cdr(p1);\n      }\n\n      expanding = x;\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      sfac_product();\n      expanding = x;\n      restore();\n      return;\n    }\n\n    push(p1);\n    expanding = x;\n    return restore();\n  };\n\n  sfac_product = function sfac_product() {\n    var i, i1, j, j1, n, o, ref, ref1, ref2, ref3, s;\n    i = 0;\n    j = 0;\n    n = 0;\n    s = tos;\n    p1 = cdr(p1);\n    n = 0;\n\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      n++;\n    }\n\n    for (i = o = 0, ref = n - 1; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n\n      for (j = i1 = ref1 = i + 1, ref2 = n; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (stack[s + j] === symbol(NIL)) {\n          continue;\n        }\n\n        sfac_product_f(s, i, j);\n      }\n    }\n\n    push(one);\n\n    for (i = j1 = 0, ref3 = n; 0 <= ref3 ? j1 < ref3 : j1 > ref3; i = 0 <= ref3 ? ++j1 : --j1) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n\n      push(stack[s + i]);\n      multiply();\n    }\n\n    p1 = pop();\n    moveTos(tos - n);\n    return push(p1);\n  };\n\n  sfac_product_f = function sfac_product_f(s, a, b) {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    p1 = stack[s + a];\n    p2 = stack[s + b];\n\n    if (ispower(p1)) {\n      p3 = caddr(p1);\n      p1 = cadr(p1);\n    } else {\n      p3 = one;\n    }\n\n    if (ispower(p2)) {\n      p4 = caddr(p2);\n      p2 = cadr(p2);\n    } else {\n      p4 = one;\n    }\n\n    if (isfactorial(p1) && isfactorial(p2)) {\n      push(p3);\n      push(p4);\n      add();\n      yyexpand();\n      n = pop_integer();\n\n      if (n !== 0) {\n        return;\n      }\n\n      push(cadr(p1));\n      push(cadr(p2));\n      subtract();\n      yyexpand();\n      n = pop_integer();\n\n      if (n === 0 || isNaN(n)) {\n        return;\n      }\n\n      if (n < 0) {\n        n = -n;\n        p5 = p1;\n        p1 = p2;\n        p2 = p5;\n        p5 = p3;\n        p3 = p4;\n        p4 = p5;\n      }\n\n      push(one);\n\n      for (i = o = 1, ref = n; 1 <= ref ? o <= ref : o >= ref; i = 1 <= ref ? ++o : --o) {\n        push(cadr(p2));\n        push_integer(i);\n        add();\n        push(p3);\n        power();\n        multiply();\n      }\n\n      stack[s + a] = pop();\n      return stack[s + b] = symbol(NIL);\n    }\n  };\n\n  polycoeff = 0;\n  factpoly_expo = 0;\n\n  factorpoly = function factorpoly() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (!_Find(p1, p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (!ispolyexpandedform(p1, p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (!issymbol(p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    push(p1);\n    push(p2);\n    yyfactorpoly();\n    return restore();\n  };\n\n  yyfactorpoly = function yyfactorpoly() {\n    var checkingTheDivision, dividend, foundComplexRoot, foundRealRoot, h, i, i1, j1, l1, o, prev_expanding, previousFactorisation, ref, ref1, ref2, ref3, remainingPoly, whichRootsAreWeFinding;\n    h = 0;\n    i = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n\n    if (_isfloating(p1)) {\n      stop(\"floating point numbers in polynomial\");\n    }\n\n    polycoeff = tos;\n    push(p1);\n    push(p2);\n    factpoly_expo = coeff() - 1;\n    rationalize_coefficients(h);\n    whichRootsAreWeFinding = \"real\";\n    remainingPoly = null;\n\n    while (factpoly_expo > 0) {\n      if (isZeroAtomOrTensor(stack[polycoeff + 0])) {\n        push_integer(1);\n        p4 = pop();\n        push_integer(0);\n        p5 = pop();\n      } else {\n        if (whichRootsAreWeFinding === \"real\") {\n          foundRealRoot = get_factor_from_real_root();\n        } else if (whichRootsAreWeFinding === \"complex\") {\n          foundComplexRoot = get_factor_from_complex_root(remainingPoly);\n        }\n      }\n\n      if (whichRootsAreWeFinding === \"real\") {\n        if (foundRealRoot === 0) {\n          whichRootsAreWeFinding = \"complex\";\n          continue;\n        } else {\n          push(p4);\n          push(p2);\n          multiply();\n          push(p5);\n          add();\n          p8 = pop();\n\n          if (DEBUG) {\n            console.log(\"success\\nFACTOR=\" + p8);\n          }\n          /*\n          if (isnegativeterm(p4))\n            push(p8)\n            negate()\n            p8 = pop()\n            push(p7)\n            negate_noexpand()\n            p7 = pop()\n           */\n\n\n          push(p7);\n          push(p8);\n          multiply_noexpand();\n          p7 = pop();\n          yydivpoly();\n\n          while (factpoly_expo && isZeroAtomOrTensor(stack[polycoeff + factpoly_expo])) {\n            factpoly_expo--;\n          }\n\n          push(zero);\n\n          for (i = o = 0, ref = factpoly_expo; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {\n            push(stack[polycoeff + i]);\n            push(p2);\n            push_integer(i);\n            power();\n            multiply();\n            add();\n          }\n\n          remainingPoly = pop();\n        }\n      } else if (whichRootsAreWeFinding === \"complex\") {\n        if (foundComplexRoot === 0) {\n          break;\n        } else {\n          push(p4);\n          push(p2);\n          subtract();\n          push(p4);\n          conjugate();\n          push(p2);\n          subtract();\n          multiply();\n          p8 = pop();\n\n          if (DEBUG) {\n            console.log(\"success\\nFACTOR=\" + p8);\n          }\n          /*\n          if (isnegativeterm(p4))\n            push(p8)\n            negate()\n            p8 = pop()\n            push(p7)\n            negate_noexpand()\n            p7 = pop()\n           */\n\n\n          push(p7);\n          previousFactorisation = pop();\n          push(p7);\n          push(p8);\n          multiply_noexpand();\n          p7 = pop();\n\n          if (remainingPoly == null) {\n            push(zero);\n\n            for (i = i1 = 0, ref1 = factpoly_expo; 0 <= ref1 ? i1 <= ref1 : i1 >= ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n              push(stack[polycoeff + i]);\n              push(p2);\n              push_integer(i);\n              power();\n              multiply();\n              add();\n            }\n\n            remainingPoly = pop();\n          }\n\n          dividend = remainingPoly;\n          push(dividend);\n          push(p8);\n          push(p2);\n          divpoly();\n          remainingPoly = pop();\n          push(remainingPoly);\n          push(p8);\n          multiply();\n          checkingTheDivision = pop();\n\n          if (!equal(checkingTheDivision, dividend)) {\n            if (DEBUG) {\n              console.log(\"we found a polynomial based on complex root and its conj but it doesn't divide the poly, quitting\");\n            }\n\n            if (DEBUG) {\n              console.log(\"so just returning previousFactorisation times dividend: \" + previousFactorisation + \" * \" + dividend);\n            }\n\n            push(previousFactorisation);\n            push(dividend);\n            prev_expanding = expanding;\n            expanding = 0;\n            yycondense();\n            expanding = prev_expanding;\n            multiply_noexpand();\n            p7 = pop();\n            stack[h] = p7;\n            moveTos(h + 1);\n            restore();\n            return;\n          }\n          /*\n          if compare_numbers(startingDegree, remainingDegree)\n             * ok even if we found a complex root that\n             * together with the conjugate generates a poly in Z,\n             * that doesn't mean that the division would end up in Z.\n             * Example: 1+x^2+x^4+x^6 has +i and -i as one of its roots\n             * so a factor is 1+x^2 ( = (x+i)*(x-i))\n             * BUT\n           */\n\n\n          for (i = j1 = 0, ref2 = factpoly_expo; 0 <= ref2 ? j1 <= ref2 : j1 >= ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n            pop();\n          }\n\n          push(remainingPoly);\n          push(p2);\n          coeff();\n          factpoly_expo -= 2;\n        }\n      }\n    }\n\n    push(zero);\n\n    for (i = l1 = 0, ref3 = factpoly_expo; 0 <= ref3 ? l1 <= ref3 : l1 >= ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[polycoeff + i]);\n      push(p2);\n      push_integer(i);\n      power();\n      multiply();\n      add();\n    }\n\n    p1 = pop();\n\n    if (DEBUG) {\n      console.log(\"POLY=\" + p1);\n    }\n\n    push(p1);\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    p1 = pop();\n\n    if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff + factpoly_expo])) {\n      push(p1);\n      negate();\n      p1 = pop();\n      push(p7);\n      negate_noexpand();\n      p7 = pop();\n    }\n\n    push(p7);\n    push(p1);\n    multiply_noexpand();\n    p7 = pop();\n\n    if (DEBUG) {\n      console.log(\"RESULT=\" + p7);\n    }\n\n    stack[h] = p7;\n    moveTos(h + 1);\n    return restore();\n  };\n\n  rationalize_coefficients = function rationalize_coefficients(h) {\n    var i, i1, o, ref, ref1, ref2, ref3;\n    i = 0;\n    p7 = one;\n\n    for (i = o = ref = h, ref1 = tos; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {\n      push(stack[i]);\n\n      _denominator();\n\n      push(p7);\n      lcm();\n      p7 = pop();\n    }\n\n    for (i = i1 = ref2 = h, ref3 = tos; ref2 <= ref3 ? i1 < ref3 : i1 > ref3; i = ref2 <= ref3 ? ++i1 : --i1) {\n      push(p7);\n      push(stack[i]);\n      multiply();\n      stack[i] = pop();\n    }\n\n    push(p7);\n    reciprocate();\n    p7 = pop();\n\n    if (DEBUG) {\n      return console.log(\"rationalize_coefficients result\");\n    }\n  };\n\n  get_factor_from_real_root = function get_factor_from_real_root() {\n    var a0, an, h, i, i1, j, j1, l1, m1, na0, nan, o, ref, ref1, ref2, ref3, ref4, rootsTries_i, rootsTries_j;\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n\n    if (DEBUG) {\n      push(zero);\n\n      for (i = o = 0, ref = factpoly_expo; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {\n        push(stack[polycoeff + i]);\n        push(p2);\n        push_integer(i);\n        power();\n        multiply();\n        add();\n      }\n\n      p1 = pop();\n      console.log(\"POLY=\" + p1);\n    }\n\n    h = tos;\n    an = tos;\n    push(stack[polycoeff + factpoly_expo]);\n    divisors_onstack();\n    nan = tos - an;\n    a0 = tos;\n    push(stack[polycoeff + 0]);\n    divisors_onstack();\n    na0 = tos - a0;\n\n    if (DEBUG) {\n      console.log(\"divisors of base term\");\n\n      for (i = i1 = 0, ref1 = na0; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        console.log(\", \" + stack[a0 + i]);\n      }\n\n      console.log(\"divisors of leading term\");\n\n      for (i = j1 = 0, ref2 = nan; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n        console.log(\", \" + stack[an + i]);\n      }\n    }\n\n    for (rootsTries_i = l1 = 0, ref3 = nan; 0 <= ref3 ? l1 < ref3 : l1 > ref3; rootsTries_i = 0 <= ref3 ? ++l1 : --l1) {\n      for (rootsTries_j = m1 = 0, ref4 = na0; 0 <= ref4 ? m1 < ref4 : m1 > ref4; rootsTries_j = 0 <= ref4 ? ++m1 : --m1) {\n        p4 = stack[an + rootsTries_i];\n        p5 = stack[a0 + rootsTries_j];\n        push(p5);\n        push(p4);\n        divide();\n        negate();\n        p3 = pop();\n        Evalpoly();\n\n        if (DEBUG) {\n          console.log(\"try A=\" + p4);\n          console.log(\", B=\" + p5);\n          console.log(\", root \" + p2);\n          console.log(\"=-B/A=\" + p3);\n          console.log(\", POLY(\" + p3);\n          console.log(\")=\" + p6);\n        }\n\n        if (isZeroAtomOrTensor(p6)) {\n          moveTos(h);\n\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n\n          return 1;\n        }\n\n        push(p5);\n        negate();\n        p5 = pop();\n        push(p3);\n        negate();\n        p3 = pop();\n        Evalpoly();\n\n        if (DEBUG) {\n          console.log(\"try A=\" + p4);\n          console.log(\", B=\" + p5);\n          console.log(\", root \" + p2);\n          console.log(\"=-B/A=\" + p3);\n          console.log(\", POLY(\" + p3);\n          console.log(\")=\" + p6);\n        }\n\n        if (isZeroAtomOrTensor(p6)) {\n          moveTos(h);\n\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n\n          return 1;\n        }\n      }\n    }\n\n    moveTos(h);\n\n    if (DEBUG) {\n      console.log(\"get_factor_from_real_root returning 0\");\n    }\n\n    return 0;\n  };\n\n  get_factor_from_complex_root = function get_factor_from_complex_root(remainingPoly) {\n    var a0, an, h, i, i1, j, na0, nan, o, rootsTries_i, rootsTries_j;\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n\n    if (factpoly_expo <= 2) {\n      if (DEBUG) {\n        console.log(\"no more factoring via complex roots to be found in polynomial of degree <= 2\");\n      }\n\n      return 0;\n    }\n\n    p1 = remainingPoly;\n\n    if (DEBUG) {\n      console.log(\"complex root finding for POLY=\" + p1);\n    }\n\n    h = tos;\n    an = tos;\n    push_integer(-1);\n    push_rational(2, 3);\n    power();\n\n    _rect();\n\n    p4 = pop();\n\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + p4);\n    }\n\n    push(p4);\n    p3 = pop();\n    push(p3);\n    Evalpoly();\n\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + p6);\n    }\n\n    if (isZeroAtomOrTensor(p6)) {\n      moveTos(h);\n\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n\n      return 1;\n    }\n\n    push_integer(1);\n    push_rational(2, 3);\n    power();\n\n    _rect();\n\n    p4 = pop();\n\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + p4);\n    }\n\n    push(p4);\n    p3 = pop();\n    push(p3);\n    Evalpoly();\n\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + p6);\n    }\n\n    if (isZeroAtomOrTensor(p6)) {\n      moveTos(h);\n\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n\n      return 1;\n    }\n\n    for (rootsTries_i = o = -10; o <= 10; rootsTries_i = ++o) {\n      for (rootsTries_j = i1 = 1; i1 <= 5; rootsTries_j = ++i1) {\n        push_integer(rootsTries_i);\n        push_integer(rootsTries_j);\n        push(imaginaryunit);\n        multiply();\n        add();\n\n        _rect();\n\n        p4 = pop();\n        push(p4);\n        p3 = pop();\n        push(p3);\n        Evalpoly();\n\n        if (isZeroAtomOrTensor(p6)) {\n          moveTos(h);\n\n          if (DEBUG) {\n            console.log(\"found complex root: \" + p6);\n          }\n\n          return 1;\n        }\n      }\n    }\n\n    moveTos(h);\n\n    if (DEBUG) {\n      console.log(\"get_factor_from_complex_root returning 0\");\n    }\n\n    return 0;\n  };\n\n  yydivpoly = function yydivpoly() {\n    var i, o, ref;\n    i = 0;\n    p6 = zero;\n\n    for (i = o = ref = factpoly_expo; ref <= 0 ? o < 0 : o > 0; i = ref <= 0 ? ++o : --o) {\n      push(stack[polycoeff + i]);\n      stack[polycoeff + i] = p6;\n      push(p4);\n      divide();\n      p6 = pop();\n      push(stack[polycoeff + i - 1]);\n      push(p6);\n      push(p5);\n      multiply();\n      subtract();\n      stack[polycoeff + i - 1] = pop();\n    }\n\n    stack[polycoeff + 0] = p6;\n\n    if (DEBUG) {\n      return console.log(\"yydivpoly Q:\");\n    }\n  };\n\n  Evalpoly = function Evalpoly() {\n    var i, o, ref;\n    i = 0;\n    push(zero);\n\n    for (i = o = ref = factpoly_expo; ref <= 0 ? o <= 0 : o >= 0; i = ref <= 0 ? ++o : --o) {\n      push(p3);\n      multiply();\n      push(stack[polycoeff + i]);\n\n      if (DEBUG) {\n        console.log(\"Evalpoly top of stack:\");\n        console.log(_print_list(stack[tos - i]));\n      }\n\n      add();\n    }\n\n    return p6 = pop();\n  };\n\n  factors = function factors(p) {\n    var h;\n    h = tos;\n\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n\n      while (iscons(p)) {\n        push_term_factors(car(p));\n        p = cdr(p);\n      }\n    } else {\n      push_term_factors(p);\n    }\n\n    return tos - h;\n  };\n\n  push_term_factors = function push_term_factors(p) {\n    var results;\n\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else {\n      return push(p);\n    }\n  };\n  /*\n  Remove terms that involve a given symbol or expression. For example...\n  \n    filter(x^2 + x + 1, x)    =>  1\n  \n    filter(x^2 + x + 1, x^2)  =>  x + 1\n   */\n\n\n  Eval_filter = function Eval_filter() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      filter();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n  /*\n   For example...\n  \n    push(F)\n    push(X)\n    filter()\n    F = pop()\n   */\n\n\n  filter = function filter() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    filter_main();\n    return restore();\n  };\n\n  filter_main = function filter_main() {\n    if (car(p1) === symbol(ADD)) {\n      return filter_sum();\n    } else if (istensor(p1)) {\n      return filter_tensor();\n    } else if (_Find(p1, p2)) {\n      return push_integer(0);\n    } else {\n      return push(p1);\n    }\n  };\n\n  filter_sum = function filter_sum() {\n    var results;\n    push_integer(0);\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      filter();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  filter_tensor = function filter_tensor() {\n    var i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    n = p1.tensor.nelem;\n    p3 = alloc_tensor(n);\n    p3.tensor.ndim = p1.tensor.ndim;\n\n    for (i = o = 0, ref = p1.tensor.ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    for (i = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      filter();\n      p3.tensor.elem[i] = pop();\n    }\n\n    return push(p3);\n  };\n\n  Eval_float = function Eval_float() {\n    evaluatingAsFloats++;\n    push(cadr(p1));\n    Eval();\n\n    _yyfloat();\n\n    Eval();\n    return evaluatingAsFloats--;\n  };\n\n  checkFloatHasWorkedOutCompletely = function checkFloatHasWorkedOutCompletely(nodeToCheck) {\n    var numberOfEs, numberOfMults, numberOfPIs, numberOfPowers, numberOfSums;\n    numberOfPowers = _countOccurrencesOfSymbol(symbol(POWER), nodeToCheck);\n    numberOfPIs = _countOccurrencesOfSymbol(symbol(PI), nodeToCheck);\n    numberOfEs = _countOccurrencesOfSymbol(symbol(E), nodeToCheck);\n    numberOfMults = _countOccurrencesOfSymbol(symbol(MULTIPLY), nodeToCheck);\n    numberOfSums = _countOccurrencesOfSymbol(symbol(ADD), nodeToCheck);\n\n    if (DEBUG) {\n      console.log(\"     ... numberOfPowers: \" + numberOfPowers);\n      console.log(\"     ... numberOfPIs: \" + numberOfPIs);\n      console.log(\"     ... numberOfEs: \" + numberOfEs);\n      console.log(\"     ... numberOfMults: \" + numberOfMults);\n      console.log(\"     ... numberOfSums: \" + numberOfSums);\n    }\n\n    if (numberOfPowers > 1 || numberOfPIs > 0 || numberOfEs > 0 || numberOfMults > 1 || numberOfSums > 1) {\n      return stop(\"float: some unevalued parts in \" + nodeToCheck);\n    }\n  };\n\n  zzfloat = function zzfloat() {\n    save();\n    evaluatingAsFloats++;\n    Eval();\n\n    _yyfloat();\n\n    Eval();\n    evaluatingAsFloats--;\n    return restore();\n  };\n\n  _yyfloat = function yyfloat() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    evaluatingAsFloats++;\n    save();\n    p1 = pop();\n\n    if (iscons(p1)) {\n      h = tos;\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _yyfloat();\n\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n    } else if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n\n      for (i = o = 0, ref = p1.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n\n        _yyfloat();\n\n        p1.tensor.elem[i] = pop();\n      }\n\n      push(p1);\n    } else if (p1.k === NUM) {\n      push(p1);\n      bignum_float();\n    } else if (p1 === symbol(PI)) {\n      push_double(Math.PI);\n    } else if (p1 === symbol(E)) {\n      push_double(Math.E);\n    } else {\n      push(p1);\n    }\n\n    restore();\n    return evaluatingAsFloats--;\n  };\n\n  Eval_floor = function Eval_floor() {\n    push(cadr(p1));\n    Eval();\n    return yfloor();\n  };\n\n  yfloor = function yfloor() {\n    save();\n    yyfloor();\n    return restore();\n  };\n\n  yyfloor = function yyfloor() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (!isNumericAtom(p1)) {\n      push_symbol(FLOOR);\n      push(p1);\n      list(2);\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.floor(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n\n    if (isnegativenumber(p1)) {\n      push_integer(-1);\n      return add();\n    }\n  };\n  /*\n  x=0\n  y=2\n  for(do(x=sqrt(2+x),y=2*y/x),k,1,9)\n  float(y)\n  \n  X: k\n  B: 1...9\n  \n  1st parameter is the body\n  2nd parameter is the variable to loop with\n  3rd and 4th are the limits\n   */\n\n\n  Eval_for = function Eval_for() {\n    var i, j, k, loopingVariable, o, ref, ref1;\n    i = 0;\n    j = 0;\n    k = 0;\n    loopingVariable = caddr(p1);\n\n    if (!issymbol(loopingVariable)) {\n      stop(\"for: 2nd arg should be the variable to loop over\");\n    }\n\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n\n    p4 = get_binding(loopingVariable);\n\n    for (i = o = ref = j, ref1 = k; ref <= ref1 ? o <= ref1 : o >= ref1; i = ref <= ref1 ? ++o : --o) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(loopingVariable, p5);\n      push(cadr(p1));\n      Eval();\n      pop();\n    }\n\n    set_binding(loopingVariable, p4);\n    return push_symbol(NIL);\n  };\n\n  Eval_gamma = function Eval_gamma() {\n    push(cadr(p1));\n    Eval();\n    return gamma();\n  };\n\n  gamma = function gamma() {\n    save();\n    gammaf();\n    return restore();\n  };\n\n  gammaf = function gammaf() {\n    p1 = pop();\n\n    if (isrational(p1) && MEQUAL(p1.q.a, 1) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n\n      push_rational(1, 2);\n      power();\n      return;\n    }\n\n    if (isrational(p1) && MEQUAL(p1.q.a, 3) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n\n      push_rational(1, 2);\n      power();\n      push_rational(1, 2);\n      multiply();\n      return;\n    }\n\n    if (isnegativeterm(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n\n      push_integer(-1);\n      multiply();\n\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n\n      push(p1);\n      multiply();\n      sine();\n      push(p1);\n      multiply();\n      push(p1);\n      negate();\n      gamma();\n      multiply();\n      divide();\n      return;\n    }\n\n    if (car(p1) === symbol(ADD)) {\n      gamma_of_sum();\n      return;\n    }\n\n    push_symbol(GAMMA);\n    push(p1);\n    list(2);\n  };\n\n  gamma_of_sum = function gamma_of_sum() {\n    p3 = cdr(p1);\n\n    if (isrational(car(p3)) && MEQUAL(car(p3).q.a, 1) && MEQUAL(car(p3).q.b, 1)) {\n      push(cadr(p3));\n      push(cadr(p3));\n      gamma();\n      return multiply();\n    } else {\n      if (isrational(car(p3)) && MEQUAL(car(p3).q.a, -1) && MEQUAL(car(p3).q.b, 1)) {\n        push(cadr(p3));\n        gamma();\n        push(cadr(p3));\n        push_integer(-1);\n        add();\n        return divide();\n      } else {\n        push_symbol(GAMMA);\n        push(p1);\n        list(2);\n      }\n    }\n  };\n\n  Eval_gcd = function Eval_gcd() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      gcd();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  gcd = function gcd() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    gcd_main();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  gcd_main = function gcd_main() {\n    var polyVar;\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n\n    if (equal(p1, p2)) {\n      push(p1);\n      return;\n    }\n\n    if (isrational(p1) && isrational(p2)) {\n      push(p1);\n      push(p2);\n      gcd_numbers();\n      return;\n    }\n\n    if (polyVar = areunivarpolysfactoredorexpandedform(p1, p2)) {\n      gcd_polys(polyVar);\n      return;\n    }\n\n    if (car(p1) === symbol(ADD) && car(p2) === symbol(ADD)) {\n      gcd_sum_sum();\n      return;\n    }\n\n    if (car(p1) === symbol(ADD)) {\n      gcd_sum(p1);\n      p1 = pop();\n    }\n\n    if (car(p2) === symbol(ADD)) {\n      gcd_sum(p2);\n      p2 = pop();\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      gcd_sum_product();\n      return;\n    }\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      gcd_product_sum();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n\n    return gcd_powers_with_same_base();\n  };\n\n  areunivarpolysfactoredorexpandedform = function areunivarpolysfactoredorexpandedform(p1, p2) {\n    var polyVar;\n\n    if (polyVar = isunivarpolyfactoredorexpandedform(p1)) {\n      if (isunivarpolyfactoredorexpandedform(p2, polyVar)) {\n        return polyVar;\n      }\n    }\n\n    return false;\n  };\n\n  gcd_polys = function gcd_polys(polyVar) {\n    push(p1);\n    push(polyVar);\n    factorpoly();\n    p1 = pop();\n    push(p2);\n    push(polyVar);\n    factorpoly();\n    p2 = pop();\n\n    if (DEBUG) {\n      console.log(\"factored polys:\");\n    }\n\n    if (DEBUG) {\n      console.log(\"p1:\" + p1.toString());\n    }\n\n    if (DEBUG) {\n      console.log(\"p2:\" + p2.toString());\n    }\n\n    if (car(p1) === symbol(MULTIPLY) || car(p2) === symbol(MULTIPLY)) {\n      if (car(p1) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push(one);\n        list(3);\n        p1 = pop();\n      }\n\n      if (car(p2) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p2);\n        push(one);\n        list(3);\n        p2 = pop();\n      }\n    }\n\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n\n    gcd_powers_with_same_base();\n    return true;\n  };\n\n  gcd_product_product = function gcd_product_product() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n\n    while (iscons(p3)) {\n      p4 = cdr(p2);\n\n      while (iscons(p4)) {\n        push(car(p3));\n        push(car(p4));\n        gcd();\n        multiply();\n        p4 = cdr(p4);\n      }\n\n      results.push(p3 = cdr(p3));\n    }\n\n    return results;\n  };\n\n  gcd_powers_with_same_base = function gcd_powers_with_same_base() {\n    if (car(p1) === symbol(POWER)) {\n      p3 = caddr(p1);\n      p1 = cadr(p1);\n    } else {\n      p3 = one;\n    }\n\n    if (car(p2) === symbol(POWER)) {\n      p4 = caddr(p2);\n      p2 = cadr(p2);\n    } else {\n      p4 = one;\n    }\n\n    if (!equal(p1, p2)) {\n      push(one);\n      return;\n    }\n\n    if (isNumericAtom(p3) && isNumericAtom(p4)) {\n      push(p1);\n\n      if (lessp(p3, p4)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n\n      power();\n      return;\n    }\n\n    push(p3);\n    push(p4);\n    divide();\n    p5 = pop();\n\n    if (isNumericAtom(p5)) {\n      push(p1);\n\n      if (car(p3) === symbol(MULTIPLY) && isNumericAtom(cadr(p3))) {\n        p5 = cadr(p3);\n      } else {\n        p5 = one;\n      }\n\n      if (car(p4) === symbol(MULTIPLY) && isNumericAtom(cadr(p4))) {\n        p6 = cadr(p4);\n      } else {\n        p6 = one;\n      }\n\n      if (lessp(p5, p6)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n\n      power();\n      return;\n    }\n\n    push(p3);\n    push(p4);\n    subtract();\n    p5 = pop();\n\n    if (!isNumericAtom(p5)) {\n      push(one);\n      return;\n    }\n\n    push(p1);\n\n    if (isnegativenumber(p5)) {\n      push(p3);\n    } else {\n      push(p4);\n    }\n\n    return power();\n  };\n\n  gcd_sum_sum = function gcd_sum_sum() {\n    if (length(p1) !== length(p2)) {\n      push(one);\n      return;\n    }\n\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n\n    p3 = pop();\n    p4 = cdr(p2);\n    push(car(p4));\n    p4 = cdr(p4);\n\n    while (iscons(p4)) {\n      push(car(p4));\n      gcd();\n      p4 = cdr(p4);\n    }\n\n    p4 = pop();\n    push(p1);\n    push(p3);\n    divide();\n    p5 = pop();\n    push(p2);\n    push(p4);\n    divide();\n    p6 = pop();\n\n    if (equal(p5, p6)) {\n      push(p5);\n      push(p3);\n      push(p4);\n      gcd();\n      return multiply();\n    } else {\n      return push(one);\n    }\n  };\n\n  gcd_sum = function gcd_sum(p) {\n    var results;\n    p = cdr(p);\n    push(car(p));\n    p = cdr(p);\n    results = [];\n\n    while (iscons(p)) {\n      push(car(p));\n      gcd();\n      results.push(p = cdr(p));\n    }\n\n    return results;\n  };\n\n  gcd_sum_product = function gcd_sum_product() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n\n    while (iscons(p3)) {\n      push(car(p3));\n      push(p2);\n      gcd();\n      multiply();\n      results.push(p3 = cdr(p3));\n    }\n\n    return results;\n  };\n\n  gcd_product_sum = function gcd_product_sum() {\n    var results;\n    push(one);\n    p4 = cdr(p2);\n    results = [];\n\n    while (iscons(p4)) {\n      push(p1);\n      push(car(p4));\n      gcd();\n      multiply();\n      results.push(p4 = cdr(p4));\n    }\n\n    return results;\n  };\n\n  guess = function guess() {\n    var p;\n    p = pop();\n    push(p);\n\n    if (_Find(p, symbol(SYMBOL_X))) {\n      return push_symbol(SYMBOL_X);\n    } else if (_Find(p, symbol(SYMBOL_Y))) {\n      return push_symbol(SYMBOL_Y);\n    } else if (_Find(p, symbol(SYMBOL_Z))) {\n      return push_symbol(SYMBOL_Z);\n    } else if (_Find(p, symbol(SYMBOL_T))) {\n      return push_symbol(SYMBOL_T);\n    } else if (_Find(p, symbol(SYMBOL_S))) {\n      return push_symbol(SYMBOL_S);\n    } else {\n      return push_symbol(SYMBOL_X);\n    }\n  };\n\n  hermite = function hermite() {\n    save();\n    yyhermite();\n    return restore();\n  };\n\n  yyhermite = function yyhermite() {\n    var n;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push_symbol(HERMITE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    if (issymbol(p1)) {\n      return yyhermite2(n);\n    } else {\n      p3 = p1;\n      p1 = symbol(SECRETX);\n      yyhermite2(n);\n      p1 = p3;\n      push(symbol(SECRETX));\n      push(p1);\n\n      _subst();\n\n      return Eval();\n    }\n  };\n\n  yyhermite2 = function yyhermite2(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p4 = pop();\n    results = [];\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p5 = p4;\n      p4 = pop();\n      push(p1);\n      push(p4);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(2);\n      results.push(multiply());\n    }\n\n    return results;\n  };\n\n  hilbert = function hilbert() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p2 = pop();\n    push(p2);\n    n = pop_integer();\n\n    if (n < 2) {\n      push_symbol(HILBERT);\n      push(p2);\n      list(2);\n      restore();\n      return;\n    }\n\n    push_zero_matrix(n, n);\n    p1 = pop();\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        push_integer(i + j + 1);\n        inverse();\n        p1.tensor.elem[i * n + j] = pop();\n      }\n    }\n\n    push(p1);\n    return restore();\n  };\n  /*\n   Returns the coefficient of the imaginary part of complex z\n  \n    z    imag(z)\n    -    -------\n  \n    a + i b    b\n  \n    exp(i a)  sin(a)\n   */\n\n\n  DEBUG_IMAG = false;\n\n  Eval_imag = function Eval_imag() {\n    push(cadr(p1));\n    Eval();\n    return imag();\n  };\n\n  imag = function imag() {\n    save();\n\n    _rect();\n\n    p1 = pop();\n\n    if (DEBUG_IMAG) {\n      console.log(\"IMAGE of \" + p1);\n    }\n\n    push(p1);\n    push(p1);\n    conjugate();\n\n    if (DEBUG_IMAG) {\n      console.log(\" image: conjugate result: \" + stack[tos - 1]);\n    }\n\n    subtract();\n    push_integer(2);\n    divide();\n\n    if (DEBUG_IMAG) {\n      console.log(\" image: 1st divide result: \" + stack[tos - 1]);\n    }\n\n    push(imaginaryunit);\n    divide();\n\n    if (DEBUG_IMAG) {\n      console.log(\" image: 2nd divide result: \" + stack[tos - 1]);\n    }\n\n    return restore();\n  };\n\n  index_function = function index_function(n) {\n    var i, i1, j1, k, l1, m, m1, ndim, nelem, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    save();\n    s = tos - n;\n    p1 = stack[s];\n    ndim = p1.tensor.ndim;\n    m = n - 1;\n\n    if (m > ndim) {\n      stop(\"too many indices for tensor\");\n    }\n\n    k = 0;\n\n    for (i = o = 0, ref = m; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 1]);\n      t = pop_integer();\n\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"index out of range\");\n      }\n\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n\n    if (ndim === m) {\n      moveTos(tos - n);\n      push(p1.tensor.elem[k]);\n      restore();\n      return;\n    }\n\n    for (i = i1 = ref1 = m, ref2 = ndim; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n\n    nelem = 1;\n\n    for (i = j1 = ref3 = m, ref4 = ndim; ref3 <= ref4 ? j1 < ref4 : j1 > ref4; i = ref3 <= ref4 ? ++j1 : --j1) {\n      nelem *= p1.tensor.dim[i];\n    }\n\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim - m;\n\n    for (i = l1 = ref5 = m, ref6 = ndim; ref5 <= ref6 ? l1 < ref6 : l1 > ref6; i = ref5 <= ref6 ? ++l1 : --l1) {\n      p2.tensor.dim[i - m] = p1.tensor.dim[i];\n    }\n\n    for (i = m1 = 0, ref7 = nelem; 0 <= ref7 ? m1 < ref7 : m1 > ref7; i = 0 <= ref7 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[k + i];\n    }\n\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  set_component = function set_component(n) {\n    var i, i1, j1, k, l1, m, m1, n1, ndim, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    t = 0;\n    save();\n\n    if (n < 3) {\n      stop(\"error in indexed assign\");\n    }\n\n    s = tos - n;\n    p2 = stack[s];\n    p1 = stack[s + 1];\n\n    if (!istensor(p1)) {\n      stop(\"error in indexed assign: assigning to something that is not a tensor\");\n    }\n\n    ndim = p1.tensor.ndim;\n    m = n - 2;\n\n    if (m > ndim) {\n      stop(\"error in indexed assign\");\n    }\n\n    k = 0;\n\n    for (i = o = 0, ref = m; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 2]);\n      t = pop_integer();\n\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"error in indexed assign\\n\");\n      }\n\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n\n    for (i = i1 = ref1 = m, ref2 = ndim; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n\n    for (i = j1 = 0, ref3 = p1.tensor.ndim; 0 <= ref3 ? j1 < ref3 : j1 > ref3; i = 0 <= ref3 ? ++j1 : --j1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    for (i = l1 = 0, ref4 = p1.tensor.nelem; 0 <= ref4 ? l1 < ref4 : l1 > ref4; i = 0 <= ref4 ? ++l1 : --l1) {\n      p3.tensor.elem[i] = p1.tensor.elem[i];\n    }\n\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p3);\n    p1 = p3;\n\n    if (ndim === m) {\n      if (istensor(p2)) {\n        stop(\"error in indexed assign\");\n      }\n\n      p1.tensor.elem[k] = p2;\n      check_tensor_dimensions(p1);\n      moveTos(tos - n);\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (!istensor(p2)) {\n      stop(\"error in indexed assign\");\n    }\n\n    if (ndim - m !== p2.tensor.ndim) {\n      stop(\"error in indexed assign\");\n    }\n\n    for (i = m1 = 0, ref5 = p2.tensor.ndim; 0 <= ref5 ? m1 < ref5 : m1 > ref5; i = 0 <= ref5 ? ++m1 : --m1) {\n      if (p1.tensor.dim[m + i] !== p2.tensor.dim[i]) {\n        stop(\"error in indexed assign\");\n      }\n    }\n\n    for (i = n1 = 0, ref6 = p2.tensor.nelem; 0 <= ref6 ? n1 < ref6 : n1 > ref6; i = 0 <= ref6 ? ++n1 : --n1) {\n      p1.tensor.elem[k + i] = p2.tensor.elem[i];\n    }\n\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p1);\n    return restore();\n  };\n  /* dot =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  a,b,...\n  \n  General description\n  -------------------\n  \n  The inner (or dot) operator gives products of vectors,\n  matrices, and tensors.\n  \n  Note that for Algebrite, the elements of a vector/matrix\n  can only be scalars. This allows for example to flesh out\n  matrix multiplication using the usual multiplication.\n  So for example block-representations are not allowed.\n  \n  There is an aweful lot of confusion between sw packages on\n  what dot and inner do.\n  \n  First off, the \"dot\" operator is different from the\n  mathematical notion of dot product, which can be\n  slightly confusing.\n  \n  The mathematical notion of dot product is here:\n    http://mathworld.wolfram.com/DotProduct.html\n  \n  However, \"dot\" does that and a bunch of other things,\n  i.e. in Algebrite\n  dot/inner does what the dot of Mathematica does, i.e.:\n  \n  scalar product of vectors:\n  \n    inner((a, b, c), (x, y, z))\n    > a x + b y + c z\n  \n  products of matrices and vectors:\n  \n    inner(((a, b), (c,d)), (x, y))\n    > (a x + b y,c x + d y)\n  \n    inner((x, y), ((a, b), (c,d)))\n    > (a x + c y,b x + d y)\n  \n    inner((x, y), ((a, b), (c,d)), (r, s))\n    > a r x + b s x + c r y + d s y\n  \n  matrix product:\n  \n    inner(((a,b),(c,d)),((r,s),(t,u)))\n    > ((a r + b t,a s + b u),(c r + d t,c s + d u))\n  \n  the \"dot/inner\" operator is associative and\n  distributive but not commutative.\n  \n  In Mathematica, Inner is a generalisation of Dot where\n  the user can specify the multiplication and the addition\n  operators.\n  But here in Algebrite they do the same thing.\n  \n   https://reference.wolfram.com/language/ref/Dot.html\n   https://reference.wolfram.com/language/ref/Inner.html\n  \n   http://uk.mathworks.com/help/matlab/ref/dot.html\n   http://uk.mathworks.com/help/matlab/ref/mtimes.html\n   */\n\n\n  _Eval_inner = function Eval_inner() {\n    var difference, i, i1, j1, l1, moretheArguments, o, operands, ref, ref1, ref2, ref3, refinedOperands, results, secondArgument, shift, theArguments;\n    theArguments = [];\n    theArguments.push(car(cdr(p1)));\n    secondArgument = car(cdr(cdr(p1)));\n\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n\n    moretheArguments = cdr(cdr(p1));\n\n    while (moretheArguments !== symbol(NIL)) {\n      theArguments.push(car(moretheArguments));\n      moretheArguments = cdr(moretheArguments);\n    }\n\n    if (theArguments.length > 2) {\n      push_symbol(INNER);\n      push(theArguments[theArguments.length - 2]);\n      push(theArguments[theArguments.length - 1]);\n      list(3);\n\n      for (i = o = 2, ref = theArguments.length; 2 <= ref ? o < ref : o > ref; i = 2 <= ref ? ++o : --o) {\n        push_symbol(INNER);\n        swap();\n        push(theArguments[theArguments.length - i - 1]);\n        swap();\n        list(3);\n      }\n\n      p1 = pop();\n\n      _Eval_inner();\n\n      return;\n    }\n\n    operands = [];\n\n    _get_innerprod_factors(p1, operands);\n\n    refinedOperands = [];\n\n    for (i = i1 = 0, ref1 = operands.length; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      if (operands[i] === symbol(SYMBOL_IDENTITY_MATRIX)) {\n        continue;\n      } else {\n        refinedOperands.push(operands[i]);\n      }\n    }\n\n    operands = refinedOperands;\n    refinedOperands = [];\n\n    if (operands.length > 1) {\n      shift = 0;\n\n      for (i = j1 = 0, ref2 = operands.length; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n        if (i + shift + 1 <= operands.length - 1) {\n          if (!(_isNumericAtomOrTensor(operands[i + shift]) || _isNumericAtomOrTensor(operands[i + shift + 1]))) {\n            push(operands[i + shift]);\n            Eval();\n\n            _inv();\n\n            push(operands[i + shift + 1]);\n            Eval();\n            subtract();\n            difference = pop();\n\n            if (isZeroAtomOrTensor(difference)) {\n              shift += 1;\n            } else {\n              refinedOperands.push(operands[i + shift]);\n            }\n          } else {\n            refinedOperands.push(operands[i + shift]);\n          }\n        } else {\n          break;\n        }\n\n        if (i + shift === operands.length - 2) {\n          refinedOperands.push(operands[operands.length - 1]);\n        }\n\n        if (i + shift >= operands.length - 1) {\n          break;\n        }\n      }\n\n      operands = refinedOperands;\n    }\n\n    push(symbol(INNER));\n\n    if (operands.length > 0) {\n      for (i = l1 = 0, ref3 = operands.length; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n        push(operands[i]);\n      }\n    } else {\n      pop();\n      push(symbol(SYMBOL_IDENTITY_MATRIX));\n      return;\n    }\n\n    list(operands.length + 1);\n    p1 = pop();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n\n      _inner();\n\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  _inner = function inner() {\n    var arg1, arg2, arg3, subtractionResult;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isnegativeterm(p2) && isnegativeterm(p1)) {\n      push(p2);\n      negate();\n      p2 = pop();\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n\n    if (isinnerordot(p1)) {\n      arg1 = car(cdr(p1));\n      arg2 = car(cdr(cdr(p1)));\n      arg3 = p2;\n      p1 = arg1;\n      push(arg2);\n      push(arg3);\n\n      _inner();\n\n      p2 = pop();\n    }\n\n    if (p1 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p2);\n      restore();\n      return;\n    } else if (p2 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (istensor(p1) && istensor(p2)) {\n      inner_f();\n    } else {\n      if (!(_isNumericAtomOrTensor(p1) || _isNumericAtomOrTensor(p2))) {\n        push(p1);\n        push(p2);\n\n        _inv();\n\n        subtract();\n        subtractionResult = pop();\n\n        if (isZeroAtomOrTensor(subtractionResult)) {\n          push_symbol(SYMBOL_IDENTITY_MATRIX);\n          restore();\n          return;\n        }\n      }\n\n      if (expanding && isadd(p1)) {\n        p1 = cdr(p1);\n        push(zero);\n\n        while (iscons(p1)) {\n          push(car(p1));\n          push(p2);\n\n          _inner();\n\n          add();\n          p1 = cdr(p1);\n        }\n\n        restore();\n        return;\n      }\n\n      if (expanding && isadd(p2)) {\n        p2 = cdr(p2);\n        push(zero);\n\n        while (iscons(p2)) {\n          push(p1);\n          push(car(p2));\n\n          _inner();\n\n          add();\n          p2 = cdr(p2);\n        }\n\n        restore();\n        return;\n      }\n\n      push(p1);\n      push(p2);\n\n      if (istensor(p1) && isNumericAtom(p2)) {\n        tensor_times_scalar();\n      } else if (isNumericAtom(p1) && istensor(p2)) {\n        scalar_times_tensor();\n      } else {\n        if (isNumericAtom(p1) || isNumericAtom(p2)) {\n          multiply();\n        } else {\n          pop();\n          pop();\n          push_symbol(INNER);\n          push(p1);\n          push(p2);\n          list(3);\n          restore();\n          return;\n        }\n      }\n    }\n\n    return restore();\n  };\n\n  inner_f = function inner_f() {\n    var a, ak, b, bk, c, i, i1, j, j1, k, l1, m1, n, n1, ndim, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    n = p1.tensor.dim[p1.tensor.ndim - 1];\n\n    if (n !== p2.tensor.dim[0]) {\n      debugger;\n      stop(\"inner: tensor dimension check\");\n    }\n\n    ndim = p1.tensor.ndim + p2.tensor.ndim - 2;\n\n    if (ndim > MAXDIM) {\n      stop(\"inner: rank of result exceeds maximum\");\n    }\n\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    ak = 1;\n\n    for (i = o = 0, ref = p1.tensor.ndim - 1; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      ak *= p1.tensor.dim[i];\n    }\n\n    bk = 1;\n\n    for (i = i1 = 1, ref1 = p2.tensor.ndim; 1 <= ref1 ? i1 < ref1 : i1 > ref1; i = 1 <= ref1 ? ++i1 : --i1) {\n      bk *= p2.tensor.dim[i];\n    }\n\n    p3 = alloc_tensor(ak * bk);\n    c = p3.tensor.elem;\n\n    for (i = j1 = 0, ref2 = ak; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = 0, ref3 = n; 0 <= ref3 ? l1 < ref3 : l1 > ref3; j = 0 <= ref3 ? ++l1 : --l1) {\n        if (isZeroAtomOrTensor(a[i * n + j])) {\n          continue;\n        }\n\n        for (k = m1 = 0, ref4 = bk; 0 <= ref4 ? m1 < ref4 : m1 > ref4; k = 0 <= ref4 ? ++m1 : --m1) {\n          push(a[i * n + j]);\n          push(b[j * bk + k]);\n          multiply();\n          push(c[i * bk + k]);\n          add();\n          c[i * bk + k] = pop();\n        }\n      }\n    }\n\n    if (ndim === 0) {\n      return push(p3.tensor.elem[0]);\n    } else {\n      p3.tensor.ndim = ndim;\n      j = 0;\n\n      for (i = n1 = 0, ref5 = p1.tensor.ndim - 1; 0 <= ref5 ? n1 < ref5 : n1 > ref5; i = 0 <= ref5 ? ++n1 : --n1) {\n        p3.tensor.dim[i] = p1.tensor.dim[i];\n      }\n\n      j = p1.tensor.ndim - 1;\n\n      for (i = o1 = 0, ref6 = p2.tensor.ndim - 1; 0 <= ref6 ? o1 < ref6 : o1 > ref6; i = 0 <= ref6 ? ++o1 : --o1) {\n        p3.tensor.dim[j + i] = p2.tensor.dim[i + 1];\n      }\n\n      return push(p3);\n    }\n  };\n\n  _get_innerprod_factors = function get_innerprod_factors(tree, factors_accumulator) {\n    if (!iscons(tree)) {\n      add_factor_to_accumulator(tree, factors_accumulator);\n      return;\n    }\n\n    if (cdr(tree) === symbol(NIL)) {\n      tree = _get_innerprod_factors(car(tree), factors_accumulator);\n      return;\n    }\n\n    if (isinnerordot(tree)) {\n      _get_innerprod_factors(car(cdr(tree)), factors_accumulator);\n\n      _get_innerprod_factors(cdr(cdr(tree)), factors_accumulator);\n\n      return;\n    }\n\n    return add_factor_to_accumulator(tree, factors_accumulator);\n  };\n\n  add_factor_to_accumulator = function add_factor_to_accumulator(tree, factors_accumulator) {\n    if (tree !== symbol(NIL)) {\n      return factors_accumulator.push(tree);\n    }\n  };\n  /*\n   Table of integrals\n  \n  The symbol f is just a dummy symbol for creating a list f(A,B,C,C,...) where\n  \n    A  is the template expression\n  \n    B  is the result expression\n  \n    C  is an optional list of conditional expressions\n   */\n\n\n  itab = [\"f(a,a*x)\", \"f(1/x,log(x))\", \"f(x^a,x^(a+1)/(a+1))\", \"f(x^(-2),-x^(-1))\", \"f(x^(-1/2),2*x^(1/2))\", \"f(x^(1/2),2/3*x^(3/2))\", \"f(x,x^2/2)\", \"f(x^2,x^3/3)\", \"f(exp(a*x),1/a*exp(a*x))\", \"f(exp(a*x+b),1/a*exp(a*x+b))\", \"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\", \"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\", \"f(log(a*x),x*log(a*x)-x)\", \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\", \"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\", \"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\", \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\", \"f(1/(a+b*x),1/b*log(a+b*x))\", \"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\", \"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\", \"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\", \"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\", \"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\", \"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\", \"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\", \"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\", \"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\", \"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\", \"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\", \"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\", \"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\", \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\", \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\", \"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\", \"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\", \"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\", \"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\", \"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\", \"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\", \"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\", \"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\", \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\", \"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\", \"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\", \"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\", \"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\", \"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\", \"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\", \"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\", \"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\", \"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\", \"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\", \"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\", \"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\", \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\", \"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\", \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\", \"f(x/sqrt(x^2+a),sqrt(x^2+a))\", \"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\", \"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\", \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\", \"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\", \"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\", \"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\", \"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\", \"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\", \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\", \"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\", \"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\", \"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\", \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\", \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\", \"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\", \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\", \"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\", \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\", \"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\", \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\", \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\", \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\", \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\", \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\", \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\", \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\", \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\", \"f(sin(a*x),-cos(a*x)/a)\", \"f(cos(a*x),sin(a*x)/a)\", \"f(tan(a*x),-log(cos(a*x))/a)\", \"f(1/tan(a*x),log(sin(a*x))/a)\", \"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\", \"f(1/sin(a*x),log(tan(a*x/2))/a)\", \"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\", \"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\", \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\", \"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\", \"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\", \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\", \"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\", \"f(1/cos(a*x)^2,tan(a*x)/a)\", \"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\", \"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\", \"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\", \"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\", \"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\", \"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\", \"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\", \"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\", \"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\", \"f(sin(a+b*x),-cos(a+b*x)/b)\", \"f(cos(a+b*x),sin(a+b*x)/b)\", \"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\", \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\", \"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\", \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\", \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\", \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\", \"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\", \"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\", \"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\", \"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\", \"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\", \"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\", \"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\", \"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\", \"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\", \"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\", \"f(1/x*1/(a+log(x)),log(a+log(x)))\", \"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\", \"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\", \"f(sinh(x),cosh(x))\", \"f(cosh(x),sinh(x))\", \"f(tanh(x),log(cosh(x)))\", \"f(x*sinh(x),x*cosh(x)-sinh(x))\", \"f(x*cosh(x),x*sinh(x)-cosh(x))\", \"f(sinh(x)^2,sinh(2*x)/4-x/2)\", \"f(tanh(x)^2,x-tanh(x))\", \"f(cosh(x)^2,sinh(2*x)/4+x/2)\", \"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\", \"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\", \"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\", \"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\", \"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\", \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\", \"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\", \"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\", \"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\", \"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\", \"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\", \"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\", \"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\", 0];\n\n  Eval_integral = function Eval_integral() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n\n    while (1) {\n      if (isNumericAtom(p5)) {\n        push(p5);\n        n = pop_integer();\n\n        if (isNaN(n)) {\n          stop(\"nth integral: check n\");\n        }\n      } else {\n        n = 1;\n      }\n\n      push(p3);\n\n      if (n >= 0) {\n        for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          integral();\n        }\n      } else {\n        n = -n;\n\n        for (i = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          derivative();\n        }\n      }\n\n      p3 = pop();\n\n      if (p5 === symbol(NIL)) {\n        break;\n      }\n\n      if (isNumericAtom(p5)) {\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n\n        if (p5 === symbol(NIL)) {\n          break;\n        }\n\n        if (isNumericAtom(p5)) {\n          doNothing = 1;\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop();\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n      }\n    }\n\n    return push(p3);\n  };\n\n  integral = function integral() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (car(p1) === symbol(ADD)) {\n      integral_of_sum();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      integral_of_product();\n    } else {\n      integral_of_form();\n    }\n\n    p1 = pop();\n\n    if (_Find(p1, symbol(INTEGRAL))) {\n      stop(\"integral: sorry, could not find a solution\");\n    }\n\n    push(p1);\n    simplify();\n    Eval();\n    return restore();\n  };\n\n  integral_of_sum = function integral_of_sum() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    push(p2);\n    integral();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      integral();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  integral_of_product = function integral_of_product() {\n    push(p1);\n    push(p2);\n    partition();\n    p1 = pop();\n    integral_of_form();\n    return multiply();\n  };\n\n  integral_of_form = function integral_of_form() {\n    var hc, tab;\n    hc = italu_hashcode(p1, p2).toFixed(6);\n    tab = hashed_itab[hc];\n\n    if (!tab) {\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    push(p1);\n    push(p2);\n\n    _transform(tab, false);\n\n    p3 = pop();\n\n    if (p3 === symbol(NIL)) {\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(p3);\n    }\n  };\n\n  hashcode_values = {\n    'x': 0.95532,\n    'constexp': 1.43762,\n    'constant': 1.14416593629414332,\n    'constbase': 1.20364122304218824,\n    'sin': 1.73305482518303221,\n    'arcsin': 1.6483368529465804,\n    'cos': 1.058672123686340116,\n    'arccos': 1.8405225918106694,\n    'tan': 1.12249437762925064,\n    'arctan': 1.1297397925394962,\n    'sinh': 1.8176164926060078,\n    'cosh': 1.9404934661708022,\n    'tanh': 1.6421307715103121,\n    'log': 1.47744370135492387,\n    'erf': 1.0825269225702916\n  };\n\n  italu_hashcode = function italu_hashcode(u, x) {\n    var half;\n\n    if (issymbol(u)) {\n      if (equal(u, x)) {\n        return hashcode_values.x;\n      } else {\n        return hashcode_values.constant;\n      }\n    } else if (iscons(u)) {\n      switch (symnum(car(u))) {\n        case ADD:\n          return hash_addition(cdr(u), x);\n\n        case MULTIPLY:\n          return hash_multiplication(cdr(u), x);\n\n        case POWER:\n          return hash_power(cadr(u), caddr(u), x);\n\n        case EXP:\n          return hash_power(symbol(E), cadr(u), x);\n\n        case SQRT:\n          push_double(0.5);\n          half = pop();\n          return hash_power(cadr(u), half, x);\n\n        default:\n          return hash_function(u, x);\n      }\n    }\n\n    return hashcode_values.constant;\n  };\n\n  hash_function = function hash_function(u, x) {\n    var arg_hash, base, name;\n\n    if (!_Find(cadr(u), x)) {\n      return hashcode_values.constant;\n    }\n\n    name = car(u);\n    arg_hash = italu_hashcode(cadr(u), x);\n    base = hashcode_values[name.printname];\n\n    if (!base) {\n      throw new Error('Unsupported function ' + name.printname);\n    }\n\n    return Math.pow(base, arg_hash);\n  };\n\n  hash_addition = function hash_addition(terms, x) {\n    var k, sum, term, term_hash, term_set, v;\n    term_set = {};\n\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n      term_hash = 0;\n\n      if (_Find(term, x)) {\n        term_hash = italu_hashcode(term, x);\n      } else {\n        term_hash = hashcode_values.constant;\n      }\n\n      term_set[term_hash.toFixed(6)] = true;\n    }\n\n    sum = 0;\n\n    for (k in term_set) {\n      if (!hasProp.call(term_set, k)) continue;\n      v = term_set[k];\n      sum = sum + parseFloat(k, 10);\n    }\n\n    return sum;\n  };\n\n  hash_multiplication = function hash_multiplication(terms, x) {\n    var product, term;\n    product = 1;\n\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n\n      if (_Find(term, x)) {\n        product = product * italu_hashcode(term, x);\n      }\n    }\n\n    return product;\n  };\n\n  hash_power = function hash_power(base, power, x) {\n    var base_hash, exp_hash;\n    base_hash = hashcode_values.constant;\n    exp_hash = hashcode_values.constexp;\n\n    if (_Find(base, x)) {\n      base_hash = italu_hashcode(base, x);\n    }\n\n    if (_Find(power, x)) {\n      exp_hash = italu_hashcode(power, x);\n    } else {\n      if (base_hash === hashcode_values.constant) {\n        return hashcode_values.constant;\n      }\n\n      if (isminusone(power)) {\n        exp_hash = -1;\n      } else if (isoneovertwo(power)) {\n        exp_hash = 0.5;\n      } else if (isminusoneovertwo(power)) {\n        exp_hash = -0.5;\n      } else if (equalq(power, 2, 1)) {\n        exp_hash = 2;\n      } else if (equalq(power, -2, 1)) {\n        exp_hash = -2;\n      }\n    }\n\n    return Math.pow(base_hash, exp_hash);\n  };\n\n  make_hashed_itab = function make_hashed_itab() {\n    var f, h, key, len, o, s, tab, u;\n    tab = {};\n\n    for (o = 0, len = itab.length; o < len; o++) {\n      s = itab[o];\n\n      if (!s) {\n        break;\n      }\n\n      scan_meta(s);\n      f = pop();\n      u = cadr(f);\n      h = italu_hashcode(u, symbol(METAX));\n      key = h.toFixed(6);\n\n      if (!tab[key]) {\n        tab[key] = [];\n      }\n\n      tab[key].push(s);\n    }\n\n    console.log('hashed_itab = ' + JSON.stringify(tab, null, 2));\n    return tab;\n  };\n\n  $.make_hashed_itab = make_hashed_itab;\n  hashed_itab = {\n    \"1.144166\": [\"f(a,a*x)\"],\n    \"1.046770\": [\"f(1/x,log(x))\"],\n    \"0.936400\": [\"f(x^a,x^(a+1)/(a+1))\"],\n    \"1.095727\": [\"f(x^(-2),-x^(-1))\"],\n    \"1.023118\": [\"f(x^(-1/2),2*x^(1/2))\"],\n    \"0.977405\": [\"f(x^(1/2),2/3*x^(3/2))\"],\n    \"0.955320\": [\"f(x,x^2/2)\"],\n    \"0.912636\": [\"f(x^2,x^3/3)\"],\n    \"1.137302\": [\"f(exp(a*x),1/a*exp(a*x))\", \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\"],\n    \"1.326774\": [\"f(exp(a*x+b),1/a*exp(a*x+b))\"],\n    \"1.080259\": [\"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\"],\n    \"1.260228\": [\"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\"],\n    \"1.451902\": [\"f(log(a*x),x*log(a*x)-x)\"],\n    \"0.486192\": [\"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\", \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\", \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.697274\": [\"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\", \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\", \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\"],\n    \"0.476307\": [\"f(1/(a+b*x),1/b*log(a+b*x))\"],\n    \"0.226868\": [\"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\"],\n    \"2.904531\": [\"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\"],\n    \"0.455026\": [\"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\"],\n    \"0.216732\": [\"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\"],\n    \"0.434695\": [\"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\"],\n    \"0.207048\": [\"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\"],\n    \"2.650781\": [\"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\"],\n    \"0.498584\": [\"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\"],\n    \"0.237479\": [\"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\"],\n    \"3.040375\": [\"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\"],\n    \"0.521902\": [\"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\"],\n    \"0.446014\": [\"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\"],\n    \"0.248586\": [\"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\"],\n    \"0.464469\": [\"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\"],\n    \"0.443716\": [\"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\"],\n    \"0.236382\": [\"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\"],\n    \"0.508931\": [\"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\"],\n    \"0.532733\": [\"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\"],\n    \"0.480638\": [\"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\"],\n    \"0.438648\": [\"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\"],\n    \"0.459164\": [\"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\", \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.450070\": [\"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\"],\n    \"1.448960\": [\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\"],\n    \"1.384221\": [\"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\"],\n    \"1.322374\": [\"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\"],\n    \"1.516728\": [\"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.587665\": [\"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"0.690150\": [\"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\"],\n    \"0.659314\": [\"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\"],\n    \"0.629856\": [\"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\"],\n    \"0.722428\": [\"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\"],\n    \"0.756216\": [\"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.434156\": [\"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\", \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\"],\n    \"0.729886\": [\"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\", \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"1.501230\": [\"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\", \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"0.666120\": [\"f(x/sqrt(x^2+a),sqrt(x^2+a))\", \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\"],\n    \"1.370077\": [\"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\", \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\"],\n    \"1.730087\": [\"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\", \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\"],\n    \"0.578006\": [\"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\"],\n    \"0.552180\": [\"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\"],\n    \"1.652787\": [\"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\"],\n    \"1.308862\": [\"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\", \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\"],\n    \"1.342944\": [\"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\", \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\", \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\"],\n    \"0.636358\": [\"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\", \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"0.652928\": [\"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\", \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\", \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\"],\n    \"0.764022\": [\"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\", \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\"],\n    \"1.578940\": [\"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\", \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\"],\n    \"1.620055\": [\"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\", \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\"],\n    \"0.332117\": [\"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\", \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\"],\n    \"1.571443\": [\"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"1.690994\": [\"f(sin(a*x),-cos(a*x)/a)\"],\n    \"1.055979\": [\"f(cos(a*x),sin(a*x)/a)\"],\n    \"1.116714\": [\"f(tan(a*x),-log(cos(a*x))/a)\"],\n    \"0.895484\": [\"f(1/tan(a*x),log(sin(a*x))/a)\"],\n    \"0.946989\": [\"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\"],\n    \"0.591368\": [\"f(1/sin(a*x),log(tan(a*x/2))/a)\"],\n    \"2.859462\": [\"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\"],\n    \"2.128050\": [\"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\", \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"1.115091\": [\"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\"],\n    \"1.081452\": [\"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\", \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"0.349716\": [\"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\"],\n    \"0.896788\": [\"f(1/cos(a*x)^2,tan(a*x)/a)\"],\n    \"1.785654\": [\"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\"],\n    \"3.188560\": [\"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\"],\n    \"1.516463\": [\"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\"],\n    \"2.707879\": [\"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\"],\n    \"0.369293\": [\"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\"],\n    \"0.560019\": [\"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\"],\n    \"0.530332\": [\"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\"],\n    \"0.331177\": [\"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\"],\n    \"0.313621\": [\"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\"],\n    \"3.172365\": [\"f(sin(a+b*x),-cos(a+b*x)/b)\"],\n    \"1.127162\": [\"f(cos(a+b*x),sin(a+b*x)/b)\"],\n    \"0.352714\": [\"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\", \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\", \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\"],\n    \"0.454515\": [\"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\", \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\", \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\"],\n    \"1.615441\": [\"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\"],\n    \"1.543263\": [\"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\"],\n    \"1.008798\": [\"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\"],\n    \"0.963724\": [\"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\"],\n    \"1.611938\": [\"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\"],\n    \"1.791033\": [\"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\"],\n    \"1.123599\": [\"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\"],\n    \"1.387031\": [\"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\"],\n    \"1.325058\": [\"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\"],\n    \"2.108018\": [\"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\"],\n    \"0.403214\": [\"f(1/x*1/(a+log(x)),log(a+log(x)))\"],\n    \"2.269268\": [\"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\"],\n    \"2.486498\": [\"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\"],\n    \"1.769733\": [\"f(sinh(x),cosh(x))\"],\n    \"1.883858\": [\"f(cosh(x),sinh(x))\"],\n    \"1.606140\": [\"f(tanh(x),log(cosh(x)))\"],\n    \"1.690661\": [\"f(x*sinh(x),x*cosh(x)-sinh(x))\"],\n    \"1.799688\": [\"f(x*cosh(x),x*sinh(x)-cosh(x))\"],\n    \"3.131954\": [\"f(sinh(x)^2,sinh(2*x)/4-x/2)\"],\n    \"2.579685\": [\"f(tanh(x)^2,x-tanh(x))\"],\n    \"3.548923\": [\"f(cosh(x)^2,sinh(2*x)/4+x/2)\"],\n    \"1.058866\": [\"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\"],\n    \"1.235270\": [\"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\"],\n    \"1.130783\": [\"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\"],\n    \"1.078698\": [\"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\"],\n    \"2.573650\": [\"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\", \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\"],\n    \"2.640666\": [\"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\"],\n    \"1.086487\": [\"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\"],\n    \"1.267493\": [\"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\"],\n    \"1.037943\": [\"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.210862\": [\"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.064970\": [\"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\"],\n    \"1.242392\": [\"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\"]\n  };\n\n  INV_check_arg = function INV_check_arg() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  _inv = function inv() {\n    var accumulator, eachEntry, i, n, o, ref;\n    i = 0;\n    n = 0;\n    save();\n    p1 = pop();\n\n    if (isinv(p1)) {\n      push(car(cdr(p1)));\n      restore();\n      return;\n    }\n\n    if (isidentitymatrix(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n\n      while (iscons(p1)) {\n        accumulator.push(car(p1));\n        p1 = cdr(p1);\n      }\n\n      for (eachEntry = o = ref = accumulator.length - 1; ref <= 0 ? o <= 0 : o >= 0; eachEntry = ref <= 0 ? ++o : --o) {\n        push(accumulator[eachEntry]);\n\n        _inv();\n\n        if (eachEntry !== accumulator.length - 1) {\n          _inner();\n        }\n      }\n\n      restore();\n      return;\n    }\n\n    if (INV_check_arg() === 0) {\n      push_symbol(INV);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    if (_isNumericAtomOrTensor(p1)) {\n      yyinvg();\n    } else {\n      push(p1);\n      adj();\n      push(p1);\n      det();\n      p2 = pop();\n\n      if (isZeroAtomOrTensor(p2)) {\n        stop(\"inverse of singular matrix\");\n      }\n\n      push(p2);\n      divide();\n    }\n\n    return restore();\n  };\n\n  invg = function invg() {\n    save();\n    p1 = pop();\n\n    if (INV_check_arg() === 0) {\n      push_symbol(INVG);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    yyinvg();\n    return restore();\n  };\n\n  yyinvg = function yyinvg() {\n    var h, i, i1, j, j1, l1, n, o, ref, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n    h = tos;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i === j) {\n          push(one);\n        } else {\n          push(zero);\n        }\n      }\n    }\n\n    for (i = j1 = 0, ref2 = n * n; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      push(p1.tensor.elem[i]);\n    }\n\n    INV_decomp(n);\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n\n    for (i = l1 = 0, ref3 = n * n; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n\n    moveTos(tos - 2 * n * n);\n    return push(p1);\n  };\n\n  INV_decomp = function INV_decomp(n) {\n    var a, d, i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4, results, u;\n    a = 0;\n    d = 0;\n    i = 0;\n    j = 0;\n    u = 0;\n    a = tos - n * n;\n    u = a - n * n;\n    results = [];\n\n    for (d = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; d = 0 <= ref ? ++o : --o) {\n      if (equal(stack[a + n * d + d], zero)) {\n        for (i = i1 = ref1 = d + 1, ref2 = n; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(stack[a + n * i + d], zero)) {\n            break;\n          }\n        }\n\n        if (i === n) {\n          stop(\"inverse of singular matrix\");\n        }\n\n        for (j = j1 = 0, ref3 = n; 0 <= ref3 ? j1 < ref3 : j1 > ref3; j = 0 <= ref3 ? ++j1 : --j1) {\n          p2 = stack[a + n * d + j];\n          stack[a + n * d + j] = stack[a + n * i + j];\n          stack[a + n * i + j] = p2;\n          p2 = stack[u + n * d + j];\n          stack[u + n * d + j] = stack[u + n * i + j];\n          stack[u + n * i + j] = p2;\n        }\n      }\n\n      p2 = stack[a + n * d + d];\n\n      for (j = l1 = 0, ref4 = n; 0 <= ref4 ? l1 < ref4 : l1 > ref4; j = 0 <= ref4 ? ++l1 : --l1) {\n        if (j > d) {\n          push(stack[a + n * d + j]);\n          push(p2);\n          divide();\n          stack[a + n * d + j] = pop();\n        }\n\n        push(stack[u + n * d + j]);\n        push(p2);\n        divide();\n        stack[u + n * d + j] = pop();\n      }\n\n      results.push(function () {\n        var m1, ref5, results1;\n        results1 = [];\n\n        for (i = m1 = 0, ref5 = n; 0 <= ref5 ? m1 < ref5 : m1 > ref5; i = 0 <= ref5 ? ++m1 : --m1) {\n          if (i === d) {\n            continue;\n          }\n\n          p2 = stack[a + n * i + d];\n          results1.push(function () {\n            var n1, ref6, results2;\n            results2 = [];\n\n            for (j = n1 = 0, ref6 = n; 0 <= ref6 ? n1 < ref6 : n1 > ref6; j = 0 <= ref6 ? ++n1 : --n1) {\n              if (j > d) {\n                push(stack[a + n * i + j]);\n                push(stack[a + n * d + j]);\n                push(p2);\n                multiply();\n                subtract();\n                stack[a + n * i + j] = pop();\n              }\n\n              push(stack[u + n * i + j]);\n              push(stack[u + n * d + j]);\n              push(p2);\n              multiply();\n              subtract();\n              results2.push(stack[u + n * i + j] = pop());\n            }\n\n            return results2;\n          }());\n        }\n\n        return results1;\n      }());\n    }\n\n    return results;\n  };\n\n  DEBUG_IS = false;\n\n  isZeroAtom = function isZeroAtom(p) {\n    switch (p.k) {\n      case NUM:\n        if (MZERO(p.q.a)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === 0.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isZeroTensor = function isZeroTensor(p) {\n    var i, o, ref;\n\n    if (p.k !== TENSOR) {\n      return 0;\n    }\n\n    for (i = o = 0, ref = p.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (!isZeroAtomOrTensor(p.tensor.elem[i])) {\n        return 0;\n      }\n    }\n\n    return 1;\n  };\n\n  isZeroAtomOrTensor = function isZeroAtomOrTensor(p) {\n    return isZeroAtom(p) || isZeroTensor(p);\n  };\n\n  isZeroLikeOrNonZeroLikeOrUndetermined = function isZeroLikeOrNonZeroLikeOrUndetermined(valueOrPredicate) {\n    var evalledArgument;\n    push(valueOrPredicate);\n    Eval_predicate();\n    evalledArgument = pop();\n\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n\n    if (_isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n\n    push(evalledArgument);\n    zzfloat();\n    evalledArgument = pop();\n\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n\n    if (_isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n\n    if (_Find(evalledArgument, imaginaryunit)) {\n      push(evalledArgument);\n      absValFloat();\n      Eval_predicate();\n      evalledArgument = pop();\n\n      if (isZeroAtomOrTensor(evalledArgument)) {\n        return 0;\n      }\n\n      if (_isNumericAtomOrTensor(evalledArgument)) {\n        return 1;\n      }\n    }\n\n    return null;\n  };\n\n  isnegativenumber = function isnegativenumber(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === -1) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d < 0.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  ispositivenumber = function ispositivenumber(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === 1) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d > 0.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isplustwo = function isplustwo(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 2) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === 2.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isplusone = function isplusone(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === 1.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isminusone = function isminusone(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === -1.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isone = function isone(p) {\n    return isplusone(p) || isminusone(p);\n  };\n\n  isinteger = function isinteger(p) {\n    if (p.k === NUM && MEQUAL(p.q.b, 1)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isintegerorintegerfloat = function isintegerorintegerfloat(p) {\n    if (p.k === DOUBLE) {\n      if (p.d === Math.round(p.d)) {\n        return 1;\n      }\n\n      return 0;\n    }\n\n    return isinteger(p);\n  };\n\n  isnonnegativeinteger = function isnonnegativeinteger(p) {\n    if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isposint = function isposint(p) {\n    if (isinteger(p) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isunivarpolyfactoredorexpandedform = function isunivarpolyfactoredorexpandedform(p, x) {\n    if (x == null) {\n      push(p);\n      guess();\n      x = pop();\n      pop();\n    }\n\n    if (ispolyfactoredorexpandedform(p, x) && _Find(p, symbol(SYMBOL_X)) + _Find(p, symbol(SYMBOL_Y)) + _Find(p, symbol(SYMBOL_Z)) === 1) {\n      return x;\n    } else {\n      return 0;\n    }\n  };\n\n  ispolyfactoredorexpandedform = function ispolyfactoredorexpandedform(p, x) {\n    return ispolyfactoredorexpandedform_factor(p, x);\n  };\n\n  ispolyfactoredorexpandedform_factor = function ispolyfactoredorexpandedform_factor(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (DEBUG) {\n          console.log(\"ispolyfactoredorexpandedform_factor testing \" + car(p));\n        }\n\n        if (!ispolyfactoredorexpandedform_power(car(p), x)) {\n          if (DEBUG) {\n            console.log(\"... tested negative:\" + car(p));\n          }\n\n          return 0;\n        }\n\n        p = cdr(p);\n      }\n\n      return 1;\n    } else {\n      return ispolyfactoredorexpandedform_power(p, x);\n    }\n  };\n\n  ispolyfactoredorexpandedform_power = function ispolyfactoredorexpandedform_power(p, x) {\n    if (car(p) === symbol(POWER)) {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power (isposint(caddr(p)) \" + (isposint(caddr(p)), DEBUG ? console.log(\"ispolyfactoredorexpandedform_power ispolyexpandedform_expr(cadr(p), x)) \" + ispolyexpandedform_expr(cadr(p), x)) : void 0));\n      }\n\n      return isposint(caddr(p)) && ispolyexpandedform_expr(cadr(p), x);\n    } else {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power not a power, testing if this is exp form: \" + p);\n      }\n\n      return ispolyexpandedform_expr(p, x);\n    }\n  };\n\n  ispolyexpandedform = function ispolyexpandedform(p, x) {\n    if (_Find(p, x)) {\n      return ispolyexpandedform_expr(p, x);\n    } else {\n      return 0;\n    }\n  };\n\n  ispolyexpandedform_expr = function ispolyexpandedform_expr(p, x) {\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (!ispolyexpandedform_term(car(p), x)) {\n          return 0;\n        }\n\n        p = cdr(p);\n      }\n\n      return 1;\n    } else {\n      return ispolyexpandedform_term(p, x);\n    }\n  };\n\n  ispolyexpandedform_term = function ispolyexpandedform_term(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (!ispolyexpandedform_factor(car(p), x)) {\n          return 0;\n        }\n\n        p = cdr(p);\n      }\n\n      return 1;\n    } else {\n      return ispolyexpandedform_factor(p, x);\n    }\n  };\n\n  ispolyexpandedform_factor = function ispolyexpandedform_factor(p, x) {\n    if (equal(p, x)) {\n      return 1;\n    }\n\n    if (car(p) === symbol(POWER) && equal(cadr(p), x)) {\n      if (isposint(caddr(p))) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n\n    if (_Find(p, x)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  isnegativeterm = function isnegativeterm(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  hasNegativeRationalExponent = function hasNegativeRationalExponent(p) {\n    if (car(p) === symbol(POWER) && isrational(car(cdr(cdr(p)))) && isnegativenumber(car(cdr(p)))) {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has imaginary component\");\n      }\n\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has NO imaginary component\");\n      }\n\n      return 0;\n    }\n  };\n\n  isimaginarynumberdouble = function isimaginarynumberdouble(p) {\n    if (car(p) === symbol(MULTIPLY) && length(p) === 3 && isdouble(cadr(p)) && hasNegativeRationalExponent(caddr(p)) || equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isimaginarynumber = function isimaginarynumber(p) {\n    if (car(p) === symbol(MULTIPLY) && length(p) === 3 && isNumericAtom(cadr(p)) && equal(caddr(p), imaginaryunit) || equal(p, imaginaryunit) || hasNegativeRationalExponent(caddr(p))) {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" is imaginary number\");\n      }\n\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" isn't an imaginary number\");\n      }\n\n      return 0;\n    }\n  };\n\n  iscomplexnumberdouble = function iscomplexnumberdouble(p) {\n    if (car(p) === symbol(ADD) && length(p) === 3 && isdouble(cadr(p)) && isimaginarynumberdouble(caddr(p)) || isimaginarynumberdouble(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  iscomplexnumber = function iscomplexnumber(p) {\n    if (DEBUG_IS) {\n      debugger;\n    }\n\n    if (car(p) === symbol(ADD) && length(p) === 3 && isNumericAtom(cadr(p)) && isimaginarynumber(caddr(p)) || isimaginarynumber(p)) {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n\n      return 1;\n    } else {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n\n      return 0;\n    }\n  };\n\n  iseveninteger = function iseveninteger(p) {\n    if (isinteger(p) && p.q.a.isEven()) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isnegative = function isnegative(p) {\n    if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {\n      return 1;\n    } else if (isnegativeterm(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  _issymbolic = function issymbolic(p) {\n    if (issymbol(p)) {\n      return 1;\n    } else {\n      while (iscons(p)) {\n        if (_issymbolic(car(p))) {\n          return 1;\n        }\n\n        p = cdr(p);\n      }\n\n      return 0;\n    }\n  };\n\n  isintegerfactor = function isintegerfactor(p) {\n    if (isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isNumberOneOverSomething = function isNumberOneOverSomething(p) {\n    if (isfraction(p) && MEQUAL(p.q.a.abs(), 1)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isoneover = function isoneover(p) {\n    if (car(p) === symbol(POWER) && isminusone(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isfraction = function isfraction(p) {\n    if (p.k === NUM && !MEQUAL(p.q.b, 1)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  equaln = function equaln(p, n) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === n) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  equalq = function equalq(p, a, b) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === a / b) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isoneovertwo = function isoneovertwo(p) {\n    if (equalq(p, 1, 2)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isminusoneovertwo = function isminusoneovertwo(p) {\n    if (equalq(p, -1, 2)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isoneoversqrttwo = function isoneoversqrttwo(p) {\n    if (car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isminusoneoversqrttwo = function isminusoneoversqrttwo(p) {\n    if (car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  _isfloating = function isfloating(p) {\n    if (p.k === DOUBLE || p === symbol(FLOATF)) {\n      return 1;\n    }\n\n    while (iscons(p)) {\n      if (_isfloating(car(p))) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n\n  isimaginaryunit = function isimaginaryunit(p) {\n    if (equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isquarterturn = function isquarterturn(p) {\n    var minussign, n;\n    n = 0;\n    minussign = 0;\n\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n\n    if (equal(cadr(p), imaginaryunit)) {\n      if (caddr(p) !== symbol(PI)) {\n        return 0;\n      }\n\n      if (length(p) !== 3) {\n        return 0;\n      }\n\n      return 2;\n    }\n\n    if (!isNumericAtom(cadr(p))) {\n      return 0;\n    }\n\n    if (!equal(caddr(p), imaginaryunit)) {\n      return 0;\n    }\n\n    if (cadddr(p) !== symbol(PI)) {\n      return 0;\n    }\n\n    if (length(p) !== 4) {\n      return 0;\n    }\n\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n\n    if (isNaN(n)) {\n      return 0;\n    }\n\n    if (n < 1) {\n      minussign = 1;\n      n = -n;\n    }\n\n    switch (n % 4) {\n      case 0:\n        n = 1;\n        break;\n\n      case 1:\n        if (minussign) {\n          n = 4;\n        } else {\n          n = 3;\n        }\n\n        break;\n\n      case 2:\n        n = 2;\n        break;\n\n      case 3:\n        if (minussign) {\n          n = 3;\n        } else {\n          n = 4;\n        }\n\n    }\n\n    return n;\n  };\n\n  isnpi = function isnpi(p) {\n    var doNothing, n;\n    n = 0;\n\n    if (p === symbol(PI)) {\n      return 2;\n    }\n\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {\n      doNothing = 0;\n    } else {\n      return 0;\n    }\n\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n\n    if (isNaN(n)) {\n      return 0;\n    }\n\n    if (n < 0) {\n      n = 4 - -n % 4;\n    } else {\n      n = 1 + (n - 1) % 4;\n    }\n\n    return n;\n  };\n\n  $.isZeroAtomOrTensor = isZeroAtomOrTensor;\n  $.isnegativenumber = isnegativenumber;\n  $.isplusone = isplusone;\n  $.isminusone = isminusone;\n  $.isinteger = isinteger;\n  $.isnonnegativeinteger = isnonnegativeinteger;\n  $.isposint = isposint;\n  $.isnegativeterm = isnegativeterm;\n  $.isimaginarynumber = isimaginarynumber;\n  $.iscomplexnumber = iscomplexnumber;\n  $.iseveninteger = iseveninteger;\n  $.isnegative = isnegative;\n  $.issymbolic = _issymbolic;\n  $.isintegerfactor = isintegerfactor;\n  $.isoneover = isoneover;\n  $.isfraction = isfraction;\n  $.isoneoversqrttwo = isoneoversqrttwo;\n  $.isminusoneoversqrttwo = isminusoneoversqrttwo;\n  $.isfloating = _isfloating;\n  $.isimaginaryunit = isimaginaryunit;\n  $.isquarterturn = isquarterturn;\n  $.isnpi = isnpi;\n\n  Eval_isprime = function Eval_isprime() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n\n    if (isnonnegativeinteger(p1) && mprime(p1.q.a)) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n  /*\n   Laguerre function\n  \n  Example\n  \n    laguerre(x,3)\n  \n  Result\n  \n       1   3    3   2\n    - --- x  + --- x  - 3 x + 1\n       6        2\n  \n  The computation uses the following recurrence relation.\n  \n    L(x,0,k) = 1\n  \n    L(x,1,k) = -x + k + 1\n  \n    n*L(x,n,k) = (2*(n-1)+1-x+k)*L(x,n-1,k) - (n-1+k)*L(x,n-2,k)\n  \n  In the \"for\" loop i = n-1 so the recurrence relation becomes\n  \n    (i+1)*L(x,n,k) = (2*i+1-x+k)*L(x,n-1,k) - (i+k)*L(x,n-2,k)\n   */\n\n\n  Eval_laguerre = function Eval_laguerre() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n\n    return laguerre();\n  };\n\n  laguerre = function laguerre() {\n    var n;\n    n = 0;\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push_symbol(LAGUERRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      restore();\n      return;\n    }\n\n    if (issymbol(p1)) {\n      laguerre2(n);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n      laguerre2(n);\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n\n      _subst();\n\n      Eval();\n    }\n\n    return restore();\n  };\n\n  laguerre2 = function laguerre2(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n    results = [];\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      subtract();\n      push(p3);\n      add();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p3);\n      add();\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      results.push(divide());\n    }\n\n    return results;\n  };\n\n  Eval_lcm = function Eval_lcm() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      lcm();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  lcm = function lcm() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    yylcm();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yylcm = function yylcm() {\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    gcd();\n    push(p1);\n    divide();\n    push(p2);\n    divide();\n    return inverse();\n  };\n  /*\n   Return the leading coefficient of a polynomial.\n  \n  Example\n  \n    leading(5x^2+x+1,x)\n  \n  Result\n  \n    5\n  \n  The result is undefined if P is not a polynomial.\n   */\n\n\n  Eval_leading = function Eval_leading() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n\n    return leading();\n  };\n\n  leading = function leading() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    degree();\n    p3 = pop();\n    push(p1);\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2);\n    filter();\n    return restore();\n  };\n  /*\n   Legendre function\n  \n  Example\n  \n    legendre(x,3,0)\n  \n  Result\n  \n     5   3    3\n    --- x  - --- x\n     2        2\n  \n  The computation uses the following recurrence relation.\n  \n    P(x,0) = 1\n  \n    P(x,1) = x\n  \n    n*P(x,n) = (2*(n-1)+1)*x*P(x,n-1) - (n-1)*P(x,n-2)\n  \n  In the \"for\" loop we have i = n-1 so the recurrence relation becomes\n  \n    (i+1)*P(x,n) = (2*i+1)*x*P(x,n-1) - i*P(x,n-2)\n  \n  For m > 0\n  \n    P(x,n,m) = (-1)^m * (1-x^2)^(m/2) * d^m/dx^m P(x,n)\n   */\n\n\n  Eval_legendre = function Eval_legendre() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n\n    return legendre();\n  };\n\n  legendre = function legendre() {\n    save();\n\n    __legendre();\n\n    return restore();\n  };\n\n  __legendre = function __legendre() {\n    var m, n;\n    m = 0;\n    n = 0;\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    push(p3);\n    m = pop_integer();\n\n    if (n < 0 || isNaN(n) || m < 0 || isNaN(m)) {\n      push_symbol(LEGENDRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      return;\n    }\n\n    if (issymbol(p1)) {\n      __legendre2(n, m);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n\n      __legendre2(n, m);\n\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n\n      _subst();\n\n      Eval();\n    }\n\n    return __legendre3(m);\n  };\n\n  __legendre2 = function __legendre2(n, m) {\n    var i, i1, o, ref, ref1, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      multiply();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      divide();\n    }\n\n    results = [];\n\n    for (i = i1 = 0, ref1 = m; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1);\n      results.push(derivative());\n    }\n\n    return results;\n  };\n\n  __legendre3 = function __legendre3(m) {\n    if (m === 0) {\n      return;\n    }\n\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      sine();\n      square();\n    } else if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      cosine();\n      square();\n    } else {\n      push_integer(1);\n      push(p1);\n      square();\n      subtract();\n    }\n\n    push_integer(m);\n    push_rational(1, 2);\n    multiply();\n    power();\n    multiply();\n\n    if (m % 2) {\n      return negate();\n    }\n  };\n\n  list = function list(n) {\n    var listIterator, o, ref, results;\n    listIterator = 0;\n    push(symbol(NIL));\n    results = [];\n\n    for (listIterator = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; listIterator = 0 <= ref ? ++o : --o) {\n      results.push(cons());\n    }\n\n    return results;\n  };\n\n  Eval_log = function Eval_log() {\n    push(cadr(p1));\n    Eval();\n    return logarithm();\n  };\n\n  logarithm = function logarithm() {\n    save();\n    yylog();\n    return restore();\n  };\n\n  yylog = function yylog() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (p1 === symbol(E)) {\n      push_integer(1);\n      return;\n    }\n\n    if (equaln(p1, 1)) {\n      push_integer(0);\n      return;\n    }\n\n    if (isnegativenumber(p1)) {\n      push(p1);\n      negate();\n      logarithm();\n      push(imaginaryunit);\n\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n\n      multiply();\n      add();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.log(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isfraction(p1)) {\n      push(p1);\n\n      _numerator();\n\n      logarithm();\n      push(p1);\n\n      _denominator();\n\n      logarithm();\n      subtract();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER)) {\n      push(caddr(p1));\n      push(cadr(p1));\n      logarithm();\n      multiply();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      push_integer(0);\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        logarithm();\n        add();\n        p1 = cdr(p1);\n      }\n\n      return;\n    }\n\n    push_symbol(LOG);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_lookup = function Eval_lookup() {\n    p1 = cadr(p1);\n\n    if (!iscons(p1) && cadr(p1).k === SYM) {\n      p1 = get_binding(p1);\n    }\n\n    return push(p1);\n  };\n\n  madd = function madd(a, b) {\n    return a.add(b);\n  };\n\n  msub = function msub(a, b) {\n    return a.subtract(b);\n  };\n\n  addf = function addf(a, b) {\n    return a.add(b);\n  };\n\n  subf = function subf(a, b) {\n    return a.subtract(b);\n  };\n\n  ucmp = function ucmp(a, b) {\n    return a.compareAbs(b);\n  };\n\n  mgcd = function mgcd(u, v) {\n    return bigInt.gcd(u, v);\n  };\n\n  new_string = function new_string(s) {\n    save();\n    p1 = new U();\n    p1.k = STR;\n    p1.str = s;\n    push(p1);\n    return restore();\n  };\n\n  out_of_memory = function out_of_memory() {\n    return stop(\"out of memory\");\n  };\n\n  push_zero_matrix = function push_zero_matrix(i, j) {\n    push(alloc_tensor(i * j));\n    stack[tos - 1].tensor.ndim = 2;\n    stack[tos - 1].tensor.dim[0] = i;\n    return stack[tos - 1].tensor.dim[1] = j;\n  };\n\n  push_identity_matrix = function push_identity_matrix(n) {\n    var i, o, ref;\n    push_zero_matrix(n, n);\n    i = 0;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      stack[tos - 1].tensor.elem[i * n + i] = one;\n    }\n\n    return check_tensor_dimensions(stack[tos - 1]);\n  };\n\n  push_cars = function push_cars(p) {\n    var results;\n    results = [];\n\n    while (iscons(p)) {\n      push(car(p));\n      results.push(p = cdr(p));\n    }\n\n    return results;\n  };\n\n  peek = function peek() {\n    save();\n    p1 = pop();\n    push(p1);\n    return restore();\n  };\n\n  equal = function equal(p1, p2) {\n    if (_cmp_expr(p1, p2) === 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  lessp = function lessp(p1, p2) {\n    if (_cmp_expr(p1, p2) < 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  sign = function sign(n) {\n    if (n < 0) {\n      return -1;\n    } else if (n > 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  _cmp_expr = function cmp_expr(p1, p2) {\n    var n;\n    n = 0;\n\n    if (p1 === p2) {\n      return 0;\n    }\n\n    if (p1 === symbol(NIL)) {\n      return -1;\n    }\n\n    if (p2 === symbol(NIL)) {\n      return 1;\n    }\n\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      return sign(compare_numbers(p1, p2));\n    }\n\n    if (isNumericAtom(p1)) {\n      return -1;\n    }\n\n    if (isNumericAtom(p2)) {\n      return 1;\n    }\n\n    if (isstr(p1) && isstr(p2)) {\n      return sign(strcmp(p1.str, p2.str));\n    }\n\n    if (isstr(p1)) {\n      return -1;\n    }\n\n    if (isstr(p2)) {\n      return 1;\n    }\n\n    if (issymbol(p1) && issymbol(p2)) {\n      return sign(strcmp(get_printname(p1), get_printname(p2)));\n    }\n\n    if (issymbol(p1)) {\n      return -1;\n    }\n\n    if (issymbol(p2)) {\n      return 1;\n    }\n\n    if (istensor(p1) && istensor(p2)) {\n      return compare_tensors(p1, p2);\n    }\n\n    if (istensor(p1)) {\n      return -1;\n    }\n\n    if (istensor(p2)) {\n      return 1;\n    }\n\n    while (iscons(p1) && iscons(p2)) {\n      n = _cmp_expr(car(p1), car(p2));\n\n      if (n !== 0) {\n        return n;\n      }\n\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n\n    if (iscons(p2)) {\n      return -1;\n    }\n\n    if (iscons(p1)) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  length = function length(p) {\n    var n;\n    n = 0;\n\n    while (iscons(p)) {\n      p = cdr(p);\n      n++;\n    }\n\n    return n;\n  };\n\n  unique = function unique(p) {\n    save();\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n\n    _unique_f(p);\n\n    if (p2 !== symbol(NIL)) {\n      p1 = symbol(NIL);\n    }\n\n    p = p1;\n    restore();\n    return p;\n  };\n\n  _unique_f = function unique_f(p) {\n    if (isstr(p)) {\n      if (p1 === symbol(NIL)) {\n        p1 = p;\n      } else if (p !== p1) {\n        p2 = p;\n      }\n\n      return;\n    }\n\n    while (iscons(p)) {\n      _unique_f(car(p));\n\n      if (p2 !== symbol(NIL)) {\n        return;\n      }\n\n      p = cdr(p);\n    }\n  };\n\n  ssqrt = function ssqrt() {\n    push_rational(1, 2);\n    return power();\n  };\n\n  yyexpand = function yyexpand() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  exponential = function exponential() {\n    push_symbol(E);\n    swap();\n    return power();\n  };\n\n  square = function square() {\n    push_integer(2);\n    return power();\n  };\n\n  sort_stack = function sort_stack(n) {\n    var h, subsetOfStack;\n    h = tos - n;\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(_cmp_expr);\n    return stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n  };\n\n  $.equal = equal;\n  $.length = length;\n\n  mmul = function mmul(a, b) {\n    return a.multiply(b);\n  };\n\n  mdiv = function mdiv(a, b) {\n    return a.divide(b);\n  };\n  /*\n  static void\n  addf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # can be signed or unsigned \n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] + b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n  \n  // a = a - b\n  \n  static void\n  subf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # must be signed\n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] - b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n  \n  // a = b * c\n  \n  // 0xffffffff + 0xffffffff * 0xffffffff == 0xffffffff00000000\n  \n  static void\n  mulf(unsigned int *a, unsigned int *b, int len, unsigned int c)\n  {\n    int i\n    unsigned long long t = 0; # must be unsigned\n    for (i = 0; i < len; i++) {\n      t += (unsigned long long) b[i] * c\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n    a[i] = (unsigned int) t\n  }\n   */\n\n\n  mmod = function mmod(a, b) {\n    return a.mod(b);\n  };\n\n  mdivrem = function mdivrem(a, b) {\n    var toReturn;\n    toReturn = a.divmod(b);\n    return [toReturn.quotient, toReturn.remainder];\n  };\n\n  Eval_mod = function Eval_mod() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return mod();\n  };\n\n  mod = function mod() {\n    var n;\n    n = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"mod function: divide by zero\");\n    }\n\n    if (!isNumericAtom(p1) || !isNumericAtom(p2)) {\n      push_symbol(MOD);\n      push(p1);\n      push(p2);\n      list(3);\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      push(p1);\n      n = pop_integer();\n\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n\n      push_integer(n);\n      p1 = pop();\n    }\n\n    if (isdouble(p2)) {\n      push(p2);\n      n = pop_integer();\n\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n\n      push_integer(n);\n      p2 = pop();\n    }\n\n    if (!isinteger(p1) || !isinteger(p2)) {\n      stop(\"mod function: integer arguments expected\");\n    }\n\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mmod(p1.q.a, p2.q.a);\n    p3.q.b = mint(1);\n    push(p3);\n    return restore();\n  };\n\n  mpow = function mpow(a, n) {\n    return a.pow(n);\n  };\n\n  mprime = function mprime(n) {\n    return n.isProbablePrime();\n  };\n\n  mroot = function mroot(n, index) {\n    var i, j, k, o, ref, x, y;\n    n = n.abs();\n    i = 0;\n    j = 0;\n    k = 0;\n\n    if (index === 0) {\n      stop(\"root index is zero\");\n    }\n\n    k = 0;\n\n    while (n.shiftRight(k) > 0) {\n      k++;\n    }\n\n    if (k === 0) {\n      return mint(0);\n    }\n\n    k = Math.floor((k - 1) / index);\n    j = Math.floor(k / 32 + 1);\n    x = bigInt(j);\n\n    for (i = o = 0, ref = j; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      x = x.and(bigInt(1).shiftLeft(i).not());\n    }\n\n    while (k >= 0) {\n      x = x.or(bigInt(1).shiftLeft(k));\n      y = mpow(x, index);\n\n      switch (mcmp(y, n)) {\n        case 0:\n          return x;\n\n        case 1:\n          x = x.and(bigInt(1).shiftLeft(k).not());\n      }\n\n      k--;\n    }\n\n    return 0;\n  };\n\n  Eval_multiply = function Eval_multiply() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      multiply();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  multiply = function multiply() {\n    if (esc_flag) {\n      stop(\"escape key stop\");\n    }\n\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply_numbers();\n    } else {\n      save();\n      yymultiply();\n      return restore();\n    }\n  };\n\n  yymultiply = function yymultiply() {\n    var h, i, n, o, ref, ref1;\n    h = 0;\n    i = 0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n\n    if (isZeroAtom(p1) || isZeroAtom(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n\n      return;\n    }\n\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        multiply();\n        add();\n        p1 = cdr(p1);\n      }\n\n      return;\n    }\n\n    if (expanding && isadd(p2)) {\n      p2 = cdr(p2);\n\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n\n      while (iscons(p2)) {\n        push(p1);\n        push(car(p2));\n        multiply();\n        add();\n        p2 = cdr(p2);\n      }\n\n      return;\n    }\n\n    if (!istensor(p1) && istensor(p2)) {\n      push(p1);\n      push(p2);\n      scalar_times_tensor();\n      return;\n    }\n\n    if (istensor(p1) && !istensor(p2)) {\n      push(p1);\n      push(p2);\n      tensor_times_scalar();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n    } else {\n      push(p1);\n      list(1);\n      p1 = pop();\n    }\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n    } else {\n      push(p2);\n      list(1);\n      p2 = pop();\n    }\n\n    if (isNumericAtom(car(p1)) && isNumericAtom(car(p2))) {\n      push(car(p1));\n      push(car(p2));\n      multiply_numbers();\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    } else if (isNumericAtom(car(p1))) {\n      push(car(p1));\n      p1 = cdr(p1);\n    } else if (isNumericAtom(car(p2))) {\n      push(car(p2));\n      p2 = cdr(p2);\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n    }\n\n    parse_p1();\n    parse_p2();\n\n    while (iscons(p1) && iscons(p2)) {\n      if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {\n        push_symbol(OPERATOR);\n        push(cdar(p1));\n        push(cdar(p2));\n        append();\n        cons();\n        p1 = cdr(p1);\n        p2 = cdr(p2);\n        parse_p1();\n        parse_p2();\n        continue;\n      }\n\n      switch (_cmp_expr(p3, p4)) {\n        case -1:\n          push(car(p1));\n          p1 = cdr(p1);\n          parse_p1();\n          break;\n\n        case 1:\n          push(car(p2));\n          p2 = cdr(p2);\n          parse_p2();\n          break;\n\n        case 0:\n          combine_factors(h);\n          p1 = cdr(p1);\n          p2 = cdr(p2);\n          parse_p1();\n          parse_p2();\n          break;\n\n        default:\n          stop(\"internal error 2\");\n      }\n    }\n\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n\n    while (iscons(p2)) {\n      push(car(p2));\n      p2 = cdr(p2);\n    }\n\n    __normalize_radical_factors(h);\n\n    if (expanding) {\n      for (i = o = ref = h, ref1 = tos; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {\n        if (isadd(stack[i])) {\n          multiply_all(tos - h);\n          return;\n        }\n      }\n    }\n\n    n = tos - h;\n\n    if (n === 1) {\n      return;\n    }\n\n    if (isrational(stack[h]) && equaln(stack[h], 1)) {\n      if (n === 2) {\n        p7 = pop();\n        pop();\n        push(p7);\n      } else {\n        stack[h] = symbol(MULTIPLY);\n        list(n);\n      }\n\n      return;\n    }\n\n    list(n);\n    p7 = pop();\n    push_symbol(MULTIPLY);\n    push(p7);\n    return cons();\n  };\n\n  parse_p1 = function parse_p1() {\n    p3 = car(p1);\n    p5 = evaluatingAsFloats ? one_as_double : one;\n\n    if (car(p3) === symbol(POWER)) {\n      p5 = caddr(p3);\n      return p3 = cadr(p3);\n    }\n  };\n\n  parse_p2 = function parse_p2() {\n    p4 = car(p2);\n    p6 = evaluatingAsFloats ? one_as_double : one;\n\n    if (car(p4) === symbol(POWER)) {\n      p6 = caddr(p4);\n      return p4 = cadr(p4);\n    }\n  };\n\n  combine_factors = function combine_factors(h) {\n    push(p4);\n    push(p5);\n    push(p6);\n    add();\n    power();\n    p7 = pop();\n\n    if (isNumericAtom(p7)) {\n      push(stack[h]);\n      push(p7);\n      multiply_numbers();\n      return stack[h] = pop();\n    } else if (car(p7) === symbol(MULTIPLY)) {\n      if (isNumericAtom(cadr(p7)) && cdddr(p7) === symbol(NIL)) {\n        push(stack[h]);\n        push(cadr(p7));\n        multiply_numbers();\n        stack[h] = pop();\n        return push(caddr(p7));\n      } else {\n        return push(p7);\n      }\n    } else {\n      return push(p7);\n    }\n  };\n\n  gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];\n\n  combine_gammas = function combine_gammas(h) {\n    var n;\n    n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];\n\n    if (n < 0) {\n      n = -n;\n      push(stack[h]);\n      negate();\n      stack[h] = pop();\n    }\n\n    if (n > 1) {\n      return push(_gamma[n]);\n    }\n  };\n\n  multiply_noexpand = function multiply_noexpand() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply();\n    return expanding = prev_expanding;\n  };\n\n  multiply_all = function multiply_all(n) {\n    var h, i, o, ref;\n    i = 0;\n\n    if (n === 1) {\n      return;\n    }\n\n    if (n === 0) {\n      push(evaluatingAsFloats ? one_as_double : one);\n      return;\n    }\n\n    h = tos - n;\n    push(stack[h]);\n\n    for (i = o = 1, ref = n; 1 <= ref ? o < ref : o > ref; i = 1 <= ref ? ++o : --o) {\n      push(stack[h + i]);\n      multiply();\n    }\n\n    stack[h] = pop();\n    return moveTos(h + 1);\n  };\n\n  multiply_all_noexpand = function multiply_all_noexpand(n) {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply_all(n);\n    return expanding = prev_expanding;\n  };\n\n  divide = function divide() {\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return divide_numbers();\n    } else {\n      inverse();\n      return multiply();\n    }\n  };\n\n  inverse = function inverse() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return invert_number();\n    } else {\n      push_integer(-1);\n      return power();\n    }\n  };\n\n  reciprocate = function reciprocate() {\n    return inverse();\n  };\n\n  negate = function negate() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return negate_number();\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(-1.0);\n      } else {\n        push_integer(-1);\n      }\n\n      return multiply();\n    }\n  };\n\n  negate_expand = function negate_expand() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  negate_noexpand = function negate_noexpand() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  __normalize_radical_factors = function __normalize_radical_factors(h) {\n    var i, i1, j1, o, ref, ref1, ref2, ref3, ref4, ref5;\n    i = 0;\n\n    if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {\n      return;\n    }\n\n    for (i = o = ref = h + 1, ref1 = tos; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {\n      if (__is_radical_number(stack[i])) {\n        break;\n      }\n    }\n\n    if (i === tos) {\n      return;\n    }\n\n    save();\n    push(stack[h]);\n    mp_numerator();\n    p1 = pop();\n\n    for (i = i1 = ref2 = h + 1, ref3 = tos; ref2 <= ref3 ? i1 < ref3 : i1 > ref3; i = ref2 <= ref3 ? ++i1 : --i1) {\n      if (isplusone(p1) || isminusone(p1)) {\n        break;\n      }\n\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n\n      if (!isnegativenumber(p4)) {\n        continue;\n      }\n\n      push(p1);\n      push(p3);\n      divide();\n      p5 = pop();\n\n      if (!isinteger(p5)) {\n        continue;\n      }\n\n      p1 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(evaluatingAsFloats ? one_as_double : one);\n      push(p4);\n      add();\n      list(3);\n      stack[i] = pop();\n    }\n\n    push(stack[h]);\n    mp_denominator();\n    p2 = pop();\n\n    for (i = j1 = ref4 = h + 1, ref5 = tos; ref4 <= ref5 ? j1 < ref5 : j1 > ref5; i = ref4 <= ref5 ? ++j1 : --j1) {\n      if (isplusone(p2)) {\n        break;\n      }\n\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n\n      if (isnegativenumber(p4)) {\n        continue;\n      }\n\n      push(p2);\n      push(p3);\n      divide();\n      p5 = pop();\n\n      if (!isinteger(p5)) {\n        continue;\n      }\n\n      p2 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(p4);\n      push(one);\n      subtract();\n\n      if (dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication) {\n        if (isinteger(p3) && !isinteger(stack[tos - 1]) && isnegativenumber(stack[tos - 1])) {\n          pop();\n          pop();\n          pop();\n          push(p1);\n          push(p3);\n          divide();\n          p1 = pop();\n          break;\n        }\n      }\n\n      list(3);\n      stack[i] = pop();\n    }\n\n    push(p1);\n    push(p2);\n    divide();\n    stack[h] = pop();\n    return restore();\n  };\n\n  __is_radical_number = function __is_radical_number(p) {\n    if (car(p) === symbol(POWER) && isNumericAtom(cadr(p)) && isNumericAtom(caddr(p)) && !isminusone(cadr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  NROOTS_YMAX = 101;\n  NROOTS_DELTA = 1.0e-6;\n  NROOTS_EPSILON = 1.0e-9;\n\n  NROOTS_ABS = function NROOTS_ABS(z) {\n    return Math.sqrt(z.r * z.r + z.i * z.i);\n  };\n\n  theRandom = 0.0;\n\n  NROOTS_RANDOM = function NROOTS_RANDOM() {\n    return 4.0 * Math.random() - 2.0;\n  };\n\n  numericRootOfPolynomial = function () {\n    function numericRootOfPolynomial() {}\n\n    numericRootOfPolynomial.prototype.r = 0.0;\n    numericRootOfPolynomial.prototype.i = 0.0;\n    return numericRootOfPolynomial;\n  }();\n\n  nroots_a = new numericRootOfPolynomial();\n  nroots_b = new numericRootOfPolynomial();\n  nroots_x = new numericRootOfPolynomial();\n  nroots_y = new numericRootOfPolynomial();\n  nroots_fa = new numericRootOfPolynomial();\n  nroots_fb = new numericRootOfPolynomial();\n  nroots_dx = new numericRootOfPolynomial();\n  nroots_df = new numericRootOfPolynomial();\n  nroots_c = [];\n\n  for (initNRoots = o = 0, ref = NROOTS_YMAX; 0 <= ref ? o < ref : o > ref; initNRoots = 0 <= ref ? ++o : --o) {\n    nroots_c[initNRoots] = new numericRootOfPolynomial();\n  }\n\n  Eval_nroots = function Eval_nroots() {\n    var h, i, i1, j1, k, l1, n, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n\n    p2 = pop();\n    p1 = pop();\n\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"nroots: polynomial?\");\n    }\n\n    h = tos;\n    push(p1);\n    push(p2);\n    n = coeff();\n\n    if (n > NROOTS_YMAX) {\n      stop(\"nroots: degree?\");\n    }\n\n    for (i = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      push(stack[h + i]);\n      real();\n\n      _yyfloat();\n\n      Eval();\n      p1 = pop();\n      push(stack[h + i]);\n      imag();\n\n      _yyfloat();\n\n      Eval();\n      p2 = pop();\n\n      if (!isdouble(p1) || !isdouble(p2)) {\n        stop(\"nroots: coefficients?\");\n      }\n\n      nroots_c[i].r = p1.d;\n      nroots_c[i].i = p2.d;\n    }\n\n    moveTos(h);\n    monic(n);\n\n    for (k = j1 = ref2 = n; j1 > 1; k = j1 += -1) {\n      findroot(k);\n\n      if (Math.abs(nroots_a.r) < NROOTS_DELTA) {\n        nroots_a.r = 0.0;\n      }\n\n      if (Math.abs(nroots_a.i) < NROOTS_DELTA) {\n        nroots_a.i = 0.0;\n      }\n\n      push_double(nroots_a.r);\n      push_double(nroots_a.i);\n      push(imaginaryunit);\n      multiply();\n      add();\n      NROOTS_divpoly(k);\n    }\n\n    n = tos - h;\n\n    if (n > 1) {\n      sort_stack(n);\n      p1 = alloc_tensor(n);\n      p1.tensor.ndim = 1;\n      p1.tensor.dim[0] = n;\n\n      for (i = l1 = 0, ref3 = n; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n        p1.tensor.elem[i] = stack[h + i];\n      }\n\n      moveTos(h);\n      return push(p1);\n    }\n  };\n\n  monic = function monic(n) {\n    var i1, k, ref1, t;\n    k = 0;\n    t = 0.0;\n    nroots_y.r = nroots_c[n - 1].r;\n    nroots_y.i = nroots_c[n - 1].i;\n    t = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;\n\n    for (k = i1 = 0, ref1 = n - 1; 0 <= ref1 ? i1 < ref1 : i1 > ref1; k = 0 <= ref1 ? ++i1 : --i1) {\n      nroots_c[k].r = (nroots_c[k].r * nroots_y.r + nroots_c[k].i * nroots_y.i) / t;\n      nroots_c[k].i = (nroots_c[k].i * nroots_y.r - nroots_c[k].r * nroots_y.i) / t;\n    }\n\n    nroots_c[n - 1].r = 1.0;\n    return nroots_c[n - 1].i = 0.0;\n  };\n\n  findroot = function findroot(n) {\n    var i1, j, j1, k, nrabs, t;\n    j = 0;\n    k = 0;\n    t = 0.0;\n\n    if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {\n      nroots_a.r = 0.0;\n      nroots_a.i = 0.0;\n      return;\n    }\n\n    for (j = i1 = 0; i1 < 100; j = ++i1) {\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n      compute_fa(n);\n      nroots_b.r = nroots_a.r;\n      nroots_b.i = nroots_a.i;\n      nroots_fb.r = nroots_fa.r;\n      nroots_fb.i = nroots_fa.i;\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n\n      for (k = j1 = 0; j1 < 1000; k = ++j1) {\n        compute_fa(n);\n        nrabs = NROOTS_ABS(nroots_fa);\n\n        if (DEBUG) {\n          console.log(\"nrabs: \" + nrabs);\n        }\n\n        if (nrabs < NROOTS_EPSILON) {\n          return;\n        }\n\n        if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {\n          nroots_x.r = nroots_a.r;\n          nroots_x.i = nroots_a.i;\n          nroots_a.r = nroots_b.r;\n          nroots_a.i = nroots_b.i;\n          nroots_b.r = nroots_x.r;\n          nroots_b.i = nroots_x.i;\n          nroots_x.r = nroots_fa.r;\n          nroots_x.i = nroots_fa.i;\n          nroots_fa.r = nroots_fb.r;\n          nroots_fa.i = nroots_fb.i;\n          nroots_fb.r = nroots_x.r;\n          nroots_fb.i = nroots_x.i;\n        }\n\n        nroots_dx.r = nroots_b.r - nroots_a.r;\n        nroots_dx.i = nroots_b.i - nroots_a.i;\n        nroots_df.r = nroots_fb.r - nroots_fa.r;\n        nroots_df.i = nroots_fb.i - nroots_fa.i;\n        t = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;\n\n        if (t === 0.0) {\n          break;\n        }\n\n        nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t;\n        nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t;\n        nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);\n        nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);\n      }\n    }\n\n    return stop(\"nroots: convergence error\");\n  };\n\n  compute_fa = function compute_fa(n) {\n    var i1, k, ref1, results, t;\n    k = 0;\n    t = 0.0;\n    nroots_x.r = nroots_a.r;\n    nroots_x.i = nroots_a.i;\n    nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;\n    nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;\n    results = [];\n\n    for (k = i1 = 2, ref1 = n; 2 <= ref1 ? i1 < ref1 : i1 > ref1; k = 2 <= ref1 ? ++i1 : --i1) {\n      t = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;\n      nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;\n      nroots_x.r = t;\n      nroots_fa.r += nroots_c[k].r * nroots_x.r - nroots_c[k].i * nroots_x.i;\n      results.push(nroots_fa.i += nroots_c[k].r * nroots_x.i + nroots_c[k].i * nroots_x.r);\n    }\n\n    return results;\n  };\n\n  NROOTS_divpoly = function NROOTS_divpoly(n) {\n    var i1, j1, k, ref1, ref2, results;\n    k = 0;\n\n    for (k = i1 = ref1 = n - 1; ref1 <= 0 ? i1 < 0 : i1 > 0; k = ref1 <= 0 ? ++i1 : --i1) {\n      nroots_c[k - 1].r += nroots_c[k].r * nroots_a.r - nroots_c[k].i * nroots_a.i;\n      nroots_c[k - 1].i += nroots_c[k].i * nroots_a.r + nroots_c[k].r * nroots_a.i;\n    }\n\n    if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {\n      stop(\"nroots: residual error\");\n    }\n\n    results = [];\n\n    for (k = j1 = 0, ref2 = n - 1; 0 <= ref2 ? j1 < ref2 : j1 > ref2; k = 0 <= ref2 ? ++j1 : --j1) {\n      nroots_c[k].r = nroots_c[k + 1].r;\n      results.push(nroots_c[k].i = nroots_c[k + 1].i);\n    }\n\n    return results;\n  };\n\n  Eval_numerator = function Eval_numerator() {\n    push(cadr(p1));\n    Eval();\n    return _numerator();\n  };\n\n  _numerator = function numerator() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      rationalize();\n      theArgument = pop();\n    }\n\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n\n        _numerator();\n\n        theArgument = cdr(theArgument);\n      }\n\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_numerator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      return push(one);\n    } else {\n      return push(theArgument);\n    }\n  };\n\n  Eval_outer = function Eval_outer() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      outer();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  outer = function outer() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (istensor(p1) && istensor(p2)) {\n      yyouter();\n    } else {\n      push(p1);\n      push(p2);\n\n      if (istensor(p1)) {\n        tensor_times_scalar();\n      } else if (istensor(p2)) {\n        scalar_times_tensor();\n      } else {\n        multiply();\n      }\n    }\n\n    return restore();\n  };\n\n  yyouter = function yyouter() {\n    var i, i1, j, j1, k, l1, m1, ndim, nelem, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    k = 0;\n    ndim = 0;\n    nelem = 0;\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n\n    if (ndim > MAXDIM) {\n      stop(\"outer: rank of result exceeds maximum\");\n    }\n\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n\n    for (i = i1 = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    j = i;\n\n    for (i = j1 = 0, ref2 = p2.tensor.ndim; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      p3.tensor.dim[j + i] = p2.tensor.dim[i];\n    }\n\n    k = 0;\n\n    for (i = l1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n      for (j = m1 = 0, ref4 = p2.tensor.nelem; 0 <= ref4 ? m1 < ref4 : m1 > ref4; j = 0 <= ref4 ? ++m1 : --m1) {\n        push(p1.tensor.elem[i]);\n        push(p2.tensor.elem[j]);\n        multiply();\n        p3.tensor.elem[k++] = pop();\n      }\n    }\n\n    return push(p3);\n  };\n  /*\n   Partition a term\n  \n    Input stack:\n  \n      term (factor or product of factors)\n  \n      free variable\n  \n    Output stack:\n  \n      constant expression\n  \n      variable expression\n   */\n\n\n  partition = function partition() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push_integer(1);\n    p3 = pop();\n    p4 = p3;\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      if (_Find(car(p1), p2)) {\n        push(p4);\n        push(car(p1));\n        multiply();\n        p4 = pop();\n      } else {\n        push(p3);\n        push(car(p1));\n        multiply();\n        p3 = pop();\n      }\n\n      p1 = cdr(p1);\n    }\n\n    push(p3);\n    push(p4);\n    return restore();\n  };\n  /*\n    Add a pattern i.e. a substitution rule.\n    Substitution rule needs a template as first argument\n    and what to transform it to as second argument.\n    Optional third argument is a boolean test which\n    adds conditions to when the rule is applied.\n   */\n\n\n  Eval_silentpattern = function Eval_silentpattern() {\n    Eval_pattern();\n    pop();\n    return push_symbol(NIL);\n  };\n\n  Eval_pattern = function Eval_pattern() {\n    var firstArgument, patternPosition, secondArgument, stringKey, thirdArgument;\n\n    if (!iscons(cdr(p1))) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n\n    firstArgument = car(cdr(p1));\n    secondArgument = car(cdr(cdr(p1)));\n\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n\n    if (!iscons(cdr(cdr(p1)))) {\n      thirdArgument = symbol(NIL);\n    } else {\n      thirdArgument = car(cdr(cdr(cdr(p1))));\n    }\n\n    if (equal(firstArgument, secondArgument)) {\n      stop(\"recursive pattern\");\n    }\n\n    stringKey = \"template: \" + _print_list(firstArgument);\n    stringKey += \" tests: \" + _print_list(thirdArgument);\n\n    if (DEBUG) {\n      console.log(\"pattern stringkey: \" + stringKey);\n    }\n\n    patternPosition = userSimplificationsInStringForm.indexOf(stringKey);\n\n    if (patternPosition === -1) {\n      userSimplificationsInStringForm.push(stringKey);\n      userSimplificationsInListForm.push(cdr(p1));\n    } else {\n      if (DEBUG) {\n        console.log(\"pattern already exists, replacing. \" + cdr(p1));\n      }\n\n      userSimplificationsInStringForm[patternPosition] = stringKey;\n      userSimplificationsInListForm[patternPosition] = cdr(p1);\n    }\n\n    push_symbol(PATTERN);\n    push(cdr(p1));\n    return list(2);\n  };\n  /*\n    Clear all patterns\n   */\n\n\n  do_clearPatterns = function do_clearPatterns() {\n    userSimplificationsInListForm = [];\n    return userSimplificationsInStringForm = [];\n  };\n\n  Eval_clearpatterns = function Eval_clearpatterns() {\n    do_clearPatterns();\n    return push_symbol(NIL);\n  };\n\n  Eval_patternsinfo = function Eval_patternsinfo() {\n    var patternsinfoToBePrinted;\n    patternsinfoToBePrinted = patternsinfo();\n\n    if (patternsinfoToBePrinted !== \"\") {\n      return new_string(patternsinfoToBePrinted);\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  patternsinfo = function patternsinfo() {\n    var i, i1, len, patternsinfoToBePrinted;\n    patternsinfoToBePrinted = \"\";\n\n    for (i1 = 0, len = userSimplificationsInListForm.length; i1 < len; i1++) {\n      i = userSimplificationsInListForm[i1];\n      patternsinfoToBePrinted += userSimplificationsInListForm + \"\\n\";\n    }\n\n    return patternsinfoToBePrinted;\n  };\n  /*\n  Convert complex z to polar form\n  \n    Input:    push  z\n  \n    Output:    Result on stack\n  \n    polar(z) = abs(z) * exp(i * arg(z))\n   */\n\n\n  Eval_polar = function Eval_polar() {\n    push(cadr(p1));\n    Eval();\n    return polar();\n  };\n\n  polar = function polar() {\n    evaluatingPolar++;\n    save();\n    p1 = pop();\n    push(p1);\n    abs();\n    push(imaginaryunit);\n    push(p1);\n    arg();\n    multiply();\n    exponential();\n    multiply();\n    evaluatingPolar--;\n    return restore();\n  };\n\n  n_factor_number = 0;\n\n  factor_number = function factor_number() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n\n    if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    n_factor_number = p1.q.a;\n    h = tos;\n    factor_a();\n\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      cons();\n    }\n\n    return restore();\n  };\n\n  factor_a = function factor_a() {\n    var i1, k;\n    k = 0;\n\n    if (n_factor_number.isNegative()) {\n      n_factor_number = setSignTo(n_factor_number, 1);\n      push_integer(-1);\n    }\n\n    for (k = i1 = 0; i1 < 10000; k = ++i1) {\n      try_kth_prime(k);\n\n      if (n_factor_number.compare(1) === 0) {\n        return;\n      }\n    }\n\n    return factor_b();\n  };\n\n  try_kth_prime = function try_kth_prime(k) {\n    var count, d, q, r, ref1;\n    count = 0;\n    d = mint(primetab[k]);\n    count = 0;\n\n    while (1) {\n      if (n_factor_number.compare(1) === 0) {\n        if (count) {\n          push_factor(d, count);\n        }\n\n        return;\n      }\n\n      ref1 = mdivrem(n_factor_number, d), q = ref1[0], r = ref1[1];\n\n      if (r.isZero()) {\n        count++;\n        n_factor_number = q;\n      } else {\n        break;\n      }\n    }\n\n    if (count) {\n      push_factor(d, count);\n    }\n\n    if (mcmp(q, d) === -1) {\n      push_factor(n_factor_number, 1);\n      return n_factor_number = mint(1);\n    }\n  };\n\n  factor_b = function factor_b() {\n    var bigint_one, g, k, l, t, x, xprime;\n    k = 0;\n    l = 0;\n    bigint_one = mint(1);\n    x = mint(5);\n    xprime = mint(2);\n    k = 1;\n    l = 1;\n\n    while (1) {\n      if (mprime(n_factor_number)) {\n        push_factor(n_factor_number, 1);\n        return 0;\n      }\n\n      while (1) {\n        if (esc_flag) {\n          stop(\"esc\");\n        }\n\n        t = msub(xprime, x);\n        t = setSignTo(t, 1);\n        g = mgcd(t, n_factor_number);\n\n        if (MEQUAL(g, 1)) {\n          if (--k === 0) {\n            xprime = x;\n            l *= 2;\n            k = l;\n          }\n\n          t = mmul(x, x);\n          x = madd(t, bigint_one);\n          t = mmod(x, n_factor_number);\n          x = t;\n          continue;\n        }\n\n        push_factor(g, 1);\n\n        if (mcmp(g, n_factor_number) === 0) {\n          return -1;\n        }\n\n        t = mdiv(n_factor_number, g);\n        n_factor_number = t;\n        t = mmod(x, n_factor_number);\n        x = t;\n        t = mmod(xprime, n_factor_number);\n        xprime = t;\n        break;\n      }\n    }\n  };\n\n  push_factor = function push_factor(d, count) {\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = d;\n    p1.q.b = mint(1);\n    push(p1);\n\n    if (count > 1) {\n      push_symbol(POWER);\n      swap();\n      p1 = new U();\n      p1.k = NUM;\n      p1.q.a = mint(count);\n      p1.q.b = mint(1);\n      push(p1);\n      return list(3);\n    }\n  };\n  /* Power function\n  \n    Input:    push  Base\n  \n        push  Exponent\n  \n    Output:    Result on stack\n   */\n\n\n  DEBUG_POWER = false;\n\n  Eval_power = function Eval_power() {\n    if (DEBUG_POWER) {\n      debugger;\n    }\n\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return power();\n  };\n\n  power = function power() {\n    save();\n    yypower();\n    return restore();\n  };\n\n  yypower = function yypower() {\n    var b_isEven_and_c_isItsInverse, hopefullySimplified, inputBase, inputExp, isThisOne, is_a_moreThanZero, n;\n\n    if (DEBUG_POWER) {\n      debugger;\n    }\n\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    inputExp = p2;\n    inputBase = p1;\n\n    if (DEBUG_POWER) {\n      console.log(\"POWER: \" + p1 + \" ^ \" + p2);\n    }\n\n    if (equal(p1, one) || isZeroAtomOrTensor(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (equal(p2, one)) {\n      push(p1);\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isminusone(p1) && isminusone(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n\n      negate();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isminusone(p1) && isoneovertwo(p2)) {\n      push(imaginaryunit);\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isminusone(p1) && isminusoneovertwo(p2)) {\n      push(imaginaryunit);\n      negate();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isminusone(p1) && !isdouble(p1) && isrational(p2) && !isinteger(p2) && ispositivenumber(p2) && !evaluatingAsFloats) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: -1 ^ rational\");\n      }\n\n      if (DEBUG_POWER) {\n        console.log(\" trick: p2.q.a , p2.q.b \" + p2.q.a + \" , \" + p2.q.b);\n      }\n\n      if (p2.q.a < p2.q.b) {\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n      } else {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push_symbol(POWER);\n        push(p1);\n        push_rational(p2.q.a.mod(p2.q.b), p2.q.b);\n        list(3);\n        list(3);\n\n        if (DEBUG_POWER) {\n          console.log(\" trick applied : \" + stack[tos - 1]);\n        }\n      }\n\n      _rect();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isrational(p1) && isrational(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: isrational(p1) && isrational(p2)\");\n      }\n\n      push(p1);\n      push(p2);\n      qpow();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: both base and exponent are either rational or double \");\n      }\n\n      if (DEBUG_POWER) {\n        console.log(\"POWER - isNumericAtom(p1) && isNumericAtom(p2)\");\n      }\n\n      push(p1);\n      push(p2);\n      dpow();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (istensor(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: istensor(p1) \");\n      }\n\n      power_tensor();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (car(p1) === symbol(ABS) && iseveninteger(p2) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: even power of absolute of real value \");\n      }\n\n      push(cadr(p1));\n      push(p2);\n      power();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (p1 === symbol(E) && car(p2) === symbol(LOG)) {\n      push(cadr(p2));\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (p1 === symbol(E) && isdouble(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: p1 == symbol(E) && isdouble(p2) \");\n      }\n\n      push_double(Math.exp(p2.d));\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (p1 === symbol(E) && _Find(p2, imaginaryunit) !== 0 && _Find(p2, symbol(PI)) !== 0 && !evaluatingPolar) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n\n      if (DEBUG_POWER) {\n        console.log(\"   power: turning complex exponential to rect: \" + stack[tos - 1]);\n      }\n\n      _rect();\n\n      hopefullySimplified = pop();\n\n      if (_Find(hopefullySimplified, symbol(PI)) === 0) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: turned complex exponential to rect: \" + hopefullySimplified);\n        }\n\n        push(hopefullySimplified);\n        return;\n      }\n    }\n\n    if (car(p1) === symbol(MULTIPLY) && isinteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: (a * b) ^ c  ->  (a ^ c) * (b ^ c) \");\n      }\n\n      p1 = cdr(p1);\n      push(car(p1));\n      push(p2);\n      power();\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        power();\n        multiply();\n        p1 = cdr(p1);\n      }\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    is_a_moreThanZero = false;\n\n    if (isNumericAtom(cadr(p1))) {\n      is_a_moreThanZero = sign(compare_numbers(cadr(p1), zero));\n    }\n\n    if (car(p1) === symbol(POWER) && (isinteger(p2) || is_a_moreThanZero)) {\n      push(cadr(p1));\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      power();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    b_isEven_and_c_isItsInverse = false;\n\n    if (iseveninteger(caddr(p1))) {\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      isThisOne = pop();\n\n      if (isone(isThisOne)) {\n        b_isEven_and_c_isItsInverse = true;\n      }\n    }\n\n    if (car(p1) === symbol(POWER) && b_isEven_and_c_isItsInverse) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: car(p1) == symbol(POWER) && b_isEven_and_c_isItsInverse \");\n      }\n\n      push(cadr(p1));\n      abs();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (expanding && isadd(p1) && isNumericAtom(p2)) {\n      push(p2);\n      n = pop_integer();\n\n      if (n > 1 && !isNaN(n)) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: expanding && isadd(p1) && isNumericAtom(p2) \");\n        }\n\n        power_sum(n);\n\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n\n        return;\n      }\n    }\n\n    if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 1 && car(p1) == symbol(SIN) && iseveninteger(p2) \");\n      }\n\n      push_integer(1);\n      push(cadr(p1));\n      cosine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 2 && car(p1) == symbol(COS) && iseveninteger(p2) \");\n      }\n\n      push_integer(1);\n      push(cadr(p1));\n      sine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (iscomplexnumber(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\" power - handling the case (a + ib) ^ n\");\n      }\n\n      if (isinteger(p2)) {\n        push(p1);\n        conjugate();\n        p3 = pop();\n        push(p3);\n        push(p3);\n        push(p1);\n        multiply();\n        divide();\n\n        if (!isone(p2)) {\n          push(p2);\n          negate();\n          power();\n        }\n\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n\n        return;\n      }\n\n      if (isNumericAtom(p2)) {\n        push(p1);\n        abs();\n        push(p2);\n        power();\n        push_integer(-1);\n        push(p1);\n        arg();\n        push(p2);\n        multiply();\n\n        if (evaluatingAsFloats || iscomplexnumberdouble(p1) && isdouble(p2)) {\n          push_double(Math.PI);\n        } else {\n          push(symbol(PI));\n        }\n\n        divide();\n        power();\n        multiply();\n\n        if (avoidCalculatingPowersIntoArctans) {\n          if (_Find(stack[tos - 1], symbol(ARCTAN))) {\n            pop();\n            push_symbol(POWER);\n            push(p1);\n            push(p2);\n            list(3);\n          }\n        }\n\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n\n        return;\n      }\n    }\n\n    if (simplify_polar()) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: using simplify_polar\");\n      }\n\n      return;\n    }\n\n    if (DEBUG_POWER) {\n      console.log(\"   power: nothing can be done \");\n    }\n\n    push_symbol(POWER);\n    push(p1);\n    push(p2);\n    list(3);\n\n    if (DEBUG_POWER) {\n      return console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n    }\n  };\n\n  power_sum = function power_sum(n) {\n    var a, i, i1, j, j1, k, l1, ref1, ref2, ref3;\n    a = [];\n    i = 0;\n    j = 0;\n    k = 0;\n    k = length(p1) - 1;\n    push_frame(k * (n + 1));\n    p1 = cdr(p1);\n\n    for (i = i1 = 0, ref1 = k; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      for (j = j1 = 0, ref2 = n; 0 <= ref2 ? j1 <= ref2 : j1 >= ref2; j = 0 <= ref2 ? ++j1 : --j1) {\n        push(car(p1));\n        push_integer(j);\n        power();\n        stack[frame + i * (n + 1) + j] = pop();\n      }\n\n      p1 = cdr(p1);\n    }\n\n    push_integer(n);\n    factorial();\n    p1 = pop();\n\n    for (i = l1 = 0, ref3 = k; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n      a[i] = 0;\n    }\n\n    push(zero);\n\n    _multinomial_sum(k, n, a, 0, n);\n\n    return pop_frame(k * (n + 1));\n  };\n\n  _multinomial_sum = function multinomial_sum(k, n, a, i, m) {\n    var i1, j, j1, l1, ref1, ref2, ref3;\n    j = 0;\n\n    if (i < k - 1) {\n      for (j = i1 = 0, ref1 = m; 0 <= ref1 ? i1 <= ref1 : i1 >= ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        a[i] = j;\n\n        _multinomial_sum(k, n, a, i + 1, m - j);\n      }\n\n      return;\n    }\n\n    a[i] = m;\n    push(p1);\n\n    for (j = j1 = 0, ref2 = k; 0 <= ref2 ? j1 < ref2 : j1 > ref2; j = 0 <= ref2 ? ++j1 : --j1) {\n      push_integer(a[j]);\n      factorial();\n      divide();\n    }\n\n    for (j = l1 = 0, ref3 = k; 0 <= ref3 ? l1 < ref3 : l1 > ref3; j = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[frame + j * (n + 1) + a[j]]);\n      multiply();\n    }\n\n    return add();\n  };\n\n  simplify_polar = function simplify_polar() {\n    var doNothing, n;\n    n = 0;\n    n = isquarterturn(p2);\n\n    switch (n) {\n      case 0:\n        doNothing = 1;\n        break;\n\n      case 1:\n        push_integer(1);\n        return 1;\n\n      case 2:\n        push_integer(-1);\n        return 1;\n\n      case 3:\n        push(imaginaryunit);\n        return 1;\n\n      case 4:\n        push(imaginaryunit);\n        negate();\n        return 1;\n    }\n\n    if (car(p2) === symbol(ADD)) {\n      p3 = cdr(p2);\n\n      while (iscons(p3)) {\n        n = isquarterturn(car(p3));\n\n        if (n) {\n          break;\n        }\n\n        p3 = cdr(p3);\n      }\n\n      switch (n) {\n        case 0:\n          return 0;\n\n        case 1:\n          push_integer(1);\n          break;\n\n        case 2:\n          push_integer(-1);\n          break;\n\n        case 3:\n          push(imaginaryunit);\n          break;\n\n        case 4:\n          push(imaginaryunit);\n          negate();\n      }\n\n      push(p2);\n      push(car(p3));\n      subtract();\n      exponential();\n      multiply();\n      return 1;\n    }\n\n    return 0;\n  };\n\n  Eval_prime = function Eval_prime() {\n    push(cadr(p1));\n    Eval();\n    return prime();\n  };\n\n  prime = function prime() {\n    var n;\n    n = 0;\n    n = pop_integer();\n\n    if (n < 1 || n > MAXPRIMETAB) {\n      stop(\"prime: Argument out of range.\");\n    }\n\n    n = primetab[n - 1];\n    return push_integer(n);\n  };\n\n  power_str = \"^\";\n  codeGen = false;\n\n  Eval_print = function Eval_print() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), printMode);\n    return push(symbol(NIL));\n  };\n\n  Eval_print2dascii = function Eval_print2dascii() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_2DASCII);\n    return push(symbol(NIL));\n  };\n\n  Eval_printcomputer = function Eval_printcomputer() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_COMPUTER);\n    return push(symbol(NIL));\n  };\n\n  Eval_printlatex = function Eval_printlatex() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_LATEX);\n    return push(symbol(NIL));\n  };\n\n  Eval_printhuman = function Eval_printhuman() {\n    var original_test_flag;\n    original_test_flag = test_flag;\n    test_flag = 0;\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_HUMAN);\n    test_flag = original_test_flag;\n    return push(symbol(NIL));\n  };\n\n  Eval_printlist = function Eval_printlist() {\n    var beenPrinted;\n    beenPrinted = _print(cdr(p1), PRINTMODE_LIST);\n    stringsEmittedByUserPrintouts += beenPrinted;\n    return push(symbol(NIL));\n  };\n\n  _print = function _print(p, passedPrintMode) {\n    var accumulator, origPrintMode;\n    accumulator = \"\";\n\n    while (iscons(p)) {\n      push(car(p));\n      Eval();\n      p2 = pop();\n      /*\n      if (issymbol(car(p)) && car(p) != p2)\n        push_symbol(SETQ);\n        push(car(p));\n        push(p2);\n        list(3);\n        p2 = pop();\n       */\n\n      origPrintMode = printMode;\n\n      if (passedPrintMode === PRINTMODE_COMPUTER) {\n        printMode = PRINTMODE_COMPUTER;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_FULL_PRINT);\n      } else if (passedPrintMode === PRINTMODE_HUMAN) {\n        printMode = PRINTMODE_HUMAN;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_PLAIN_PRINT);\n      } else if (passedPrintMode === PRINTMODE_2DASCII) {\n        printMode = PRINTMODE_2DASCII;\n        accumulator = print2dascii(p2);\n        rememberPrint(accumulator, LAST_2DASCII_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LATEX) {\n        printMode = PRINTMODE_LATEX;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_LATEX_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LIST) {\n        printMode = PRINTMODE_LIST;\n        accumulator = _print_list(p2);\n        rememberPrint(accumulator, LAST_LIST_PRINT);\n      }\n\n      printMode = origPrintMode;\n      p = cdr(p);\n    }\n\n    if (DEBUG) {\n      console.log(\"emttedString from display: \" + stringsEmittedByUserPrintouts);\n    }\n\n    return accumulator;\n  };\n\n  rememberPrint = function rememberPrint(theString, theTypeOfPrint) {\n    var parsedString;\n    scan('\"' + theString + '\"');\n    parsedString = pop();\n    return set_binding(symbol(theTypeOfPrint), parsedString);\n  };\n\n  print_str = function print_str(s) {\n    if (DEBUG) {\n      console.log(\"emttedString from print_str: \" + stringsEmittedByUserPrintouts);\n    }\n\n    return s;\n  };\n\n  print_char = function print_char(c) {\n    return c;\n  };\n\n  collectLatexStringFromReturnValue = function collectLatexStringFromReturnValue(p) {\n    var origPrintMode, originalCodeGen, returnedString;\n    origPrintMode = printMode;\n    printMode = PRINTMODE_LATEX;\n    originalCodeGen = codeGen;\n    codeGen = false;\n    returnedString = print_expr(p);\n    returnedString = returnedString.replace(/_/g, \"\\\\_\");\n    printMode = origPrintMode;\n    codeGen = originalCodeGen;\n\n    if (DEBUG) {\n      console.log(\"emttedString from collectLatexStringFromReturnValue: \" + stringsEmittedByUserPrintouts);\n    }\n\n    return returnedString;\n  };\n\n  printline = function printline(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(p);\n    return accumulator;\n  };\n\n  print_base_of_denom = function print_base_of_denom(p1) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (isfraction(p1) || car(p1) === symbol(ADD) || car(p1) === symbol(MULTIPLY) || car(p1) === symbol(POWER) || lessp(p1, zero)) {\n      accumulator += print_char('(');\n      accumulator += print_expr(p1);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p1);\n    }\n\n    return accumulator;\n  };\n\n  print_expo_of_denom = function print_expo_of_denom(p2) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (isfraction(p2) || car(p2) === symbol(ADD) || car(p2) === symbol(MULTIPLY) || car(p2) === symbol(POWER)) {\n      accumulator += print_char('(');\n      accumulator += print_expr(p2);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p2);\n    }\n\n    return accumulator;\n  };\n\n  print_denom = function print_denom(p, d) {\n    var accumulator;\n    accumulator = \"\";\n    save();\n    p1 = cadr(p);\n    p2 = caddr(p);\n\n    if (isminusone(p2)) {\n      accumulator += print_base_of_denom(p1);\n      restore();\n      return accumulator;\n    }\n\n    if (d === 1) {\n      accumulator += print_char('(');\n    }\n\n    push(p2);\n    negate();\n    p2 = pop();\n    accumulator += _print_power(p1, p2);\n\n    if (d === 1) {\n      accumulator += print_char(')');\n    }\n\n    restore();\n    return accumulator;\n  };\n\n  print_a_over_b = function print_a_over_b(p) {\n    var accumulator, d, doNothing, n;\n    accumulator = \"\";\n    flag = 0;\n    n = 0;\n    d = 0;\n    save();\n    n = 0;\n    d = 0;\n    p1 = cdr(p);\n    p2 = car(p1);\n\n    if (isrational(p2)) {\n      push(p2);\n      mp_numerator();\n\n      _absval();\n\n      p3 = pop();\n      push(p2);\n      mp_denominator();\n      p4 = pop();\n\n      if (!isplusone(p3)) {\n        n++;\n      }\n\n      if (!isplusone(p4)) {\n        d++;\n      }\n\n      p1 = cdr(p1);\n    } else {\n      p3 = one;\n      p4 = one;\n    }\n\n    while (iscons(p1)) {\n      p2 = car(p1);\n\n      if (is_denominator(p2)) {\n        d++;\n      } else {\n        n++;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('\\\\frac{');\n    }\n\n    if (n === 0) {\n      accumulator += print_char('1');\n    } else {\n      flag = 0;\n      p1 = cdr(p);\n\n      if (isrational(car(p1))) {\n        p1 = cdr(p1);\n      }\n\n      if (!isplusone(p3)) {\n        accumulator += _print_factor(p3);\n        flag = 1;\n      }\n\n      while (iscons(p1)) {\n        p2 = car(p1);\n\n        if (is_denominator(p2)) {\n          doNothing = 1;\n        } else {\n          if (flag) {\n            accumulator += print_multiply_sign();\n          }\n\n          accumulator += _print_factor(p2);\n          flag = 1;\n        }\n\n        p1 = cdr(p1);\n      }\n    }\n\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}{');\n    } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n      accumulator += print_str(\" / \");\n    } else {\n      accumulator += print_str(\"/\");\n    }\n\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char('(');\n    }\n\n    flag = 0;\n    p1 = cdr(p);\n\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n\n    if (!isplusone(p4)) {\n      accumulator += _print_factor(p4);\n      flag = 1;\n    }\n\n    while (iscons(p1)) {\n      p2 = car(p1);\n\n      if (is_denominator(p2)) {\n        if (flag) {\n          accumulator += print_multiply_sign();\n        }\n\n        accumulator += print_denom(p2, d);\n        flag = 1;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char(')');\n    }\n\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}');\n    }\n\n    restore();\n    return accumulator;\n  };\n\n  print_expr = function print_expr(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (isadd(p)) {\n      p = cdr(p);\n\n      if (sign_of_term(car(p)) === '-') {\n        accumulator += print_str(\"-\");\n      }\n\n      accumulator += print_term(car(p));\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (sign_of_term(car(p)) === '+') {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" + \");\n          } else {\n            accumulator += print_str(\"+\");\n          }\n        } else {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" - \");\n          } else {\n            accumulator += print_str(\"-\");\n          }\n        }\n\n        accumulator += print_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (sign_of_term(p) === '-') {\n        accumulator += print_str(\"-\");\n      }\n\n      accumulator += print_term(p);\n    }\n\n    return accumulator;\n  };\n\n  sign_of_term = function sign_of_term(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && lessp(cadr(p), zero)) {\n      accumulator += '-';\n    } else if (isNumericAtom(p) && lessp(p, zero)) {\n      accumulator += '-';\n    } else {\n      accumulator += '+';\n    }\n\n    return accumulator;\n  };\n\n  print_term = function print_term(p) {\n    var accumulator, denom, numberOneOverSomething, origAccumulator, previousFactorWasANumber;\n    accumulator = \"\";\n\n    if (car(p) === symbol(MULTIPLY) && any_denominators(p)) {\n      accumulator += print_a_over_b(p);\n      return accumulator;\n    }\n\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n\n      if (isminusone(car(p))) {\n        p = cdr(p);\n      }\n\n      previousFactorWasANumber = false;\n\n      if (isNumericAtom(car(p))) {\n        previousFactorWasANumber = true;\n      }\n\n      numberOneOverSomething = false;\n\n      if (printMode === PRINTMODE_LATEX && iscons(cdr(p)) && isNumberOneOverSomething(car(p))) {\n        numberOneOverSomething = true;\n        denom = car(p).q.b.toString();\n      }\n\n      if (numberOneOverSomething) {\n        origAccumulator = accumulator;\n        accumulator = \"\";\n      } else {\n        accumulator += _print_factor(car(p));\n      }\n\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (printMode === PRINTMODE_LATEX) {\n          if (previousFactorWasANumber) {\n            if (caar(p) === symbol(POWER)) {\n              if (isNumericAtom(car(cdr(car(p))))) {\n                if (!isfraction(car(cdr(cdr(car(p)))))) {\n                  accumulator += \" \\\\cdot \";\n                }\n              }\n            }\n          }\n        }\n\n        accumulator += print_multiply_sign();\n        accumulator += _print_factor(car(p));\n        previousFactorWasANumber = false;\n\n        if (isNumericAtom(car(p))) {\n          previousFactorWasANumber = true;\n        }\n\n        p = cdr(p);\n      }\n\n      if (numberOneOverSomething) {\n        accumulator = origAccumulator + \"\\\\frac{\" + accumulator + \"}{\" + denom + \"}\";\n      }\n    } else {\n      accumulator += _print_factor(p);\n    }\n\n    return accumulator;\n  };\n\n  print_subexpr = function print_subexpr(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_char('(');\n    accumulator += print_expr(p);\n    accumulator += print_char(')');\n    return accumulator;\n  };\n\n  print_factorial_function = function print_factorial_function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cadr(p);\n\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(p);\n    } else {\n      accumulator += print_expr(p);\n    }\n\n    accumulator += print_char('!');\n    return accumulator;\n  };\n\n  print_ABS_latex = function print_ABS_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\left |\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\right |\");\n    return accumulator;\n  };\n\n  print_BINOMIAL_latex = function print_BINOMIAL_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\binom{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"}{\");\n    accumulator += print_expr(caddr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_DOT_latex = function print_DOT_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\cdot \");\n    accumulator += print_expr(caddr(p));\n    return accumulator;\n  };\n\n  print_DOT_codegen = function print_DOT_codegen(p) {\n    var accumulator;\n    accumulator = \"dot(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \", \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SIN_codegen = function print_SIN_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.sin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_COS_codegen = function print_COS_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.cos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_TAN_codegen = function print_TAN_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.tan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCSIN_codegen = function print_ARCSIN_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.asin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCCOS_codegen = function print_ARCCOS_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.acos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCTAN_codegen = function print_ARCTAN_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.atan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SQRT_latex = function print_SQRT_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\sqrt{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_latex = function print_TRANSPOSE_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n\n    accumulator += print_expr(cadr(p));\n\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^T\");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_codegen = function print_TRANSPOSE_codegen(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"transpose(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_UNIT_codegen = function print_UNIT_codegen(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"identity(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_INV_latex = function print_INV_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n\n    accumulator += print_expr(cadr(p));\n\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^{-1}\");\n    return accumulator;\n  };\n\n  print_INV_codegen = function print_INV_codegen(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"inv(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_DEFINT_latex = function print_DEFINT_latex(p) {\n    var accumulator, functionBody, i, i1, numberOfIntegrals, originalIntegral, ref1, theIntegral, theVariable;\n    accumulator = \"\";\n    functionBody = car(cdr(p));\n    p = cdr(p);\n    originalIntegral = p;\n    numberOfIntegrals = 0;\n\n    while (iscons(cdr(cdr(p)))) {\n      numberOfIntegrals++;\n      theIntegral = cdr(cdr(p));\n      accumulator += print_str(\"\\\\int^{\");\n      accumulator += print_expr(car(cdr(theIntegral)));\n      accumulator += print_str(\"}_{\");\n      accumulator += print_expr(car(theIntegral));\n      accumulator += print_str(\"} \\\\! \");\n      p = cdr(theIntegral);\n    }\n\n    accumulator += print_expr(functionBody);\n    accumulator += print_str(\" \\\\,\");\n    p = originalIntegral;\n\n    for (i = i1 = 1, ref1 = numberOfIntegrals; 1 <= ref1 ? i1 <= ref1 : i1 >= ref1; i = 1 <= ref1 ? ++i1 : --i1) {\n      theVariable = cdr(p);\n      accumulator += print_str(\" \\\\mathrm{d} \");\n      accumulator += print_expr(car(theVariable));\n\n      if (i < numberOfIntegrals) {\n        accumulator += print_str(\" \\\\, \");\n      }\n\n      p = cdr(cdr(theVariable));\n    }\n\n    return accumulator;\n  };\n\n  print_tensor = function print_tensor(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += _print_tensor_inner(p, 0, 0)[1];\n    return accumulator;\n  };\n\n  _print_tensor_inner = function print_tensor_inner(p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, ref3, retString;\n    accumulator = \"\";\n    accumulator += print_str(\"[\");\n\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        ref2 = _print_tensor_inner(p, j + 1, k), k = ref2[0], retString = ref2[1];\n        accumulator += retString;\n\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n      }\n    } else {\n      for (i = j1 = 0, ref3 = p.tensor.dim[j]; 0 <= ref3 ? j1 < ref3 : j1 > ref3; i = 0 <= ref3 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n\n        k++;\n      }\n    }\n\n    accumulator += print_str(\"]\");\n    return [k, accumulator];\n  };\n\n  print_tensor_latex = function print_tensor_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (p.tensor.ndim <= 2) {\n      accumulator += _print_tensor_inner_latex(true, p, 0, 0)[1];\n    }\n\n    return accumulator;\n  };\n\n  _print_tensor_inner_latex = function print_tensor_inner_latex(firstLevel, p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, ref3, retString;\n    accumulator = \"\";\n\n    if (firstLevel) {\n      accumulator += \"\\\\begin{bmatrix} \";\n    }\n\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        ref2 = _print_tensor_inner_latex(0, p, j + 1, k), k = ref2[0], retString = ref2[1];\n        accumulator += retString;\n\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\" \\\\\\\\ \");\n        }\n      }\n    } else {\n      for (i = j1 = 0, ref3 = p.tensor.dim[j]; 0 <= ref3 ? j1 < ref3 : j1 > ref3; i = 0 <= ref3 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\" & \");\n        }\n\n        k++;\n      }\n    }\n\n    if (firstLevel) {\n      accumulator += \" \\\\end{bmatrix}\";\n    }\n\n    return [k, accumulator];\n  };\n\n  print_SUM_latex = function print_SUM_latex(p) {\n    var accumulator;\n    accumulator = \"\\\\sum_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_SUM_codegen = function print_SUM_codegen(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderSum = 0; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderSum += \" + print_expr(body) + \";\" + \" } \" + \" return holderSum;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_TEST_latex = function print_TEST_latex(p) {\n    var accumulator;\n    accumulator = \"\\\\left\\\\{ \\\\begin{array}{ll}\";\n    p = cdr(p);\n\n    while (iscons(p)) {\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"{\";\n        accumulator += print_expr(car(p));\n        accumulator += \"} & otherwise \";\n        accumulator += \" \\\\\\\\\\\\\\\\\";\n        break;\n      }\n\n      accumulator += \"{\";\n      accumulator += print_expr(cadr(p));\n      accumulator += \"} & if & \";\n      accumulator += print_expr(car(p));\n      accumulator += \" \\\\\\\\\\\\\\\\\";\n      p = cddr(p);\n    }\n\n    accumulator = accumulator.substring(0, accumulator.length - 4);\n    return accumulator += \"\\\\end{array} \\\\right.\";\n  };\n\n  print_TEST_codegen = function print_TEST_codegen(p) {\n    var accumulator, howManyIfs;\n    accumulator = \"(function(){\";\n    p = cdr(p);\n    howManyIfs = 0;\n\n    while (iscons(p)) {\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"else {\";\n        accumulator += \"return (\" + print_expr(car(p)) + \");\";\n        accumulator += \"}\";\n        break;\n      }\n\n      if (howManyIfs) {\n        accumulator += \" else \";\n      }\n\n      accumulator += \"if (\" + print_expr(car(p)) + \"){\";\n      accumulator += \"return (\" + print_expr(cadr(p)) + \");\";\n      accumulator += \"}\";\n      howManyIfs++;\n      p = cddr(p);\n    }\n\n    accumulator += \"})()\";\n    return accumulator;\n  };\n\n  print_TESTLT_latex = function print_TESTLT_latex(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" < \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTLE_latex = function print_TESTLE_latex(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\leq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGT_latex = function print_TESTGT_latex(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" > \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGE_latex = function print_TESTGE_latex(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\geq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTEQ_latex = function print_TESTEQ_latex(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" = \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_FOR_codegen = function print_FOR_codegen(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   \" + print_expr(body) + \" } \" + \"})()\";\n    return accumulator;\n  };\n\n  print_DO_codegen = function print_DO_codegen(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n\n    while (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n    }\n\n    return accumulator;\n  };\n\n  print_SETQ_codegen = function print_SETQ_codegen(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \" = \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"; \";\n    return accumulator;\n  };\n\n  print_PRODUCT_latex = function print_PRODUCT_latex(p) {\n    var accumulator;\n    accumulator = \"\\\\prod_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_PRODUCT_codegen = function print_PRODUCT_codegen(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderProduct = 1; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderProduct *= \" + print_expr(body) + \";\" + \" } \" + \" return holderProduct;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_base = function print_base(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (isadd(cadr(p)) || caadr(p) === symbol(MULTIPLY) || caadr(p) === symbol(POWER) || isnegativenumber(cadr(p))) {\n      accumulator += print_str('(');\n      accumulator += print_expr(cadr(p));\n      accumulator += print_str(')');\n    } else if (isNumericAtom(cadr(p)) && (lessp(cadr(p), zero) || isfraction(cadr(p)))) {\n      accumulator += print_str('(');\n      accumulator += _print_factor(cadr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += _print_factor(cadr(p));\n    }\n\n    return accumulator;\n  };\n\n  print_exponent = function print_exponent(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (iscons(caddr(p)) || isfraction(caddr(p)) || isNumericAtom(caddr(p)) && lessp(caddr(p), zero)) {\n      accumulator += print_str('(');\n      accumulator += print_expr(caddr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += _print_factor(caddr(p));\n    }\n\n    return accumulator;\n  };\n\n  _print_power = function print_power(base, exponent) {\n    var accumulator, denomExponent, newExponent, numExponent;\n    accumulator = \"\";\n\n    if (DEBUG) {\n      console.log(\"power base: \" + base + \" \" + \" exponent: \" + exponent);\n    }\n\n    if (isoneovertwo(exponent)) {\n      if (equaln(base, 2)) {\n        if (codeGen) {\n          accumulator += print_str(\"Math.SQRT2\");\n          return accumulator;\n        }\n      } else {\n        if (printMode === PRINTMODE_LATEX) {\n          accumulator += print_str(\"\\\\sqrt{\");\n          accumulator += print_expr(base);\n          accumulator += print_str(\"}\");\n          return accumulator;\n        } else if (codeGen) {\n          accumulator += print_str(\"Math.sqrt(\");\n          accumulator += print_expr(base);\n          accumulator += print_str(')');\n          return accumulator;\n        }\n      }\n    }\n\n    if (equaln(get_binding(symbol(PRINT_LEAVE_E_ALONE)), 1) && base === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.exp(\");\n        accumulator += print_expo_of_denom(exponent);\n        accumulator += print_str(')');\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"e^{\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(\"}\");\n      } else {\n        accumulator += print_str(\"exp(\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      }\n\n      return accumulator;\n    }\n\n    if (codeGen) {\n      accumulator += print_str(\"Math.pow(\");\n      accumulator += print_base_of_denom(base);\n      accumulator += print_str(\", \");\n      accumulator += print_expo_of_denom(exponent);\n      accumulator += print_str(')');\n      return accumulator;\n    }\n\n    if (equaln(get_binding(symbol(PRINT_LEAVE_X_ALONE)), 0) || base.printname !== \"x\") {\n      if (base !== symbol(E)) {\n        if (isminusone(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += print_expr(base);\n            accumulator += print_str(')');\n          } else {\n            accumulator += print_expr(base);\n          }\n\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n\n          return accumulator;\n        }\n\n        if (isnegativeterm(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n\n          push(exponent);\n          push_integer(-1);\n          multiply();\n          newExponent = pop();\n\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += _print_power(base, newExponent);\n            accumulator += print_str(')');\n          } else {\n            accumulator += _print_power(base, newExponent);\n          }\n\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n\n          return accumulator;\n        }\n      }\n\n      if (isfraction(exponent) && printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\sqrt\");\n        push(exponent);\n\n        _denominator();\n\n        denomExponent = pop();\n\n        if (!isplustwo(denomExponent)) {\n          accumulator += print_str(\"[\");\n          accumulator += print_expr(denomExponent);\n          accumulator += print_str(\"]\");\n        }\n\n        accumulator += print_str(\"{\");\n        push(exponent);\n\n        _numerator();\n\n        numExponent = pop();\n        exponent = numExponent;\n        accumulator += _print_power(base, exponent);\n        accumulator += print_str(\"}\");\n        return accumulator;\n      }\n    }\n\n    if (printMode === PRINTMODE_LATEX && isplusone(exponent)) {\n      accumulator += print_expr(base);\n    } else {\n      if (isadd(base) || isnegativenumber(base)) {\n        accumulator += print_str('(');\n        accumulator += print_expr(base);\n        accumulator += print_str(')');\n      } else if (car(base) === symbol(MULTIPLY) || car(base) === symbol(POWER)) {\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str('(');\n        }\n\n        accumulator += _print_factor(base, true);\n\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str(')');\n        }\n      } else if (isNumericAtom(base) && (lessp(base, zero) || isfraction(base))) {\n        accumulator += print_str('(');\n        accumulator += _print_factor(base);\n        accumulator += print_str(')');\n      } else {\n        accumulator += _print_factor(base);\n      }\n\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        accumulator += print_str(power_str);\n      } else {\n        accumulator += print_str(\"^\");\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        if (print_expr(exponent).length > 1) {\n          accumulator += print_str(\"{\");\n          accumulator += print_expr(exponent);\n          accumulator += print_str(\"}\");\n        } else {\n          accumulator += print_expr(exponent);\n        }\n      } else if (iscons(exponent) || isfraction(exponent) || isNumericAtom(exponent) && lessp(exponent, zero)) {\n        accumulator += print_str('(');\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      } else {\n        accumulator += _print_factor(exponent);\n      }\n    }\n\n    return accumulator;\n  };\n\n  print_index_function = function print_index_function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(car(p));\n    } else {\n      accumulator += print_expr(car(p));\n    }\n\n    accumulator += print_str('[');\n    p = cdr(p);\n\n    if (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n\n      while (iscons(p)) {\n        accumulator += print_str(',');\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n      }\n    }\n\n    accumulator += print_str(']');\n    return accumulator;\n  };\n\n  _print_factor = function print_factor(p, omitParens) {\n    var accumulator, base, exponent, fbody, parameters, returned;\n    accumulator = \"\";\n\n    if (isNumericAtom(p)) {\n      accumulator += print_number(p, false);\n      return accumulator;\n    }\n\n    if (isstr(p)) {\n      accumulator += print_str(\"\\\"\");\n      accumulator += print_str(p.str);\n      accumulator += print_str(\"\\\"\");\n      return accumulator;\n    }\n\n    if (istensor(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_tensor_latex(p);\n      } else {\n        accumulator += print_tensor(p);\n      }\n\n      return accumulator;\n    }\n\n    if (car(p) === symbol(MULTIPLY)) {\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\left (\");\n          } else {\n            accumulator += print_str('(');\n          }\n        }\n      }\n\n      accumulator += print_expr(p);\n\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\right ) \");\n          } else {\n            accumulator += print_str(')');\n          }\n        }\n      }\n\n      return accumulator;\n    } else if (isadd(p)) {\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n\n      accumulator += print_expr(p);\n\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n\n      return accumulator;\n    }\n\n    if (car(p) === symbol(POWER)) {\n      base = cadr(p);\n      exponent = caddr(p);\n      accumulator += _print_power(base, exponent);\n      return accumulator;\n    }\n\n    if (car(p) === symbol(FUNCTION)) {\n      fbody = cadr(p);\n\n      if (!codeGen) {\n        parameters = caddr(p);\n        accumulator += print_str(\"function \");\n\n        if (DEBUG) {\n          console.log(\"emittedString from print_factor \" + stringsEmittedByUserPrintouts);\n        }\n\n        returned = _print_list(parameters);\n        accumulator += returned;\n        accumulator += print_str(\" -> \");\n      }\n\n      accumulator += print_expr(fbody);\n      return accumulator;\n    }\n\n    if (car(p) === symbol(PATTERN)) {\n      accumulator += print_expr(caadr(p));\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\" \\\\rightarrow \");\n      } else {\n        if (printMode === PRINTMODE_HUMAN && !test_flag) {\n          accumulator += print_str(\" -> \");\n        } else {\n          accumulator += print_str(\"->\");\n        }\n      }\n\n      accumulator += print_expr(car(cdr(cadr(p))));\n      return accumulator;\n    }\n\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      accumulator += print_index_function(p);\n      return accumulator;\n    }\n\n    if (car(p) === symbol(FACTORIAL)) {\n      accumulator += print_factorial_function(p);\n      return accumulator;\n    } else if (car(p) === symbol(ABS) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_ABS_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(SQRT) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_SQRT_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(TRANSPOSE)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TRANSPOSE_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_TRANSPOSE_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(UNIT)) {\n      if (codeGen) {\n        accumulator += print_UNIT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(INV)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_INV_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_INV_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(BINOMIAL) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_BINOMIAL_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(DEFINT) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_DEFINT_latex(p);\n      return accumulator;\n    } else if (isinnerordot(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_DOT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_DOT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SIN)) {\n      if (codeGen) {\n        accumulator += print_SIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(COS)) {\n      if (codeGen) {\n        accumulator += print_COS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TAN)) {\n      if (codeGen) {\n        accumulator += print_TAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCSIN)) {\n      if (codeGen) {\n        accumulator += print_ARCSIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCCOS)) {\n      if (codeGen) {\n        accumulator += print_ARCCOS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCTAN)) {\n      if (codeGen) {\n        accumulator += print_ARCTAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SUM)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_SUM_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_SUM_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(PRODUCT)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_PRODUCT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_PRODUCT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FOR)) {\n      if (codeGen) {\n        accumulator += print_FOR_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(DO)) {\n      if (codeGen) {\n        accumulator += print_DO_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TEST)) {\n      if (codeGen) {\n        accumulator += print_TEST_codegen(p);\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TEST_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") < (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") <= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") > (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") >= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTEQ)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") === (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTEQ_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FLOOR)) {\n      if (codeGen) {\n        accumulator += \"Math.floor(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lfloor {\" + print_expr(cadr(p)) + \"} \\\\rfloor \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(CEILING)) {\n      if (codeGen) {\n        accumulator += \"Math.ceiling(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lceil {\" + print_expr(cadr(p)) + \"} \\\\rceil \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ROUND)) {\n      if (codeGen) {\n        accumulator += \"Math.round(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SETQ)) {\n      if (codeGen) {\n        accumulator += print_SETQ_codegen(p);\n        return accumulator;\n      } else {\n        accumulator += print_expr(cadr(p));\n        accumulator += print_str(\"=\");\n        accumulator += print_expr(caddr(p));\n        return accumulator;\n      }\n    }\n\n    if (iscons(p)) {\n      accumulator += _print_factor(car(p));\n      p = cdr(p);\n\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n\n      if (iscons(p)) {\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n\n        while (iscons(p)) {\n          accumulator += print_str(\",\");\n          accumulator += print_expr(car(p));\n          p = cdr(p);\n        }\n      }\n\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n\n      return accumulator;\n    }\n\n    if (p === symbol(DERIVATIVE)) {\n      accumulator += print_char('d');\n    } else if (p === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.E\");\n      } else {\n        accumulator += print_str(\"e\");\n      }\n    } else if (p === symbol(PI)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\pi\");\n      } else {\n        accumulator += print_str(\"pi\");\n      }\n    } else {\n      accumulator += print_str(get_printname(p));\n    }\n\n    return accumulator;\n  };\n\n  _print_list = function print_list(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    switch (p.k) {\n      case CONS:\n        accumulator += '(';\n        accumulator += _print_list(car(p));\n\n        if (p === cdr(p) && p !== symbol(NIL)) {\n          console.log(\"oh no recursive!\");\n          debugger;\n        }\n\n        p = cdr(p);\n\n        while (iscons(p)) {\n          accumulator += \" \";\n          accumulator += _print_list(car(p));\n          p = cdr(p);\n\n          if (p === cdr(p) && p !== symbol(NIL)) {\n            console.log(\"oh no recursive!\");\n            debugger;\n          }\n        }\n\n        if (p !== symbol(NIL)) {\n          accumulator += \" . \";\n          accumulator += _print_list(p);\n        }\n\n        accumulator += ')';\n        break;\n\n      case STR:\n        accumulator += p.str;\n        break;\n\n      case NUM:\n      case DOUBLE:\n        accumulator += print_number(p, true);\n        break;\n\n      case SYM:\n        accumulator += get_printname(p);\n        break;\n\n      default:\n        accumulator += \"<tensor>\";\n    }\n\n    return accumulator;\n  };\n\n  print_multiply_sign = function print_multiply_sign() {\n    var accumulator;\n    accumulator = \"\";\n\n    if (printMode === PRINTMODE_LATEX) {\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        accumulator += print_str(\" \");\n      } else {\n        return accumulator;\n      }\n    }\n\n    if (printMode === PRINTMODE_HUMAN && !test_flag && !codeGen) {\n      accumulator += print_str(\" \");\n    } else {\n      accumulator += print_str(\"*\");\n    }\n\n    return accumulator;\n  };\n\n  is_denominator = function is_denominator(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && isnegativeterm(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  any_denominators = function any_denominators(p) {\n    var q;\n    p = cdr(p);\n\n    while (iscons(p)) {\n      q = car(p);\n\n      if (is_denominator(q)) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n  /*\n  \n  Prints in \"2d\", e.g. instead of 1/(x+1)^2 :\n  \n        1\n   ----------\n           2\n    (1 + x)\n  \n   Note that although this looks more natural, a) it's not parsable and\n   b) it can be occasionally be ambiguous, such as:\n  \n     1\n   ----\n     2\n   x\n  \n  is 1/x^2 but it also looks a little like x^(1/2)\n   */\n\n\n  YMAX = 10000;\n\n  glyph = function () {\n    function glyph() {}\n\n    glyph.prototype.c = 0;\n    glyph.prototype.x = 0;\n    glyph.prototype.y = 0;\n    return glyph;\n  }();\n\n  chartab = [];\n\n  for (charTabIndex = i1 = 0, ref1 = YMAX; 0 <= ref1 ? i1 < ref1 : i1 > ref1; charTabIndex = 0 <= ref1 ? ++i1 : --i1) {\n    chartab[charTabIndex] = new glyph();\n  }\n\n  yindex = 0;\n  level = 0;\n  emit_x = 0;\n  expr_level = 0;\n  display_flag = 0;\n\n  printchar_nowrap = function printchar_nowrap(character) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += character;\n    return accumulator;\n  };\n\n  printchar = function printchar(character) {\n    return printchar_nowrap(character);\n  };\n\n  print2dascii = function print2dascii(p) {\n    var beenPrinted, h, ref2, w, y;\n    h = 0;\n    w = 0;\n    y = 0;\n    save();\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_top_expr(p);\n    ref2 = get_size(0, yindex), h = ref2[0], w = ref2[1], y = ref2[2];\n\n    if (w > 100) {\n      printline(p);\n      restore();\n      return;\n    }\n\n    beenPrinted = print_glyphs();\n    restore();\n    return beenPrinted;\n  };\n\n  emit_top_expr = function emit_top_expr(p) {\n    if (car(p) === symbol(SETQ)) {\n      emit_expr(cadr(p));\n\n      __emit_str(\" = \");\n\n      emit_expr(caddr(p));\n      return;\n    }\n\n    if (istensor(p)) {\n      return emit_tensor(p);\n    } else {\n      return emit_expr(p);\n    }\n  };\n\n  will_be_displayed_as_fraction = function will_be_displayed_as_fraction(p) {\n    if (level > 0) {\n      return 0;\n    }\n\n    if (isfraction(p)) {\n      return 1;\n    }\n\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n\n    if (isfraction(cadr(p))) {\n      return 1;\n    }\n\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n\n  emit_expr = function emit_expr(p) {\n    expr_level++;\n\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n\n      if (__is_negative(car(p))) {\n        __emit_char('-');\n\n        if (will_be_displayed_as_fraction(car(p))) {\n          __emit_char(' ');\n        }\n      }\n\n      emit_term(car(p));\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n\n          __emit_char('-');\n\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n\n          __emit_char('+');\n\n          __emit_char(' ');\n        }\n\n        emit_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (__is_negative(p)) {\n        __emit_char('-');\n\n        if (will_be_displayed_as_fraction(p)) {\n          __emit_char(' ');\n        }\n      }\n\n      emit_term(p);\n    }\n\n    return expr_level--;\n  };\n\n  emit_unsigned_expr = function emit_unsigned_expr(p) {\n    var results;\n\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      emit_term(car(p));\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n\n          __emit_char('-');\n\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n\n          __emit_char('+');\n\n          __emit_char(' ');\n        }\n\n        emit_term(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else {\n      return emit_term(p);\n    }\n  };\n\n  __is_negative = function __is_negative(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    }\n\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  emit_term = function emit_term(p) {\n    var n;\n\n    if (car(p) === symbol(MULTIPLY)) {\n      n = count_denominators(p);\n\n      if (n && level === 0) {\n        return emit_fraction(p, n);\n      } else {\n        return emit_multiply(p, n);\n      }\n    } else {\n      return emit_factor(p);\n    }\n  };\n\n  isdenominator = function isdenominator(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && __is_negative(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  count_denominators = function count_denominators(p) {\n    var count, q;\n    count = 0;\n    p = cdr(p);\n\n    while (iscons(p)) {\n      q = car(p);\n\n      if (isdenominator(q)) {\n        count++;\n      }\n\n      p = cdr(p);\n    }\n\n    return count;\n  };\n\n  emit_multiply = function emit_multiply(p, n) {\n    var results;\n\n    if (n === 0) {\n      p = cdr(p);\n\n      if (isplusone(car(p)) || isminusone(car(p))) {\n        p = cdr(p);\n      }\n\n      emit_factor(car(p));\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        __emit_char(' ');\n\n        emit_factor(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else {\n      emit_numerators(p);\n\n      __emit_char('/');\n\n      if (n > 1 || isfraction(cadr(p))) {\n        __emit_char('(');\n\n        emit_denominators(p);\n        return __emit_char(')');\n      } else {\n        return emit_denominators(p);\n      }\n    }\n  };\n\n  emit_fraction = function emit_fraction(p, d) {\n    var count, doNothing, k1, k2, n, x;\n    count = 0;\n    k1 = 0;\n    k2 = 0;\n    n = 0;\n    x = 0;\n    save();\n    p3 = one;\n    p4 = one;\n\n    if (isrational(cadr(p))) {\n      push(cadr(p));\n      mp_numerator();\n\n      _absval();\n\n      p3 = pop();\n      push(cadr(p));\n      mp_denominator();\n      p4 = pop();\n    }\n\n    if (isdouble(cadr(p))) {\n      push(cadr(p));\n\n      _absval();\n\n      p3 = pop();\n    }\n\n    if (isplusone(p3)) {\n      n = 0;\n    } else {\n      n = 1;\n    }\n\n    p1 = cdr(p);\n\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n\n    while (iscons(p1)) {\n      p2 = car(p1);\n\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        n++;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    x = emit_x;\n    k1 = yindex;\n    count = 0;\n\n    if (!isplusone(p3)) {\n      emit_number(p3, 0);\n      count++;\n    }\n\n    p1 = cdr(p);\n\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n\n    while (iscons(p1)) {\n      p2 = car(p1);\n\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n\n        if (n === 1) {\n          emit_expr(p2);\n        } else {\n          emit_factor(p2);\n        }\n\n        count++;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    if (count === 0) {\n      __emit_char('1');\n    }\n\n    k2 = yindex;\n    count = 0;\n\n    if (!isplusone(p4)) {\n      emit_number(p4, 0);\n      count++;\n      d++;\n    }\n\n    p1 = cdr(p);\n\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n\n    while (iscons(p1)) {\n      p2 = car(p1);\n\n      if (isdenominator(p2)) {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n\n        emit_denominator(p2, d);\n        count++;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  emit_numerators = function emit_numerators(p) {\n    var doNothing, n;\n    save();\n    n = 0;\n    p1 = one;\n    p = cdr(p);\n\n    if (isrational(car(p))) {\n      push(car(p));\n      mp_numerator();\n\n      _absval();\n\n      p1 = pop();\n      p = cdr(p);\n    } else if (isdouble(car(p))) {\n      push(car(p));\n\n      _absval();\n\n      p1 = pop();\n      p = cdr(p);\n    }\n\n    n = 0;\n\n    if (!isplusone(p1)) {\n      emit_number(p1, 0);\n      n++;\n    }\n\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        doNothing = 1;\n      } else {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n\n        emit_factor(car(p));\n        n++;\n      }\n\n      p = cdr(p);\n    }\n\n    if (n === 0) {\n      __emit_char('1');\n    }\n\n    return restore();\n  };\n\n  emit_denominators = function emit_denominators(p) {\n    var n;\n    save();\n    n = 0;\n    p = cdr(p);\n\n    if (isfraction(car(p))) {\n      push(car(p));\n      mp_denominator();\n      p1 = pop();\n      emit_number(p1, 0);\n      n++;\n      p = cdr(p);\n    }\n\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n\n        emit_denominator(car(p), 0);\n        n++;\n      }\n\n      p = cdr(p);\n    }\n\n    return restore();\n  };\n\n  emit_factor = function emit_factor(p) {\n    if (istensor(p)) {\n      if (level === 0) {\n        emit_flat_tensor(p);\n      } else {\n        emit_flat_tensor(p);\n      }\n\n      return;\n    }\n\n    if (isdouble(p)) {\n      emit_number(p, 0);\n      return;\n    }\n\n    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY)) {\n      emit_subexpr(p);\n      return;\n    }\n\n    if (car(p) === symbol(POWER)) {\n      emit_power(p);\n      return;\n    }\n\n    if (iscons(p)) {\n      emit_function(p);\n      return;\n    }\n\n    if (isNumericAtom(p)) {\n      if (level === 0) {\n        emit_numerical_fraction(p);\n      } else {\n        emit_number(p, 0);\n      }\n\n      return;\n    }\n\n    if (issymbol(p)) {\n      emit_symbol(p);\n      return;\n    }\n\n    if (isstr(p)) {\n      emit_string(p);\n    }\n  };\n\n  emit_numerical_fraction = function emit_numerical_fraction(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n    save();\n    push(p);\n    mp_numerator();\n\n    _absval();\n\n    p3 = pop();\n    push(p);\n    mp_denominator();\n    p4 = pop();\n\n    if (isplusone(p4)) {\n      emit_number(p3, 0);\n      restore();\n      return;\n    }\n\n    x = emit_x;\n    k1 = yindex;\n    emit_number(p3, 0);\n    k2 = yindex;\n    emit_number(p4, 0);\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  isfactor = function isfactor(p) {\n    if (iscons(p) && car(p) !== symbol(ADD) && car(p) !== symbol(MULTIPLY) && car(p) !== symbol(POWER)) {\n      return 1;\n    }\n\n    if (issymbol(p)) {\n      return 1;\n    }\n\n    if (isfraction(p)) {\n      return 0;\n    }\n\n    if (isnegativenumber(p)) {\n      return 0;\n    }\n\n    if (isNumericAtom(p)) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  emit_power = function emit_power(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n\n    if (cadr(p) === symbol(E)) {\n      __emit_str(\"exp(\");\n\n      emit_expr(caddr(p));\n\n      __emit_char(')');\n\n      return;\n    }\n\n    if (level > 0) {\n      if (isminusone(caddr(p))) {\n        __emit_char('1');\n\n        __emit_char('/');\n\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n      } else {\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n\n        __emit_char('^');\n\n        if (isfactor(caddr(p))) {\n          emit_factor(caddr(p));\n        } else {\n          emit_subexpr(caddr(p));\n        }\n      }\n\n      return;\n    }\n\n    if (__is_negative(caddr(p))) {\n      x = emit_x;\n      k1 = yindex;\n\n      __emit_char('1');\n\n      k2 = yindex;\n      emit_denominator(p, 1);\n      fixup_fraction(x, k1, k2);\n      return;\n    }\n\n    k1 = yindex;\n\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n\n    k2 = yindex;\n    level++;\n    emit_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  emit_denominator = function emit_denominator(p, n) {\n    var k1, k2;\n    k1 = 0;\n    k2 = 0;\n\n    if (isminusone(caddr(p))) {\n      if (n === 1) {\n        emit_expr(cadr(p));\n      } else {\n        emit_factor(cadr(p));\n      }\n\n      return;\n    }\n\n    k1 = yindex;\n\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n\n    k2 = yindex;\n    level++;\n    emit_unsigned_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  emit_function = function emit_function(p) {\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      emit_index_function(p);\n      return;\n    }\n\n    if (car(p) === symbol(FACTORIAL)) {\n      emit_factorial_function(p);\n      return;\n    }\n\n    if (car(p) === symbol(DERIVATIVE)) {\n      __emit_char('d');\n    } else {\n      emit_symbol(car(p));\n    }\n\n    __emit_char('(');\n\n    p = cdr(p);\n\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n\n      while (iscons(p)) {\n        __emit_char(',');\n\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n\n    return __emit_char(')');\n  };\n\n  emit_index_function = function emit_index_function(p) {\n    p = cdr(p);\n\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      emit_subexpr(car(p));\n    } else {\n      emit_expr(car(p));\n    }\n\n    __emit_char('[');\n\n    p = cdr(p);\n\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n\n      while (iscons(p)) {\n        __emit_char(',');\n\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n\n    return __emit_char(']');\n  };\n\n  emit_factorial_function = function emit_factorial_function(p) {\n    p = cadr(p);\n\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      emit_subexpr(p);\n    } else {\n      emit_expr(p);\n    }\n\n    return __emit_char('!');\n  };\n\n  emit_subexpr = function emit_subexpr(p) {\n    __emit_char('(');\n\n    emit_expr(p);\n    return __emit_char(')');\n  };\n\n  emit_symbol = function emit_symbol(p) {\n    var i, j1, pPrintName, ref2, results;\n    i = 0;\n\n    if (p === symbol(E)) {\n      __emit_str(\"exp(1)\");\n\n      return;\n    }\n\n    pPrintName = get_printname(p);\n    results = [];\n\n    for (i = j1 = 0, ref2 = pPrintName.length; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(pPrintName[i]));\n    }\n\n    return results;\n  };\n\n  emit_string = function emit_string(p) {\n    var i, j1, pString, ref2;\n    i = 0;\n    pString = p.str;\n\n    __emit_char('\"');\n\n    for (i = j1 = 0, ref2 = pString.length; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      __emit_char(pString[i]);\n    }\n\n    return __emit_char('\"');\n  };\n\n  fixup_fraction = function fixup_fraction(x, k1, k2) {\n    var dx, dy, h1, h2, i, j1, ref2, ref3, ref4, results, w, w1, w2, y, y1, y2;\n    dx = 0;\n    dy = 0;\n    i = 0;\n    w = 0;\n    y = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    ref2 = get_size(k1, k2), h1 = ref2[0], w1 = ref2[1], y1 = ref2[2];\n    ref3 = get_size(k2, yindex), h2 = ref3[0], w2 = ref3[1], y2 = ref3[2];\n\n    if (w2 > w1) {\n      dx = (w2 - w1) / 2;\n    } else {\n      dx = 0;\n    }\n\n    dx++;\n    y = y1 + h1 - 1;\n    dy = -y - 1;\n    move(k1, k2, dx, dy);\n\n    if (w2 > w1) {\n      dx = -w1;\n    } else {\n      dx = -w1 + (w1 - w2) / 2;\n    }\n\n    dx++;\n    dy = -y2 + 1;\n    move(k2, yindex, dx, dy);\n\n    if (w2 > w1) {\n      w = w2;\n    } else {\n      w = w1;\n    }\n\n    w += 2;\n    emit_x = x;\n    results = [];\n\n    for (i = j1 = 0, ref4 = w; 0 <= ref4 ? j1 < ref4 : j1 > ref4; i = 0 <= ref4 ? ++j1 : --j1) {\n      results.push(__emit_char('-'));\n    }\n\n    return results;\n  };\n\n  fixup_power = function fixup_power(k1, k2) {\n    var dy, h1, h2, ref2, ref3, w1, w2, y1, y2;\n    dy = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    ref2 = get_size(k1, k2), h1 = ref2[0], w1 = ref2[1], y1 = ref2[2];\n    ref3 = get_size(k2, yindex), h2 = ref3[0], w2 = ref3[1], y2 = ref3[2];\n    dy = -y2 - h2 + 1;\n    dy += y1 - 1;\n    return move(k2, yindex, 0, dy);\n  };\n\n  move = function move(j, k, dx, dy) {\n    var i, j1, ref2, ref3, results;\n    i = 0;\n    results = [];\n\n    for (i = j1 = ref2 = j, ref3 = k; ref2 <= ref3 ? j1 < ref3 : j1 > ref3; i = ref2 <= ref3 ? ++j1 : --j1) {\n      chartab[i].x += dx;\n      results.push(chartab[i].y += dy);\n    }\n\n    return results;\n  };\n\n  get_size = function get_size(j, k) {\n    var h, i, j1, max_x, max_y, min_x, min_y, ref2, ref3, w, y;\n    i = 0;\n    min_x = chartab[j].x;\n    max_x = chartab[j].x;\n    min_y = chartab[j].y;\n    max_y = chartab[j].y;\n\n    for (i = j1 = ref2 = j + 1, ref3 = k; ref2 <= ref3 ? j1 < ref3 : j1 > ref3; i = ref2 <= ref3 ? ++j1 : --j1) {\n      if (chartab[i].x < min_x) {\n        min_x = chartab[i].x;\n      }\n\n      if (chartab[i].x > max_x) {\n        max_x = chartab[i].x;\n      }\n\n      if (chartab[i].y < min_y) {\n        min_y = chartab[i].y;\n      }\n\n      if (chartab[i].y > max_y) {\n        max_y = chartab[i].y;\n      }\n    }\n\n    h = max_y - min_y + 1;\n    w = max_x - min_x + 1;\n    y = min_y;\n    return [h, w, y];\n  };\n\n  displaychar = function displaychar(c) {\n    return __emit_char(c);\n  };\n\n  __emit_char = function __emit_char(c) {\n    if (yindex === YMAX) {\n      return;\n    }\n\n    if (chartab[yindex] == null) {\n      debugger;\n    }\n\n    chartab[yindex].c = c;\n    chartab[yindex].x = emit_x;\n    chartab[yindex].y = 0;\n    yindex++;\n    return emit_x++;\n  };\n\n  __emit_str = function __emit_str(s) {\n    var i, j1, ref2, results;\n    i = 0;\n    results = [];\n\n    for (i = j1 = 0, ref2 = s.length; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(s[i]));\n    }\n\n    return results;\n  };\n\n  emit_number = function emit_number(p, emit_sign) {\n    var i, j1, l1, m1, ref2, ref3, ref4, results, results1, tmpString;\n    tmpString = \"\";\n    i = 0;\n\n    switch (p.k) {\n      case NUM:\n        tmpString = p.q.a.toString();\n\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n\n        for (i = j1 = 0, ref2 = tmpString.length; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n          __emit_char(tmpString[i]);\n        }\n\n        tmpString = p.q.b.toString();\n\n        if (tmpString === \"1\") {\n          break;\n        }\n\n        __emit_char('/');\n\n        results = [];\n\n        for (i = l1 = 0, ref3 = tmpString.length; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n          results.push(__emit_char(tmpString[i]));\n        }\n\n        return results;\n        break;\n\n      case DOUBLE:\n        tmpString = doubleToReasonableString(p.d);\n\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n\n        results1 = [];\n\n        for (i = m1 = 0, ref4 = tmpString.length; 0 <= ref4 ? m1 < ref4 : m1 > ref4; i = 0 <= ref4 ? ++m1 : --m1) {\n          results1.push(__emit_char(tmpString[i]));\n        }\n\n        return results1;\n    }\n  };\n\n  cmpGlyphs = function cmpGlyphs(a, b) {\n    if (a.y < b.y) {\n      return -1;\n    }\n\n    if (a.y > b.y) {\n      return 1;\n    }\n\n    if (a.x < b.x) {\n      return -1;\n    }\n\n    if (a.x > b.x) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  print_glyphs = function print_glyphs() {\n    var accumulator, i, j1, ref2, subsetOfStack, x, y;\n    i = 0;\n    accumulator = \"\";\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n\n    for (i = j1 = 0, ref2 = yindex; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        accumulator += printchar('\\n');\n        x = 0;\n        y++;\n      }\n\n      while (chartab[i].x > x) {\n        accumulator += printchar_nowrap(' ');\n        x++;\n      }\n\n      accumulator += printchar_nowrap(chartab[i].c);\n      x++;\n    }\n\n    return accumulator;\n  };\n\n  buffer = \"\";\n\n  getdisplaystr = function getdisplaystr() {\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_expr(pop());\n    fill_buf();\n    return buffer;\n  };\n\n  fill_buf = function fill_buf() {\n    var i, j1, ref2, sIndex, subsetOfStack, tmpBuffer, x, y;\n    tmpBuffer = buffer;\n    sIndex = 0;\n    i = 0;\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n\n    for (i = j1 = 0, ref2 = yindex; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        tmpBuffer[sIndex++] = '\\n';\n        x = 0;\n        y++;\n      }\n\n      while (chartab[i].x > x) {\n        tmpBuffer[sIndex++] = ' ';\n        x++;\n      }\n\n      tmpBuffer[sIndex++] = chartab[i].c;\n      x++;\n    }\n\n    return tmpBuffer[sIndex++] = '\\n';\n  };\n\n  N = 100;\n\n  oneElement = function () {\n    function oneElement() {}\n\n    oneElement.prototype.x = 0;\n    oneElement.prototype.y = 0;\n    oneElement.prototype.h = 0;\n    oneElement.prototype.w = 0;\n    oneElement.prototype.index = 0;\n    oneElement.prototype.count = 0;\n    return oneElement;\n  }();\n\n  elem = [];\n\n  for (elelmIndex = j1 = 0; j1 < 10000; elelmIndex = ++j1) {\n    elem[elelmIndex] = new oneElement();\n  }\n\n  SPACE_BETWEEN_COLUMNS = 3;\n  SPACE_BETWEEN_ROWS = 1;\n\n  emit_tensor = function emit_tensor(p) {\n    var col, dx, dy, eh, ew, h, i, l1, m1, n, n1, ncol, nrow, o1, ref2, ref3, ref4, ref5, ref6, row, w, x, y;\n    i = 0;\n    n = 0;\n    nrow = 0;\n    ncol = 0;\n    x = 0;\n    y = 0;\n    h = 0;\n    w = 0;\n    dx = 0;\n    dy = 0;\n    eh = 0;\n    ew = 0;\n    row = 0;\n    col = 0;\n\n    if (p.tensor.ndim > 2) {\n      emit_flat_tensor(p);\n      return;\n    }\n\n    nrow = p.tensor.dim[0];\n\n    if (p.tensor.ndim === 2) {\n      ncol = p.tensor.dim[1];\n    } else {\n      ncol = 1;\n    }\n\n    n = nrow * ncol;\n\n    if (n > N) {\n      emit_flat_tensor(p);\n      return;\n    }\n\n    x = emit_x;\n\n    for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      elem[i].index = yindex;\n      elem[i].x = emit_x;\n      emit_expr(p.tensor.elem[i]);\n      elem[i].count = yindex - elem[i].index;\n      ref3 = get_size(elem[i].index, yindex), elem[i].h = ref3[0], elem[i].w = ref3[1], elem[i].y = ref3[2];\n    }\n\n    eh = 0;\n    ew = 0;\n\n    for (i = m1 = 0, ref4 = n; 0 <= ref4 ? m1 < ref4 : m1 > ref4; i = 0 <= ref4 ? ++m1 : --m1) {\n      if (elem[i].h > eh) {\n        eh = elem[i].h;\n      }\n\n      if (elem[i].w > ew) {\n        ew = elem[i].w;\n      }\n    }\n\n    h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;\n    w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;\n    y = -(h / 2);\n\n    for (row = n1 = 0, ref5 = nrow; 0 <= ref5 ? n1 < ref5 : n1 > ref5; row = 0 <= ref5 ? ++n1 : --n1) {\n      for (col = o1 = 0, ref6 = ncol; 0 <= ref6 ? o1 < ref6 : o1 > ref6; col = 0 <= ref6 ? ++o1 : --o1) {\n        i = row * ncol + col;\n        dx = x - elem[i].x;\n        dy = y - elem[i].y;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n        dx = 0;\n\n        if (col > 0) {\n          dx = col * (ew + SPACE_BETWEEN_COLUMNS);\n        }\n\n        dy = 0;\n\n        if (row > 0) {\n          dy = row * (eh + SPACE_BETWEEN_ROWS);\n        }\n\n        dx += (ew - elem[i].w) / 2;\n        dy += (eh - elem[i].h) / 2;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n      }\n    }\n\n    return emit_x = x + w;\n    /*\n    if 0\n    \n       * left brace\n    \n      for (i = 0; i < h; i++) {\n        if (yindex == YMAX)\n          break\n        chartab[yindex].c = '|'\n        chartab[yindex].x = x - 2\n        chartab[yindex].y = y + i\n        yindex++\n      }\n    \n       * right brace\n    \n      emit_x++\n    \n      for (i = 0; i < h; i++) {\n        if (yindex == YMAX)\n          break\n        chartab[yindex].c = '|'\n        chartab[yindex].x = emit_x\n        chartab[yindex].y = y + i\n        yindex++\n      }\n    \n      emit_x++\n    \n    endif\n     */\n  };\n\n  emit_flat_tensor = function emit_flat_tensor(p) {\n    return _emit_tensor_inner(p, 0, 0);\n  };\n\n  _emit_tensor_inner = function emit_tensor_inner(p, j, k) {\n    var i, l1, ref2;\n    i = 0;\n\n    __emit_char('(');\n\n    for (i = l1 = 0, ref2 = p.tensor.dim[j]; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (j + 1 === p.tensor.ndim) {\n        emit_expr(p.tensor.elem[k]);\n        k = k + 1;\n      } else {\n        k = _emit_tensor_inner(p, j + 1, k);\n      }\n\n      if (i + 1 < p.tensor.dim[j]) {\n        __emit_char(',');\n      }\n    }\n\n    __emit_char(')');\n\n    return k;\n  };\n\n  Eval_product = function Eval_product() {\n    var body, i, indexVariable, j, k, l1, oldIndexVariableValue, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    body = cadr(p1);\n    indexVariable = caddr(p1);\n\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n\n    oldIndexVariableValue = get_binding(indexVariable);\n    push_integer(1);\n\n    for (i = l1 = ref2 = j, ref3 = k; ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n\n      if (DEBUG) {\n        console.log(\"product - factor 1: \" + stack[tos - 1].toString());\n        console.log(\"product - factor 2: \" + stack[tos - 2].toString());\n      }\n\n      multiply();\n\n      if (DEBUG) {\n        console.log(\"product - result: \" + stack[tos - 1].toString());\n      }\n    }\n\n    return set_binding(indexVariable, oldIndexVariableValue);\n  };\n\n  qadd = function qadd() {\n    var gcdBetweenNumeratorAndDenominator, qadd_ab, qadd_ba, qadd_denominator, qadd_frac1, qadd_frac2, qadd_numerator, resultSum;\n    qadd_frac2 = pop();\n    qadd_frac1 = pop();\n    qadd_ab = mmul(qadd_frac1.q.a, qadd_frac2.q.b);\n    qadd_ba = mmul(qadd_frac1.q.b, qadd_frac2.q.a);\n    qadd_numerator = madd(qadd_ab, qadd_ba);\n\n    if (MZERO(qadd_numerator)) {\n      push(zero);\n      return;\n    }\n\n    qadd_denominator = mmul(qadd_frac1.q.b, qadd_frac2.q.b);\n    gcdBetweenNumeratorAndDenominator = mgcd(qadd_numerator, qadd_denominator);\n    gcdBetweenNumeratorAndDenominator = makeSignSameAs(gcdBetweenNumeratorAndDenominator, qadd_denominator);\n    resultSum = new U();\n    resultSum.k = NUM;\n    resultSum.q.a = mdiv(qadd_numerator, gcdBetweenNumeratorAndDenominator);\n    resultSum.q.b = mdiv(qadd_denominator, gcdBetweenNumeratorAndDenominator);\n    return push(resultSum);\n  };\n\n  qdiv = function qdiv() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (MZERO(p2.q.a)) {\n      stop(\"divide by zero\");\n    }\n\n    if (MZERO(p1.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    aa = mmul(p1.q.a, p2.q.b);\n    bb = mmul(p1.q.b, p2.q.a);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    push(p1);\n    return restore();\n  };\n\n  qmul = function qmul() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (MZERO(p1.q.a) || MZERO(p2.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    aa = mmul(p1.q.a, p2.q.a);\n    bb = mmul(p1.q.b, p2.q.b);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    push(p1);\n    return restore();\n  };\n\n  qpow = function qpow() {\n    save();\n    qpowf();\n    return restore();\n  };\n\n  qpowf = function qpowf() {\n    var a, b, expo, t, x, y;\n    expo = 0;\n    p2 = pop();\n    p1 = pop();\n\n    if (isplusone(p1) || isZeroAtomOrTensor(p2)) {\n      push_integer(1);\n      return;\n    }\n\n    if (isminusone(p1) && isoneovertwo(p2)) {\n      push(imaginaryunit);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      if (isnegativenumber(p2)) {\n        stop(\"divide by zero\");\n      }\n\n      push(zero);\n      return;\n    }\n\n    if (isplusone(p2)) {\n      push(p1);\n      return;\n    }\n\n    if (isinteger(p2)) {\n      push(p2);\n      expo = pop_integer();\n\n      if (isNaN(expo)) {\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n        return;\n      }\n\n      x = mpow(p1.q.a, Math.abs(expo));\n      y = mpow(p1.q.b, Math.abs(expo));\n\n      if (expo < 0) {\n        t = x;\n        x = y;\n        y = t;\n        x = makeSignSameAs(x, y);\n        y = makePositive(y);\n      }\n\n      p3 = new U();\n      p3.k = NUM;\n      p3.q.a = x;\n      p3.q.b = y;\n      push(p3);\n      return;\n    }\n\n    if (isminusone(p1)) {\n      push(p2);\n      normalize_angle();\n      return;\n    }\n\n    if (isnegativenumber(p1)) {\n      push(p1);\n      negate();\n      push(p2);\n      qpow();\n      push_integer(-1);\n      push(p2);\n      qpow();\n      multiply();\n      return;\n    }\n\n    if (!isinteger(p1)) {\n      push(p1);\n      mp_numerator();\n      push(p2);\n      qpow();\n      push(p1);\n      mp_denominator();\n      push(p2);\n      negate();\n      qpow();\n      multiply();\n      return;\n    }\n\n    if (is_small_integer(p1)) {\n      push(p1);\n      push(p2);\n      quickfactor();\n      return;\n    }\n\n    if (!isSmall(p2.q.a) || !isSmall(p2.q.b)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    a = p2.q.a;\n    b = p2.q.b;\n    x = mroot(p1.q.a, b);\n\n    if (x === 0) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    y = mpow(x, a);\n    p3 = new U();\n    p3.k = NUM;\n\n    if (p2.q.a.isNegative()) {\n      p3.q.a = bigInt(1);\n      p3.q.b = y;\n    } else {\n      p3.q.a = y;\n      p3.q.b = bigInt(1);\n    }\n\n    return push(p3);\n  };\n\n  normalize_angle = function normalize_angle() {\n    save();\n    p1 = pop();\n\n    if (isinteger(p1)) {\n      if (p1.q.a.isOdd()) {\n        push_integer(-1);\n      } else {\n        push_integer(1);\n      }\n\n      restore();\n      return;\n    }\n\n    push(p1);\n    bignum_truncate();\n    p2 = pop();\n\n    if (isnegativenumber(p1)) {\n      push(p2);\n      push_integer(-1);\n      add();\n      p2 = pop();\n    }\n\n    push(p1);\n    push(p2);\n    subtract();\n    p3 = pop();\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p3);\n    list(3);\n\n    if (p2.q.a.isOdd()) {\n      negate();\n    }\n\n    return restore();\n  };\n\n  is_small_integer = function is_small_integer(p) {\n    return isSmall(p.q.a);\n  };\n\n  quickfactor = function quickfactor() {\n    var h, i, l1, n, ref2, stackIndex;\n    i = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push(p1);\n    factor_small_number();\n    n = tos - h;\n    stackIndex = h;\n\n    for (i = l1 = 0, ref2 = n; l1 < ref2; i = l1 += 2) {\n      push(stack[stackIndex + i]);\n      push(stack[stackIndex + i + 1]);\n      push(p2);\n      multiply();\n      quickpower();\n    }\n\n    multiply_all(tos - h - n);\n    p1 = pop();\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  quickpower = function quickpower() {\n    var expo;\n    expo = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    bignum_truncate();\n    p3 = pop();\n    push(p2);\n    push(p3);\n    subtract();\n    p4 = pop();\n\n    if (!isZeroAtomOrTensor(p4)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p4);\n      list(3);\n    }\n\n    push(p3);\n    expo = pop_integer();\n\n    if (isNaN(expo)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p3);\n      list(3);\n      restore();\n      return;\n    }\n\n    if (expo === 0) {\n      restore();\n      return;\n    }\n\n    push(p1);\n    bignum_power_number(expo);\n    return restore();\n  };\n\n  Eval_quotient = function Eval_quotient() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p1 = pop();\n\n    if (p1 === symbol(NIL)) {\n      p1 = symbol(SYMBOL_X);\n    }\n\n    push(p1);\n    return divpoly();\n  };\n\n  divpoly = function divpoly() {\n    var dividend, divisor, h, i, l1, m, n, ref2, x;\n    h = 0;\n    i = 0;\n    m = 0;\n    n = 0;\n    x = 0;\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    dividend = tos;\n    push(p1);\n    push(p3);\n    m = coeff() - 1;\n    divisor = tos;\n    push(p2);\n    push(p3);\n    n = coeff() - 1;\n    x = m - n;\n    push_integer(0);\n    p5 = pop();\n\n    while (x >= 0) {\n      push(stack[dividend + m]);\n      push(stack[divisor + n]);\n      divide();\n      p4 = pop();\n\n      for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 <= ref2 : l1 >= ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        push(stack[dividend + x + i]);\n        push(stack[divisor + i]);\n        push(p4);\n        multiply();\n        subtract();\n        stack[dividend + x + i] = pop();\n      }\n\n      push(p5);\n      push(p4);\n      push(p3);\n      push_integer(x);\n      power();\n      multiply();\n      add();\n      p5 = pop();\n      m--;\n      x--;\n    }\n\n    moveTos(h);\n    push(p5);\n    return restore();\n  };\n\n  Eval_rationalize = function Eval_rationalize() {\n    push(cadr(p1));\n    Eval();\n    return rationalize();\n  };\n\n  rationalize = function rationalize() {\n    var x;\n    x = expanding;\n    yyrationalize();\n    return expanding = x;\n  };\n\n  yyrationalize = function yyrationalize() {\n    var commonDenominator, eachTerm, theArgument;\n    theArgument = pop();\n\n    if (istensor(theArgument)) {\n      __rationalize_tensor(theArgument);\n\n      return;\n    }\n\n    expanding = 0;\n\n    if (car(theArgument) !== symbol(ADD)) {\n      push(theArgument);\n      return;\n    }\n\n    if (DEBUG) {\n      printf(\"rationalize: this is the input expr:\\n\");\n      printline(theArgument);\n    }\n\n    push(one);\n    multiply_denominators(theArgument);\n    commonDenominator = pop();\n\n    if (DEBUG) {\n      printf(\"rationalize: this is the common denominator:\\n\");\n      printline(commonDenominator);\n    }\n\n    push(zero);\n    eachTerm = cdr(theArgument);\n\n    while (iscons(eachTerm)) {\n      push(commonDenominator);\n      push(car(eachTerm));\n      multiply();\n      add();\n      eachTerm = cdr(eachTerm);\n    }\n\n    if (DEBUG) {\n      printf(\"rationalize: original expr times common denominator:\\n\");\n      printline(stack[tos - 1]);\n    }\n\n    Condense();\n\n    if (DEBUG) {\n      printf(\"rationalize: after factoring:\\n\");\n      printline(stack[tos - 1]);\n    }\n\n    push(commonDenominator);\n    divide();\n\n    if (DEBUG) {\n      printf(\"rationalize: after dividing by common denom. (and we're done):\\n\");\n      return printline(stack[tos - 1]);\n    }\n  };\n\n  multiply_denominators = function multiply_denominators(p) {\n    var results;\n\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        multiply_denominators_term(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else {\n      return multiply_denominators_term(p);\n    }\n  };\n\n  multiply_denominators_term = function multiply_denominators_term(p) {\n    var results;\n\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        multiply_denominators_factor(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else {\n      return multiply_denominators_factor(p);\n    }\n  };\n\n  multiply_denominators_factor = function multiply_denominators_factor(p) {\n    if (car(p) !== symbol(POWER)) {\n      return;\n    }\n\n    push(p);\n    p = caddr(p);\n\n    if (isnegativenumber(p)) {\n      inverse();\n\n      __lcm();\n\n      return;\n    }\n\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      inverse();\n\n      __lcm();\n\n      return;\n    }\n\n    return pop();\n  };\n\n  __rationalize_tensor = function __rationalize_tensor(theTensor) {\n    var i, l1, n, ref2;\n    i = 0;\n    push(theTensor);\n    Eval();\n    theTensor = pop();\n\n    if (!istensor(theTensor)) {\n      push(theTensor);\n      return;\n    }\n\n    n = theTensor.tensor.nelem;\n\n    for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      push(theTensor.tensor.elem[i]);\n      rationalize();\n      theTensor.tensor.elem[i] = pop();\n    }\n\n    check_tensor_dimensions(theTensor);\n    return push(theTensor);\n  };\n\n  __lcm = function __lcm() {\n    save();\n    p1 = pop();\n    p2 = pop();\n    push(p1);\n    push(p2);\n    multiply();\n    push(p1);\n    push(p2);\n    gcd();\n    divide();\n    return restore();\n  };\n  /*\n   Returns the real part of complex z\n  \n    z    real(z)\n    -    -------\n  \n    a + i b    a\n  \n    exp(i a)  cos(a)\n   */\n\n\n  Eval_real = function Eval_real() {\n    push(cadr(p1));\n    Eval();\n    return real();\n  };\n\n  real = function real() {\n    save();\n\n    _rect();\n\n    p1 = pop();\n    push(p1);\n    push(p1);\n    conjugate();\n    add();\n    push_integer(2);\n    divide();\n    return restore();\n  };\n  /*\n  Convert complex z to rectangular form\n  \n    Input:    push  z\n  \n    Output:    Result on stack\n   */\n\n\n  DEBUG_RECT = false;\n\n  Eval_rect = function Eval_rect() {\n    push(cadr(p1));\n    Eval();\n    return _rect();\n  };\n\n  _rect = function rect() {\n    var input;\n    save();\n    p1 = pop();\n    input = p1;\n\n    if (DEBUG_RECT) {\n      console.log(\"RECT of \" + input);\n    }\n\n    if (DEBUG_RECT) {\n      console.log(\"any clock forms in : \" + input + \" ? \" + _findPossibleClockForm(input));\n    }\n\n    if (issymbol(p1)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        push(p1);\n      } else {\n        push_symbol(YYRECT);\n        push(p1);\n        list(2);\n      }\n    } else if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES))) && !_findPossibleExponentialForm(p1) && !_findPossibleClockForm(p1) && !(_Find(p1, symbol(SIN)) && _Find(p1, symbol(COS)) && _Find(p1, imaginaryunit))) {\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n\n      push(p1);\n    } else if (car(p1) === symbol(MULTIPLY) && isimaginaryunit(cadr(p1)) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      push(p1);\n    } else if (car(p1) === symbol(ADD)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is a sum \");\n      }\n\n      push_integer(0);\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _rect();\n\n        add();\n        p1 = cdr(p1);\n      }\n    } else {\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is NOT a sum \");\n      }\n\n      push(p1);\n      abs();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" abs: \" + stack[tos - 1].toString());\n      }\n\n      push(p1);\n      arg();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" arg of \" + p1 + \" : \" + stack[tos - 1].toString());\n      }\n\n      p1 = pop();\n      push(p1);\n      cosine();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cosine: \" + stack[tos - 1].toString());\n      }\n\n      push(imaginaryunit);\n      push(p1);\n      sine();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" sine: \" + stack[tos - 1].toString());\n      }\n\n      multiply();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" i * sine: \" + stack[tos - 1].toString());\n      }\n\n      add();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cos + i * sine: \" + stack[tos - 1].toString());\n      }\n\n      multiply();\n    }\n\n    restore();\n\n    if (DEBUG_RECT) {\n      return console.log(\"rect of \" + input + \" : \" + stack[tos - 1]);\n    }\n  };\n\n  show_power_debug = false;\n  performing_roots = false;\n\n  Eval_roots = function Eval_roots() {\n    p2 = cadr(p1);\n\n    if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n      push(cadr(p2));\n      Eval();\n      push(caddr(p2));\n      Eval();\n      subtract();\n    } else {\n      push(p2);\n      Eval();\n      p2 = pop();\n\n      if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n        push(cadr(p2));\n        Eval();\n        push(caddr(p2));\n        Eval();\n        subtract();\n      } else {\n        push(p2);\n      }\n    }\n\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n\n    p2 = pop();\n    p1 = pop();\n\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"roots: 1st argument is not a polynomial\");\n    }\n\n    push(p1);\n    push(p2);\n    return roots();\n  };\n\n  hasImaginaryCoeff = function hasImaginaryCoeff(k) {\n    var h, i, imaginaryCoefficients, l1, ref2;\n    imaginaryCoefficients = false;\n    h = tos;\n\n    for (i = l1 = ref2 = k; l1 > 0; i = l1 += -1) {\n      if (iscomplexnumber(stack[tos - i])) {\n        imaginaryCoefficients = true;\n        break;\n      }\n    }\n\n    return imaginaryCoefficients;\n  };\n\n  isSimpleRoot = function isSimpleRoot(k) {\n    var h, i, isSimpleRootPolynomial, l1, ref2;\n\n    if (k > 2) {\n      isSimpleRootPolynomial = true;\n      h = tos;\n\n      if (isZeroAtomOrTensor(stack[tos - k])) {\n        isSimpleRootPolynomial = false;\n      }\n\n      for (i = l1 = ref2 = k - 1; l1 > 1; i = l1 += -1) {\n        if (!isZeroAtomOrTensor(stack[tos - i])) {\n          isSimpleRootPolynomial = false;\n          break;\n        }\n      }\n    } else {\n      isSimpleRootPolynomial = false;\n    }\n\n    return isSimpleRootPolynomial;\n  };\n\n  normalisedCoeff = function normalisedCoeff() {\n    var divideBy, i, k, l1, m1, miniStack, ref2, ref3;\n    k = coeff();\n    divideBy = stack[tos - 1];\n    miniStack = [];\n\n    for (i = l1 = 1, ref2 = k; 1 <= ref2 ? l1 <= ref2 : l1 >= ref2; i = 1 <= ref2 ? ++l1 : --l1) {\n      miniStack.push(pop());\n    }\n\n    for (i = m1 = ref3 = k - 1; ref3 <= 0 ? m1 <= 0 : m1 >= 0; i = ref3 <= 0 ? ++m1 : --m1) {\n      push(miniStack[i]);\n      push(divideBy);\n      divide();\n    }\n\n    return k;\n  };\n\n  roots = function roots() {\n    var h, i, k, l1, lastCoeff, leadingCoeff, n, ref2;\n    h = 0;\n    i = 0;\n    n = 0;\n    save();\n\n    if (recursionLevelNestedRadicalsRemoval > 1) {\n      pop();\n      pop();\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n\n    performing_roots = true;\n    h = tos - 2;\n\n    if (DEBUG) {\n      console.log(\"checking if \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n    }\n\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    push(p1);\n    push(p2);\n    k = normalisedCoeff();\n\n    if (isSimpleRoot(k)) {\n      if (DEBUG) {\n        console.log(\"yes, \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n      }\n\n      lastCoeff = stack[tos - k];\n      leadingCoeff = stack[tos - 1];\n      moveTos(tos - k);\n      pop();\n      pop();\n      getSimpleRoots(k, leadingCoeff, lastCoeff);\n    } else {\n      moveTos(tos - k);\n      roots2();\n    }\n\n    n = tos - h;\n\n    if (n === 0) {\n      stop(\"roots: the polynomial is not factorable, try nroots\");\n    }\n\n    if (n === 1) {\n      performing_roots = false;\n      restore();\n      return;\n    }\n\n    sort_stack(n);\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n\n    for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n\n    moveTos(h);\n    push(p1);\n    restore();\n    return performing_roots = false;\n  };\n\n  getSimpleRoots = function getSimpleRoots(n, leadingCoeff, lastCoeff) {\n    var aSol, commonPart, l1, m1, ref2, ref3, rootsOfOne;\n\n    if (DEBUG) {\n      console.log(\"getSimpleRoots\");\n    }\n\n    save();\n    n = n - 1;\n    push(lastCoeff);\n    push_rational(1, n);\n    power();\n    push(leadingCoeff);\n    push_rational(1, n);\n    power();\n    divide();\n    commonPart = pop();\n\n    if (n % 2 === 0) {\n      for (rootsOfOne = l1 = 1, ref2 = n; l1 <= ref2; rootsOfOne = l1 += 2) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n        aSol = pop();\n        push(aSol);\n        push(aSol);\n        negate();\n      }\n    } else {\n      for (rootsOfOne = m1 = 1, ref3 = n; 1 <= ref3 ? m1 <= ref3 : m1 >= ref3; rootsOfOne = 1 <= ref3 ? ++m1 : --m1) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n\n        if (rootsOfOne % 2 === 0) {\n          negate();\n        }\n      }\n    }\n\n    return restore();\n  };\n\n  roots2 = function roots2() {\n    var k;\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    push(p1);\n    push(p2);\n    k = normalisedCoeff();\n\n    if (!hasImaginaryCoeff(k)) {\n      moveTos(tos - k);\n      factorpoly();\n      p1 = pop();\n    } else {\n      moveTos(tos - k);\n      pop();\n      pop();\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        roots3();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      roots3();\n    }\n\n    return restore();\n  };\n\n  roots3 = function roots3() {\n    var n;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (car(p1) === symbol(POWER) && ispolyexpandedform(cadr(p1), p2) && isposint(caddr(p1))) {\n      push(cadr(p1));\n      push(p2);\n      n = normalisedCoeff();\n      mini_solve(n);\n    } else if (ispolyexpandedform(p1, p2)) {\n      push(p1);\n      push(p2);\n      n = normalisedCoeff();\n      mini_solve(n);\n    }\n\n    return restore();\n  };\n\n  mini_solve = function mini_solve(n) {\n    var C_CHECKED_AS_NOT_ZERO, Q_CHECKED_AS_NOT_ZERO, R_18_a_b_c_d, R_27_a2_d, R_2_b3, R_3_a, R_3_a_C, R_3_a_c, R_4_DELTA03, R_6_a, R_6_a_C, R_C, R_C_over_3a, R_C_simplified_toCheckIfZero, R_DELTA0, R_DELTA0_simplified_toCheckIfZero, R_DELTA0_toBeCheckedIfZero, R_DELTA1, R_Q, R_Q_simplified_toCheckIfZero, R_S, R_S_simplified_toCheckIfZero, R_a2, R_a2_d, R_a2_d2, R_a3, R_a_b_c, R_a_b_c_d, R_a_c, R_b2, R_b2_c2, R_b3, R_b3_d, R_c2, R_c3, R_d2, R_determinant, R_determinant_simplified_toCheckIfZero, R_e2, R_e3, R_m, R_m27_a2_d2, R_m4_a_c3, R_m4_b3_d, R_m9_a_b_c, R_m_b_over_3a, R_minus_4S2_minus_2p, R_minus_b_over_4a, R_p, R_principalCubicRoot, R_q, R_q_over_S, R_r, S_CHECKED_AS_NOT_ZERO, ThreePPlus2M, TwoQOversqrtPPlus2M, biquadraticSolutions, choiceOfRadicalInQSoSIsNotZero, coeff2, coeff3, coeff4, depressedSolutions, eachSolution, flipSignOFQSoCIsNotZero, flipSignOFRadicalSoQIsNotZero, i_sqrt3, l1, len, len1, len2, m1, n1, one_minus_i_sqrt3, one_plus_i_sqrt3, ref2, ref3, ref4, resolventCubicSolutions, root_solution, sqrtPPlus2M, toBeCheckedIFZero;\n    save();\n\n    if (n === 2) {\n      p3 = pop();\n      p4 = pop();\n      push(p4);\n      push(p3);\n      divide();\n      negate();\n      restore();\n      return;\n    }\n\n    if (n === 3) {\n      p3 = pop();\n      p4 = pop();\n      p5 = pop();\n      push(p4);\n      push_integer(2);\n      power();\n      push_integer(4);\n      push(p3);\n      multiply();\n      push(p5);\n      multiply();\n      subtract();\n      push_rational(1, 2);\n      power();\n      p6 = pop();\n      push(p6);\n      push(p4);\n      subtract();\n      push(p3);\n      push_integer(2);\n      multiply();\n      divide();\n      push(p6);\n      push(p4);\n      add();\n      negate();\n      push(p3);\n      divide();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n\n    if (n === 4 || n === 5) {\n      p3 = pop();\n      p4 = pop();\n      p5 = pop();\n      p6 = pop();\n      push(p5);\n      push(p5);\n      multiply();\n      R_c2 = pop();\n      push(R_c2);\n      push(p5);\n      multiply();\n      R_c3 = pop();\n      push(p4);\n      push(p4);\n      multiply();\n      R_b2 = pop();\n      push(R_b2);\n      push(p4);\n      multiply();\n      R_b3 = pop();\n      push(R_b3);\n      push(p6);\n      multiply();\n      R_b3_d = pop();\n      push(R_b3_d);\n      push_integer(-4);\n      multiply();\n      R_m4_b3_d = pop();\n      push(R_b3);\n      push_integer(2);\n      multiply();\n      R_2_b3 = pop();\n      push(p3);\n      push(p3);\n      multiply();\n      R_a2 = pop();\n      push(R_a2);\n      push(p3);\n      multiply();\n      R_a3 = pop();\n      push_integer(3);\n      push(p3);\n      multiply();\n      R_3_a = pop();\n      push(R_a2);\n      push(p6);\n      multiply();\n      R_a2_d = pop();\n      push(R_a2_d);\n      push(p6);\n      multiply();\n      R_a2_d2 = pop();\n      push(R_a2_d);\n      push_integer(27);\n      multiply();\n      R_27_a2_d = pop();\n      push(R_a2_d2);\n      push_integer(-27);\n      multiply();\n      R_m27_a2_d2 = pop();\n      push(R_3_a);\n      push_integer(2);\n      multiply();\n      R_6_a = pop();\n      push(p3);\n      push(p5);\n      multiply();\n      R_a_c = pop();\n      push(R_a_c);\n      push(p4);\n      multiply();\n      R_a_b_c = pop();\n      push(R_a_b_c);\n      push(p6);\n      multiply();\n      R_a_b_c_d = pop();\n      push(R_a_c);\n      push_integer(3);\n      multiply();\n      R_3_a_c = pop();\n      push_integer(-4);\n      push(p3);\n      push(R_c3);\n      multiply();\n      multiply();\n      R_m4_a_c3 = pop();\n      push(R_a_b_c);\n      push_integer(9);\n      multiply();\n      negate();\n      R_m9_a_b_c = pop();\n      push(R_a_b_c_d);\n      push_integer(18);\n      multiply();\n      R_18_a_b_c_d = pop();\n      push(R_b2);\n      push(R_3_a_c);\n      subtract();\n      R_DELTA0 = pop();\n      push(R_b2);\n      push(R_c2);\n      multiply();\n      R_b2_c2 = pop();\n      push(p4);\n      negate();\n      push(R_3_a);\n      divide();\n      R_m_b_over_3a = pop();\n\n      if (n === 4) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using cubic formula <<<<<<<<<<<<<<< \");\n        }\n\n        if (DEBUG) {\n          console.log(\"cubic: D0: \" + R_DELTA0.toString());\n        }\n\n        push(R_DELTA0);\n        push_integer(3);\n        power();\n        push_integer(4);\n        multiply();\n        R_4_DELTA03 = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_toBeCheckedIfZero = pop();\n\n        if (DEBUG) {\n          console.log(\"cubic: D0 as float: \" + R_DELTA0_toBeCheckedIfZero.toString());\n        }\n\n        push(R_18_a_b_c_d);\n        push(R_m4_b3_d);\n        push(R_b2_c2);\n        push(R_m4_a_c3);\n        push(R_m27_a2_d2);\n        add();\n        add();\n        add();\n        add();\n        simplify();\n        absValFloat();\n        R_determinant = pop();\n\n        if (DEBUG) {\n          console.log(\"cubic: DETERMINANT: \" + R_determinant.toString());\n        }\n\n        push(R_2_b3);\n        push(R_m9_a_b_c);\n        push(R_27_a2_d);\n        add();\n        add();\n        R_DELTA1 = pop();\n\n        if (DEBUG) {\n          console.log(\"cubic: D1: \" + R_DELTA1.toString());\n        }\n\n        push(R_DELTA1);\n        push_integer(2);\n        power();\n        push(R_4_DELTA03);\n        subtract();\n        push_rational(1, 2);\n        power();\n        simplify();\n        R_Q = pop();\n\n        if (isZeroAtomOrTensor(R_determinant)) {\n          if (isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is zero\");\n            }\n\n            push(R_m_b_over_3a);\n            restore();\n            return;\n          } else {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is not zero\");\n            }\n\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            push(p4);\n            push(p5);\n            multiply();\n            subtract();\n            push(R_DELTA0);\n            push_integer(2);\n            multiply();\n            divide();\n            root_solution = pop();\n            push(root_solution);\n            push(root_solution);\n            push(R_a_b_c);\n            push_integer(4);\n            multiply();\n            push(p3);\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            multiply();\n            negate();\n            push(R_b3);\n            negate();\n            add();\n            add();\n            push(p3);\n            push(R_DELTA0);\n            multiply();\n            divide();\n            restore();\n            return;\n          }\n        }\n\n        C_CHECKED_AS_NOT_ZERO = false;\n        flipSignOFQSoCIsNotZero = false;\n\n        while (!C_CHECKED_AS_NOT_ZERO) {\n          push(R_Q);\n\n          if (flipSignOFQSoCIsNotZero) {\n            negate();\n          }\n\n          push(R_DELTA1);\n          add();\n          push_rational(1, 2);\n          multiply();\n          push_rational(1, 3);\n          power();\n          simplify();\n          R_C = pop();\n\n          if (DEBUG) {\n            console.log(\"cubic: C: \" + R_C.toString());\n          }\n\n          push(R_C);\n          simplify();\n          absValFloat();\n          R_C_simplified_toCheckIfZero = pop();\n\n          if (DEBUG) {\n            console.log(\"cubic: C as absval and float: \" + R_C_simplified_toCheckIfZero.toString());\n          }\n\n          if (isZeroAtomOrTensor(R_C_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: C IS ZERO flipping the sign\");\n            }\n\n            flipSignOFQSoCIsNotZero = true;\n          } else {\n            C_CHECKED_AS_NOT_ZERO = true;\n          }\n        }\n\n        push(R_C);\n        push(R_3_a);\n        multiply();\n        R_3_a_C = pop();\n        push(R_3_a_C);\n        push_integer(2);\n        multiply();\n        R_6_a_C = pop();\n        push(imaginaryunit);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        multiply();\n        i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        add();\n        one_plus_i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        subtract();\n        one_minus_i_sqrt3 = pop();\n        push(R_C);\n        push(R_3_a);\n        divide();\n        R_C_over_3a = pop();\n        push(R_m_b_over_3a);\n        push(R_C_over_3a);\n        negate();\n        push(R_DELTA0);\n        push(R_3_a_C);\n        divide();\n        negate();\n        add();\n        add();\n        simplify();\n        push(R_m_b_over_3a);\n        push(R_C_over_3a);\n        push(one_plus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide();\n        push(one_minus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide();\n        add();\n        add();\n        simplify();\n        push(R_m_b_over_3a);\n        push(R_C_over_3a);\n        push(one_minus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide();\n        push(one_plus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide();\n        add();\n        add();\n        simplify();\n        restore();\n        return;\n      }\n\n      if (n === 5) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using quartic formula <<<<<<<<<<<<<<< \");\n        }\n\n        p7 = pop();\n\n        if (isZeroAtomOrTensor(p4) && isZeroAtomOrTensor(p6) && !isZeroAtomOrTensor(p5) && !isZeroAtomOrTensor(p7)) {\n          if (DEBUG) {\n            console.log(\"biquadratic case\");\n          }\n\n          push(p3);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(p5);\n          push(symbol(SECRETX));\n          multiply();\n          push(p7);\n          add();\n          add();\n          push(symbol(SECRETX));\n          roots();\n          biquadraticSolutions = pop();\n          ref2 = biquadraticSolutions.tensor.elem;\n\n          for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n            eachSolution = ref2[l1];\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            simplify();\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            negate();\n            simplify();\n          }\n\n          restore();\n          return;\n        }\n\n        push(p6);\n        push(p6);\n        multiply();\n        R_d2 = pop();\n        push(p7);\n        push(p7);\n        multiply();\n        R_e2 = pop();\n        push(R_e2);\n        push(p7);\n        multiply();\n        R_e3 = pop();\n        push_integer(256);\n        push(R_a3);\n        push(R_e3);\n        multiply();\n        multiply();\n        push_integer(-192);\n        push(R_a2_d);\n        push(R_e2);\n        push(p4);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(-128);\n        push(R_a2);\n        push(R_c2);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(144);\n        push(R_a2_d2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        push(R_m27_a2_d2);\n        push(R_d2);\n        multiply();\n        push_integer(144);\n        push(R_a_b_c);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(-6);\n        push(p3);\n        push(R_b2);\n        push(R_d2);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        multiply();\n        push_integer(-80);\n        push(R_a_b_c_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(18);\n        push(R_a_b_c_d);\n        push(R_d2);\n        multiply();\n        multiply();\n        push_integer(16);\n        push(R_a_c);\n        push(R_c3);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(-4);\n        push(R_a_c);\n        push(R_c2);\n        push(R_d2);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(-27);\n        push(R_b3);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(18);\n        push(R_b3_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        push(R_m4_b3_d);\n        push(R_d2);\n        multiply();\n        push_integer(-4);\n        push(R_b2_c2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        push(R_b2_c2);\n        push(R_d2);\n        multiply();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        R_determinant = pop();\n\n        if (DEBUG) {\n          console.log(\"R_determinant: \" + R_determinant.toString());\n        }\n\n        push(R_c2);\n        push_integer(-3);\n        push(p4);\n        push(p6);\n        multiply();\n        multiply();\n        push_integer(12);\n        push(p3);\n        push(p7);\n        multiply();\n        multiply();\n        add();\n        add();\n        R_DELTA0 = pop();\n\n        if (DEBUG) {\n          console.log(\"R_DELTA0: \" + R_DELTA0.toString());\n        }\n\n        push_integer(2);\n        push(R_c3);\n        multiply();\n        push_integer(-9);\n        push(p4);\n        push(p5);\n        push(p6);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(27);\n        push(R_b2);\n        push(p7);\n        multiply();\n        multiply();\n        push_integer(27);\n        push(p3);\n        push(R_d2);\n        multiply();\n        multiply();\n        push_integer(-72);\n        push(R_a_c);\n        push(p7);\n        multiply();\n        multiply();\n        add();\n        add();\n        add();\n        add();\n        R_DELTA1 = pop();\n\n        if (DEBUG) {\n          console.log(\"R_DELTA1: \" + R_DELTA1.toString());\n        }\n\n        push_integer(8);\n        push(R_a_c);\n        multiply();\n        push_integer(-3);\n        push(R_b2);\n        multiply();\n        add();\n        push_integer(8);\n        push(R_a2);\n        multiply();\n        divide();\n        R_p = pop();\n\n        if (DEBUG) {\n          console.log(\"p: \" + R_p.toString());\n        }\n\n        push(R_b3);\n        push_integer(-4);\n        push(R_a_b_c);\n        multiply();\n        push_integer(8);\n        push(R_a2_d);\n        multiply();\n        add();\n        add();\n        push_integer(8);\n        push(R_a3);\n        multiply();\n        divide();\n        R_q = pop();\n\n        if (DEBUG) {\n          console.log(\"q: \" + R_q.toString());\n        }\n\n        if (DEBUG) {\n          console.log(\"tos 1 \" + tos);\n        }\n\n        if (!isZeroAtomOrTensor(p4)) {\n          if (DEBUG) {\n            console.log(\"tos 2 \" + tos);\n          }\n\n          push_integer(8);\n          push(p5);\n          push(p3);\n          multiply();\n          multiply();\n          push_integer(-3);\n          push(p4);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          divide();\n          R_p = pop();\n\n          if (DEBUG) {\n            console.log(\"p for depressed quartic: \" + R_p.toString());\n          }\n\n          push(p4);\n          push_integer(3);\n          power();\n          push_integer(-4);\n          push(p3);\n          push(p4);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          push_integer(8);\n          push(p6);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          multiply();\n          add();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(3);\n          power();\n          multiply();\n          divide();\n          R_q = pop();\n\n          if (DEBUG) {\n            console.log(\"q for depressed quartic: \" + R_q.toString());\n          }\n\n          push(p4);\n          push_integer(4);\n          power();\n          push_integer(-3);\n          multiply();\n          push_integer(256);\n          push(R_a3);\n          push(p7);\n          multiply();\n          multiply();\n          push_integer(-64);\n          push(R_a2_d);\n          push(p4);\n          multiply();\n          multiply();\n          push_integer(16);\n          push(R_b2);\n          push(p3);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          add();\n          add();\n          add();\n          push_integer(256);\n          push(p3);\n          push_integer(4);\n          power();\n          multiply();\n          divide();\n          R_r = pop();\n\n          if (DEBUG) {\n            console.log(\"r for depressed quartic: \" + R_r.toString());\n          }\n\n          if (DEBUG) {\n            console.log(\"tos 4 \" + tos);\n          }\n\n          push(symbol(SECRETX));\n          push_integer(4);\n          power();\n\n          if (DEBUG) {\n            console.log(\"4 * x^4: \" + stack[tos - 1].toString());\n          }\n\n          push(R_p);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n\n          if (DEBUG) {\n            console.log(\"R_p * x^2: \" + stack[tos - 1].toString());\n          }\n\n          push(R_q);\n          push(symbol(SECRETX));\n          multiply();\n\n          if (DEBUG) {\n            console.log(\"R_q * x: \" + stack[tos - 1].toString());\n          }\n\n          push(R_r);\n\n          if (DEBUG) {\n            console.log(\"R_r: \" + stack[tos - 1].toString());\n          }\n\n          add();\n          add();\n          add();\n          simplify();\n\n          if (DEBUG) {\n            console.log(\"solving depressed quartic: \" + stack[tos - 1].toString());\n          }\n\n          push(symbol(SECRETX));\n          roots();\n          depressedSolutions = pop();\n\n          if (DEBUG) {\n            console.log(\"depressedSolutions: \" + depressedSolutions);\n          }\n\n          ref3 = depressedSolutions.tensor.elem;\n\n          for (m1 = 0, len1 = ref3.length; m1 < len1; m1++) {\n            eachSolution = ref3[m1];\n            push(eachSolution);\n            push(p4);\n            push_integer(4);\n            push(p3);\n            multiply();\n            divide();\n            subtract();\n            simplify();\n\n            if (DEBUG) {\n              console.log(\"solution from depressed: \" + stack[tos - 1].toString());\n            }\n          }\n\n          restore();\n          return;\n        } else {\n          R_p = p5;\n          R_q = p6;\n          R_r = p7;\n          /*\n           * Descartes' solution\n           * https://en.wikipedia.org/wiki/Quartic_function#Descartes.27_solution\n           * finding the \"u\" in the depressed equation\n          \n          push_integer(2)\n          push(R_p)\n          multiply()\n          coeff2 = pop()\n          \n          push_integer(-4)\n          push(R_p)\n          push_integer(2)\n          power()\n          multiply()\n          push(R_r)\n          multiply()\n          coeff3 = pop()\n          \n          push(R_q)\n          push_integer(2)\n          power()\n          negate()\n          coeff4 = pop()\n          \n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(3)\n          power()\n          \n          push(coeff2)\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n          multiply()\n          \n          push(coeff3)\n          push(symbol(SECRETX))\n          multiply()\n          \n          push(coeff4)\n          \n          add()\n          add()\n          add()\n          \n          console.log(\"Descarte's resolventCubic: \" +  stack[tos-1].toString())\n          push(symbol(SECRETX))\n          \n          roots()\n          \n          resolventCubicSolutions = pop()\n          console.log(\"Descarte's resolventCubic solutions: \" +  resolventCubicSolutions)\n          console.log(\"tos: \" +  tos)\n          \n          R_u = null\n          #R_u = resolventCubicSolutions.tensor.elem[1]\n          for eachSolution in resolventCubicSolutions.tensor.elem\n            console.log(\"examining solution: \" +  eachSolution)\n            push(eachSolution)\n            push_integer(2)\n            multiply()\n            push(R_p)\n            add()\n          \n            absValFloat()\n            toBeCheckedIFZero = pop()\n            console.log(\"abs value is: \" +  eachSolution)\n            if !isZeroAtomOrTensor(toBeCheckedIFZero)\n              R_u = eachSolution\n              break\n          \n          console.log(\"chosen solution: \" +  R_u)\n          \n          push(R_u)\n          negate()\n          R_s = pop()\n          \n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          add()\n          add()\n          push_integer(2)\n          divide()\n          R_t = pop()\n          \n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          subtract()\n          add()\n          push_integer(2)\n          divide()\n          R_v = pop()\n          \n           * factoring the quartic into two quadratics:\n          \n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n          \n          push(R_s)\n          push(symbol(SECRETX))\n          multiply()\n          \n          push(R_t)\n          \n          add()\n          add()\n          \n          console.log(\"factored quartic 1: \" + stack[tos-1].toString())\n          \n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n          \n          push(R_u)\n          push(symbol(SECRETX))\n          multiply()\n          \n          push(R_v)\n          \n          add()\n          add()\n          \n          console.log(\"factored quartic 2: \" + stack[tos-1].toString())\n          pop()\n          \n          restore()\n          return\n           */\n\n          push_rational(5, 2);\n          push(R_p);\n          multiply();\n          coeff2 = pop();\n          push_integer(2);\n          push(R_p);\n          push_integer(2);\n          power();\n          multiply();\n          push(R_r);\n          subtract();\n          coeff3 = pop();\n          push(R_p);\n          push_integer(3);\n          power();\n          push_integer(2);\n          divide();\n          push_rational(-1, 2);\n          push(R_p);\n          push(R_r);\n          multiply();\n          multiply();\n          push_rational(-1, 8);\n          push(R_q);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n          coeff4 = pop();\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          push(coeff2);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(coeff3);\n          push(symbol(SECRETX));\n          multiply();\n          push(coeff4);\n          add();\n          add();\n          add();\n\n          if (DEBUG) {\n            console.log(\"resolventCubic: \" + stack[tos - 1].toString());\n          }\n\n          push(symbol(SECRETX));\n          roots();\n          resolventCubicSolutions = pop();\n\n          if (DEBUG) {\n            console.log(\"resolventCubicSolutions: \" + resolventCubicSolutions);\n          }\n\n          R_m = null;\n          ref4 = resolventCubicSolutions.tensor.elem;\n\n          for (n1 = 0, len2 = ref4.length; n1 < len2; n1++) {\n            eachSolution = ref4[n1];\n\n            if (DEBUG) {\n              console.log(\"examining solution: \" + eachSolution);\n            }\n\n            push(eachSolution);\n            push_integer(2);\n            multiply();\n            push(R_p);\n            add();\n            absValFloat();\n            toBeCheckedIFZero = pop();\n\n            if (DEBUG) {\n              console.log(\"abs value is: \" + eachSolution);\n            }\n\n            if (!isZeroAtomOrTensor(toBeCheckedIFZero)) {\n              R_m = eachSolution;\n              break;\n            }\n          }\n\n          if (DEBUG) {\n            console.log(\"chosen solution: \" + R_m);\n          }\n\n          push(R_m);\n          push_integer(2);\n          multiply();\n          push(R_p);\n          add();\n          push_rational(1, 2);\n          power();\n          simplify();\n          sqrtPPlus2M = pop();\n          push(R_q);\n          push_integer(2);\n          multiply();\n          push(sqrtPPlus2M);\n          divide();\n          simplify();\n          TwoQOversqrtPPlus2M = pop();\n          push(R_p);\n          push_integer(3);\n          multiply();\n          push(R_m);\n          push_integer(2);\n          multiply();\n          add();\n          ThreePPlus2M = pop();\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          restore();\n          return;\n        }\n\n        push(R_determinant);\n        simplify();\n        absValFloat();\n        R_determinant_simplified_toCheckIfZero = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_simplified_toCheckIfZero = pop();\n        S_CHECKED_AS_NOT_ZERO = false;\n        choiceOfRadicalInQSoSIsNotZero = 0;\n\n        while (!S_CHECKED_AS_NOT_ZERO) {\n          Q_CHECKED_AS_NOT_ZERO = false;\n          flipSignOFRadicalSoQIsNotZero = false;\n\n          while (!Q_CHECKED_AS_NOT_ZERO) {\n            push(R_DELTA1);\n            push(R_DELTA1);\n            push_integer(2);\n            power();\n            push_integer(-4);\n            push(R_DELTA0);\n            push_integer(3);\n            power();\n            multiply();\n            add();\n            push_rational(1, 2);\n            power();\n\n            if (flipSignOFRadicalSoQIsNotZero) {\n              negate();\n            }\n\n            add();\n            push_integer(2);\n            divide();\n\n            if (DEBUG) {\n              console.log(\"content of cubic root: \" + stack[tos - 1].toString());\n            }\n\n            push_rational(1, 3);\n            power();\n            simplify();\n            R_principalCubicRoot = pop();\n\n            if (DEBUG) {\n              console.log(\"principal cubic root: \" + R_principalCubicRoot.toString());\n            }\n\n            if (DEBUG) {\n              console.log(\"tos : \" + tos);\n            }\n\n            if (choiceOfRadicalInQSoSIsNotZero === 0) {\n              if (DEBUG) {\n                console.log(\"chosing principal cubic root\");\n              }\n\n              push(R_principalCubicRoot);\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond principal\");\n              }\n\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(-1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond beyond principal\");\n              }\n\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            }\n\n            simplify();\n            R_Q = pop();\n\n            if (DEBUG) {\n              console.log(\"Q \" + R_Q.toString());\n            }\n\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n\n            push(R_Q);\n            simplify();\n            absValFloat();\n            R_Q_simplified_toCheckIfZero = pop();\n\n            if (DEBUG) {\n              console.log(\"Q simplified and abs\" + R_Q_simplified_toCheckIfZero.toString());\n            }\n\n            if (isZeroAtomOrTensor(R_Q_simplified_toCheckIfZero) && !isZeroAtomOrTensor(R_determinant_simplified_toCheckIfZero) && isZeroAtomOrTensor(R_DELTA0_simplified_toCheckIfZero)) {\n              if (DEBUG) {\n                console.log(\" *********************************** Q IS ZERO and it matters, flipping the sign\");\n              }\n\n              flipSignOFRadicalSoQIsNotZero = true;\n            } else {\n              Q_CHECKED_AS_NOT_ZERO = true;\n            }\n\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n          }\n\n          push_rational(-2, 3);\n          push(R_p);\n          multiply();\n          push(R_Q);\n          push(R_DELTA0);\n          push(R_Q);\n          divide();\n          add();\n          push(R_3_a);\n          divide();\n          add();\n          push_rational(1, 2);\n          power();\n          push_integer(2);\n          divide();\n          show_power_debug = true;\n          simplify();\n          R_S = pop();\n\n          if (DEBUG) {\n            console.log(\"S \" + R_S.toString());\n          }\n\n          push(R_S);\n          simplify();\n          absValFloat();\n          R_S_simplified_toCheckIfZero = pop();\n\n          if (DEBUG) {\n            console.log(\"S \" + R_S_simplified_toCheckIfZero.toString());\n          }\n\n          if (isZeroAtomOrTensor(R_S_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" *********************************** S IS ZERO chosing another cubic root\");\n            }\n\n            choiceOfRadicalInQSoSIsNotZero++;\n          } else {\n            S_CHECKED_AS_NOT_ZERO = true;\n          }\n\n          if (DEBUG) {\n            console.log(\"tos: \" + tos);\n          }\n        }\n\n        if (DEBUG) {\n          console.log(\"tos: \" + tos);\n        }\n\n        push(p4);\n        negate();\n        push(p3);\n        push_integer(4);\n        multiply();\n        divide();\n        R_minus_b_over_4a = pop();\n        push_integer(-4);\n        push(R_S);\n        push_integer(2);\n        power();\n        multiply();\n        push_integer(2);\n        push(R_p);\n        multiply();\n        subtract();\n        R_minus_4S2_minus_2p = pop();\n        push(R_q);\n        push(R_S);\n        divide();\n        R_q_over_S = pop();\n\n        if (DEBUG) {\n          console.log(\"tos before putting together the 4 solutions: \" + tos);\n        }\n\n        push(R_minus_b_over_4a);\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        push(R_minus_b_over_4a);\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        push(R_minus_b_over_4a);\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        push(R_minus_b_over_4a);\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        restore();\n        return;\n      }\n    }\n\n    moveTos(tos - n);\n    return restore();\n  };\n\n  Eval_round = function Eval_round() {\n    push(cadr(p1));\n    Eval();\n    return yround();\n  };\n\n  yround = function yround() {\n    save();\n    yyround();\n    return restore();\n  };\n\n  yyround = function yyround() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (!isNumericAtom(p1)) {\n      push_symbol(ROUND);\n      push(p1);\n      list(2);\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.round(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n\n    push(p1);\n\n    _yyfloat();\n\n    p1 = pop();\n    return push_integer(Math.round(p1.d));\n  };\n\n  T_INTEGER = 1001;\n  T_DOUBLE = 1002;\n  T_SYMBOL = 1003;\n  T_FUNCTION = 1004;\n  T_NEWLINE = 1006;\n  T_STRING = 1007;\n  T_GTEQ = 1008;\n  T_LTEQ = 1009;\n  T_EQ = 1010;\n  T_NEQ = 1011;\n  T_QUOTASSIGN = 1012;\n  token = \"\";\n  newline_flag = 0;\n  meta_mode = 0;\n  input_str = 0;\n  scan_str = 0;\n  token_str = 0;\n  token_buf = 0;\n  lastFoundSymbol = null;\n  symbolsRightOfAssignment = null;\n  symbolsLeftOfAssignment = null;\n  isSymbolLeftOfAssignment = null;\n  scanningParameters = null;\n  functionInvokationsScanningStack = null;\n  skipRootVariableToBeSolved = false;\n  assignmentFound = null;\n  scanned = \"\";\n\n  scan = function scan(s) {\n    if (DEBUG) {\n      console.log(\"#### scanning \" + s);\n    }\n\n    lastFoundSymbol = null;\n    symbolsRightOfAssignment = [];\n    symbolsLeftOfAssignment = [];\n    isSymbolLeftOfAssignment = true;\n    scanningParameters = [];\n    functionInvokationsScanningStack = [\"\"];\n    assignmentFound = false;\n    scanned = s;\n    meta_mode = 0;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n\n    scan_stmt();\n    expanding--;\n\n    if (!assignmentFound) {\n      symbolsInExpressionsWithoutAssignments = symbolsInExpressionsWithoutAssignments.concat(symbolsLeftOfAssignment);\n    }\n\n    return token_str - input_str;\n  };\n\n  scan_meta = function scan_meta(s) {\n    scanned = s;\n    meta_mode = 1;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n\n    scan_stmt();\n    expanding--;\n    return token_str - input_str;\n  };\n\n  scan_stmt = function scan_stmt() {\n    var assignmentIsOfQuotedType, existingDependencies, i, indexOfSymbolLeftOfAssignment, l1, len, len1, m1, symbolLeftOfAssignment;\n    scan_relation();\n    assignmentIsOfQuotedType = false;\n\n    if (token === T_QUOTASSIGN) {\n      assignmentIsOfQuotedType = true;\n    }\n\n    if (token === T_QUOTASSIGN || token === '=') {\n      symbolLeftOfAssignment = lastFoundSymbol;\n\n      if (DEBUG) {\n        console.log(\"assignment!\");\n      }\n\n      assignmentFound = true;\n      isSymbolLeftOfAssignment = false;\n      get_next_token();\n      push_symbol(SETQ);\n      swap();\n\n      if (assignmentIsOfQuotedType) {\n        push_symbol(QUOTE);\n      }\n\n      scan_relation();\n\n      if (assignmentIsOfQuotedType) {\n        list(2);\n      }\n\n      list(3);\n      isSymbolLeftOfAssignment = true;\n\n      if (codeGen) {\n        indexOfSymbolLeftOfAssignment = symbolsRightOfAssignment.indexOf(symbolLeftOfAssignment);\n\n        if (indexOfSymbolLeftOfAssignment !== -1) {\n          symbolsRightOfAssignment.splice(indexOfSymbolLeftOfAssignment, 1);\n          symbolsHavingReassignments.push(symbolLeftOfAssignment);\n        }\n\n        if (DEBUG) {\n          console.log(\"locally, \" + symbolLeftOfAssignment + \" depends on: \");\n\n          for (l1 = 0, len = symbolsRightOfAssignment.length; l1 < len; l1++) {\n            i = symbolsRightOfAssignment[l1];\n            console.log(\"  \" + i);\n          }\n        }\n\n        if (symbolsDependencies[symbolLeftOfAssignment] == null) {\n          symbolsDependencies[symbolLeftOfAssignment] = [];\n        }\n\n        existingDependencies = symbolsDependencies[symbolLeftOfAssignment];\n\n        for (m1 = 0, len1 = symbolsRightOfAssignment.length; m1 < len1; m1++) {\n          i = symbolsRightOfAssignment[m1];\n\n          if (existingDependencies.indexOf(i) === -1) {\n            existingDependencies.push(i);\n          }\n        }\n\n        return symbolsRightOfAssignment = [];\n      }\n    }\n  };\n\n  scan_relation = function scan_relation() {\n    scan_expression();\n\n    switch (token) {\n      case T_EQ:\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n\n      case T_NEQ:\n        push_symbol(NOT);\n        swap();\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        list(3);\n        return list(2);\n\n      case T_LTEQ:\n        push_symbol(TESTLE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n\n      case T_GTEQ:\n        push_symbol(TESTGE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n\n      case '<':\n        push_symbol(TESTLT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n\n      case '>':\n        push_symbol(TESTGT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n    }\n  };\n\n  scan_expression = function scan_expression() {\n    var h;\n    h = tos;\n\n    switch (token) {\n      case '+':\n        get_next_token();\n        scan_term();\n        break;\n\n      case '-':\n        get_next_token();\n        scan_term();\n        negate();\n        break;\n\n      default:\n        scan_term();\n    }\n\n    while (newline_flag === 0 && (token === '+' || token === '-')) {\n      if (token === '+') {\n        get_next_token();\n        scan_term();\n      } else {\n        get_next_token();\n        scan_term();\n        negate();\n      }\n    }\n\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(ADD);\n      swap();\n      return cons();\n    }\n  };\n\n  is_factor = function is_factor() {\n    if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n      return 1;\n    }\n\n    switch (token) {\n      case '*':\n      case '/':\n        return 1;\n\n      case '(':\n      case T_SYMBOL:\n      case T_FUNCTION:\n      case T_INTEGER:\n      case T_DOUBLE:\n      case T_STRING:\n        if (newline_flag) {\n          scan_str = token_str;\n          return 0;\n        } else {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  simplify_1_in_products = function simplify_1_in_products(tos, h) {\n    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {\n      return pop();\n    }\n  };\n\n  multiply_consecutive_constants = function multiply_consecutive_constants(tos, h) {\n    if (tos > h + 1 && isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply();\n    }\n  };\n\n  scan_term = function scan_term() {\n    var h;\n    h = tos;\n    scan_factor();\n\n    if (parse_time_simplifications) {\n      simplify_1_in_products(tos, h);\n    }\n\n    while (is_factor()) {\n      if (token === '*') {\n        get_next_token();\n        scan_factor();\n      } else if (token === '/') {\n        simplify_1_in_products(tos, h);\n        get_next_token();\n        scan_factor();\n        inverse();\n      } else if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n        get_next_token();\n        push_symbol(INNER);\n        swap();\n        scan_factor();\n        list(3);\n      } else {\n        scan_factor();\n      }\n\n      if (parse_time_simplifications) {\n        multiply_consecutive_constants(tos, h);\n        simplify_1_in_products(tos, h);\n      }\n    }\n\n    if (h === tos) {\n      return push_integer(1);\n    } else if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      return cons();\n    }\n  };\n\n  scan_power = function scan_power() {\n    if (token === '^') {\n      get_next_token();\n      push_symbol(POWER);\n      swap();\n      scan_factor();\n      return list(3);\n    }\n  };\n\n  scan_index = function scan_index(h) {\n    get_next_token();\n    push_symbol(INDEX);\n    swap();\n    scan_expression();\n\n    while (token === ',') {\n      get_next_token();\n      scan_expression();\n    }\n\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n\n    get_next_token();\n    return list(tos - h);\n  };\n\n  scan_factor = function scan_factor() {\n    var firstFactorIsNumber, h;\n    h = tos;\n    firstFactorIsNumber = false;\n\n    if (token === '(') {\n      scan_subexpr();\n    } else if (token === T_SYMBOL) {\n      scan_symbol();\n    } else if (token === T_FUNCTION) {\n      scan_function_call_with_function_name();\n    } else if (token === '[') {\n      scan_tensor();\n    } else if (token === T_INTEGER) {\n      firstFactorIsNumber = true;\n      bignum_scan_integer(token_buf);\n      get_next_token();\n    } else if (token === T_DOUBLE) {\n      firstFactorIsNumber = true;\n      bignum_scan_float(token_buf);\n      get_next_token();\n    } else if (token === T_STRING) {\n      scan_string();\n    } else {\n      scan_error(\"syntax error\");\n    }\n\n    while (token === '[' || token === '(' && newline_flag === 0 && !firstFactorIsNumber) {\n      if (token === '[') {\n        scan_index(h);\n      } else if (token === '(') {\n        scan_function_call_without_function_name();\n      }\n    }\n\n    while (token === '!') {\n      get_next_token();\n      push_symbol(FACTORIAL);\n      swap();\n      list(2);\n    }\n\n    while ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === transpose_unicode) {\n      get_next_token();\n      push_symbol(TRANSPOSE);\n      swap();\n      list(2);\n    }\n\n    return scan_power();\n  };\n\n  addSymbolRightOfAssignment = function addSymbolRightOfAssignment(theSymbol) {\n    var i, l1, prefixVar, ref2;\n\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols right of assignment\");\n      }\n\n      prefixVar = \"\";\n\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; 1 <= ref2 ? l1 < ref2 : l1 > ref2; i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n\n      theSymbol = prefixVar + theSymbol;\n      return symbolsRightOfAssignment.push(theSymbol);\n    }\n  };\n\n  addSymbolLeftOfAssignment = function addSymbolLeftOfAssignment(theSymbol) {\n    var i, l1, prefixVar, ref2;\n\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols left of assignment\");\n      }\n\n      prefixVar = \"\";\n\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; 1 <= ref2 ? l1 < ref2 : l1 > ref2; i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n\n      theSymbol = prefixVar + theSymbol;\n      return symbolsLeftOfAssignment.push(theSymbol);\n    }\n  };\n\n  scan_symbol = function scan_symbol() {\n    if (token !== T_SYMBOL) {\n      scan_error(\"symbol expected\");\n    }\n\n    if (meta_mode && token_buf.length === 1) {\n      switch (token_buf[0]) {\n        case 'a':\n          push(symbol(METAA));\n          break;\n\n        case 'b':\n          push(symbol(METAB));\n          break;\n\n        case 'x':\n          push(symbol(METAX));\n          break;\n\n        default:\n          push(usr_symbol(token_buf));\n      }\n    } else {\n      push(usr_symbol(token_buf));\n    }\n\n    if (scanningParameters.length === 0) {\n      if (DEBUG) {\n        console.log(\"out of scanning parameters, processing \" + token_buf);\n      }\n\n      lastFoundSymbol = token_buf;\n\n      if (isSymbolLeftOfAssignment) {\n        addSymbolLeftOfAssignment(token_buf);\n      }\n    } else {\n      if (DEBUG) {\n        console.log(\"still scanning parameters, skipping \" + token_buf);\n      }\n\n      if (isSymbolLeftOfAssignment) {\n        addSymbolRightOfAssignment(\"'\" + token_buf);\n      }\n    }\n\n    if (DEBUG) {\n      console.log(\"found symbol: \" + token_buf + \" left of assignment: \" + isSymbolLeftOfAssignment);\n    }\n\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n\n    return get_next_token();\n  };\n\n  scan_string = function scan_string() {\n    new_string(token_buf);\n    return get_next_token();\n  };\n\n  scan_function_call_with_function_name = function scan_function_call_with_function_name() {\n    var functionName, i, l1, n, p, ref2;\n\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_with_function_name start\");\n    }\n\n    n = 1;\n    p = new U();\n    p = usr_symbol(token_buf);\n    push(p);\n    functionName = token_buf;\n\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.push(token_buf);\n    }\n\n    lastFoundSymbol = token_buf;\n\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n\n    get_next_token();\n    get_next_token();\n    scanningParameters.push(true);\n\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n\n      while (token === ',') {\n        get_next_token();\n\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n            return !new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"sum\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n            return !new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"product\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n            return !new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"for\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n            return !new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n\n        if (functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"defint\") !== -1 && (n === 2 || n > 2 && (n - 2) % 3 === 0)) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n            return !new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n\n        scan_stmt();\n        skipRootVariableToBeSolved = false;\n        n++;\n      }\n\n      if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n        symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n          return !new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + \"x\").test(x);\n        });\n      }\n    }\n\n    scanningParameters.pop();\n\n    for (i = l1 = 0, ref2 = symbolsRightOfAssignment.length; 0 <= ref2 ? l1 <= ref2 : l1 >= ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (symbolsRightOfAssignment[i] != null) {\n        if (functionName === \"roots\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n\n        if (functionName === \"defint\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n\n        if (functionName === \"sum\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n\n        if (functionName === \"product\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n\n        if (functionName === \"for\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n      }\n    }\n\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n\n    get_next_token();\n    list(n);\n\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.pop();\n    }\n\n    if (functionName === symbol(PATTERN).printname) {\n      patternHasBeenFound = true;\n    }\n\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_with_function_name end\");\n    }\n  };\n\n  scan_function_call_without_function_name = function scan_function_call_without_function_name() {\n    var n;\n\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_without_function_name start\");\n    }\n\n    push_symbol(EVAL);\n    swap();\n    list(2);\n    n = 1;\n    get_next_token();\n    scanningParameters.push(true);\n\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n\n      while (token === ',') {\n        get_next_token();\n        scan_stmt();\n        n++;\n      }\n    }\n\n    scanningParameters.pop();\n\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n\n    get_next_token();\n    list(n);\n\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_without_function_name end: \" + stack[tos - 1]);\n    }\n  };\n\n  scan_subexpr = function scan_subexpr() {\n    var n;\n    n = 0;\n\n    if (token !== '(') {\n      scan_error(\"( expected\");\n    }\n\n    get_next_token();\n    scan_stmt();\n\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n\n    return get_next_token();\n  };\n\n  scan_tensor = function scan_tensor() {\n    var n;\n    n = 0;\n\n    if (token !== '[') {\n      scan_error(\"[ expected\");\n    }\n\n    get_next_token();\n    scan_stmt();\n    n = 1;\n\n    while (token === ',') {\n      get_next_token();\n      scan_stmt();\n      n++;\n    }\n\n    build_tensor(n);\n\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n\n    return get_next_token();\n  };\n\n  scan_error = function scan_error(errmsg) {\n    errorMessage = \"\";\n\n    while (input_str !== scan_str) {\n      if ((scanned[input_str] === '\\n' || scanned[input_str] === '\\r') && input_str + 1 === scan_str) {\n        break;\n      }\n\n      errorMessage += scanned[input_str++];\n    }\n\n    errorMessage += \" ? \";\n\n    while (scanned[input_str] && scanned[input_str] !== '\\n' && scanned[input_str] !== '\\r') {\n      errorMessage += scanned[input_str++];\n    }\n\n    errorMessage += '\\n';\n    return stop(errmsg);\n  };\n\n  build_tensor = function build_tensor(n) {\n    var i, l1, ref2;\n    i = 0;\n    save();\n    p2 = alloc_tensor(n);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = n;\n\n    for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.elem[i] = stack[tos - n + i];\n    }\n\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  get_next_token = function get_next_token() {\n    newline_flag = 0;\n\n    while (1) {\n      get_token();\n\n      if (token !== T_NEWLINE) {\n        break;\n      }\n\n      newline_flag = 1;\n    }\n\n    if (DEBUG) {\n      return console.log(\"get_next_token token: \" + token);\n    }\n  };\n\n  get_token = function get_token() {\n    while (isspace(scanned[scan_str])) {\n      if (scanned[scan_str] === '\\n' || scanned[scan_str] === '\\r') {\n        token = T_NEWLINE;\n        scan_str++;\n        return;\n      }\n\n      scan_str++;\n    }\n\n    token_str = scan_str;\n\n    if (scan_str === scanned.length) {\n      token = \"\";\n      return;\n    }\n\n    if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {\n      while (isdigit(scanned[scan_str])) {\n        scan_str++;\n      }\n\n      if (scanned[scan_str] === '.') {\n        scan_str++;\n\n        while (isdigit(scanned[scan_str])) {\n          scan_str++;\n        }\n\n        if (scanned[scan_str] === 'e' && (scanned[scan_str + 1] === '+' || scanned[scan_str + 1] === '-' || isdigit(scanned[scan_str + 1]))) {\n          scan_str += 2;\n\n          while (isdigit(scanned[scan_str])) {\n            scan_str++;\n          }\n        }\n\n        token = T_DOUBLE;\n      } else {\n        token = T_INTEGER;\n      }\n\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n\n    if (isalpha(scanned[scan_str])) {\n      while (isalnumorunderscore(scanned[scan_str])) {\n        scan_str++;\n      }\n\n      if (scanned[scan_str] === '(') {\n        token = T_FUNCTION;\n      } else {\n        token = T_SYMBOL;\n      }\n\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n\n    if (scanned[scan_str] === '\"') {\n      scan_str++;\n\n      while (scanned[scan_str] !== '\"') {\n        if (scan_str === scanned.length - 1) {\n          scan_str++;\n          scan_error(\"runaway string\");\n          scan_str--;\n        }\n\n        scan_str++;\n      }\n\n      scan_str++;\n      token = T_STRING;\n      update_token_buf(token_str + 1, scan_str - 1);\n      return;\n    }\n\n    if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scanned[scan_str + 1] === '-') {\n      while (scanned[scan_str] && scanned[scan_str] !== '\\n' && scanned[scan_str] !== '\\r') {\n        scan_str++;\n      }\n\n      if (scanned[scan_str]) {\n        scan_str++;\n      }\n\n      token = T_NEWLINE;\n      return;\n    }\n\n    if (scanned[scan_str] === ':' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_QUOTASSIGN;\n      return;\n    }\n\n    if (scanned[scan_str] === '=' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_EQ;\n      return;\n    }\n\n    if (scanned[scan_str] === '!' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_NEQ;\n      return;\n    }\n\n    if (scanned[scan_str] === '<' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_LTEQ;\n      return;\n    }\n\n    if (scanned[scan_str] === '>' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_GTEQ;\n      return;\n    }\n\n    return token = scanned[scan_str++];\n  };\n\n  update_token_buf = function update_token_buf(a, b) {\n    return token_buf = scanned.substring(a, b);\n  };\n\n  $.scan = scan;\n\n  Eval_sgn = function Eval_sgn() {\n    push(cadr(p1));\n    Eval();\n    return sgn();\n  };\n\n  sgn = function sgn() {\n    save();\n    yysgn();\n    return restore();\n  };\n\n  yysgn = function yysgn() {\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      if (p1.d > 0) {\n        push_integer(1);\n        return;\n      } else {\n        if (p1.d === 0) {\n          push_integer(1);\n          return;\n        } else {\n          push_integer(-1);\n          return;\n        }\n      }\n    }\n\n    if (isrational(p1)) {\n      if (MSIGN(mmul(p1.q.a, p1.q.b)) === -1) {\n        push_integer(-1);\n        return;\n      } else {\n        if (MZERO(mmul(p1.q.a, p1.q.b))) {\n          push_integer(0);\n          return;\n        } else {\n          push_integer(1);\n          return;\n        }\n      }\n    }\n\n    if (iscomplexnumber(p1)) {\n      push_integer(-1);\n      push(p1);\n\n      _absval();\n\n      power();\n      push(p1);\n      multiply();\n      return;\n    }\n\n    if (isnegativeterm(p1)) {\n      push_symbol(SGN);\n      push(p1);\n      negate();\n      list(2);\n      push_integer(-1);\n      multiply();\n      return;\n    }\n    /*\n    push_integer(2)\n    push(p1)\n    heaviside()\n    multiply()\n    push_integer(-1)\n    add()\n     */\n\n\n    push_symbol(SGN);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_shape = function Eval_shape() {\n    push(cadr(p1));\n    Eval();\n    return shape();\n  };\n\n  shape = function shape() {\n    var ai, an, i, l1, m1, ndim, ref2, ref3, t;\n    i = 0;\n    ndim = 0;\n    t = 0;\n    ai = [];\n    an = [];\n\n    for (i = l1 = 0, ref2 = MAXDIM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n\n    save();\n    p1 = pop();\n\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"transpose: tensor expected, 1st arg is not a tensor\");\n      }\n\n      push(zero);\n      restore();\n      return;\n    }\n\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(ndim);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = ndim;\n\n    for (i = m1 = 0, ref3 = ndim; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push_integer(p1.tensor.dim[i]);\n      p2.tensor.elem[i] = pop();\n    }\n\n    push(p2);\n    return restore();\n  };\n  /*\n   Simplify factorials\n  \n  The following script\n  \n    F(n,k) = k binomial(n,k)\n    (F(n,k) + F(n,k-1)) / F(n+1,k)\n  \n  generates\n  \n         k! n!             n! (1 - k + n)!              k! n!\n   -------------------- + -------------------- - ----------------------\n   (-1 + k)! (1 + n)!     (1 + n)! (-k + n)!     k (-1 + k)! (1 + n)!\n  \n  Simplify each term to get\n  \n      k       1 - k + n       1\n   ------- + ----------- - -------\n    1 + n       1 + n       1 + n\n  \n  Then simplify the sum to get\n  \n      n\n   -------\n    1 + n\n   */\n\n\n  Eval_simfac = function Eval_simfac() {\n    push(cadr(p1));\n    Eval();\n    return simfac();\n  };\n\n  simfac = function simfac() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(ADD)) {\n      h = tos;\n      p1 = cdr(p1);\n\n      while (p1 !== symbol(NIL)) {\n        push(car(p1));\n        simfac_term();\n        p1 = cdr(p1);\n      }\n\n      add_all(tos - h);\n    } else {\n      push(p1);\n      simfac_term();\n    }\n\n    return restore();\n  };\n  /*\n  void\n  simfac(void)\n  {\n    int h\n    save()\n    p1 = pop()\n    if (car(p1) == symbol(ADD)) {\n      h = tos\n      p1 = cdr(p1)\n      while (p1 != symbol(NIL)) {\n        push(car(p1))\n        simfac_term()\n        p1 = cdr(p1)\n      }\n      addk(tos - h)\n      p1 = pop()\n      if (find(p1, symbol(FACTORIAL))) {\n        push(p1)\n        if (car(p1) == symbol(ADD)) {\n          Condense()\n          simfac_term()\n        }\n      }\n    } else {\n      push(p1)\n      simfac_term()\n    }\n    restore()\n  }\n  \n  #endif\n   */\n\n\n  simfac_term = function simfac_term() {\n    var doNothing, h;\n    h = 0;\n    save();\n    p1 = pop();\n\n    if (car(p1) !== symbol(MULTIPLY)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    h = tos;\n    p1 = cdr(p1);\n\n    while (p1 !== symbol(NIL)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n\n    while (yysimfac(h)) {\n      doNothing = 1;\n    }\n\n    multiply_all_noexpand(tos - h);\n    return restore();\n  };\n\n  yysimfac = function yysimfac(h) {\n    var i, j, l1, m1, ref2, ref3, ref4, ref5;\n    i = 0;\n    j = 0;\n\n    for (i = l1 = ref2 = h, ref3 = tos; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      p1 = stack[i];\n\n      for (j = m1 = ref4 = h, ref5 = tos; ref4 <= ref5 ? m1 < ref5 : m1 > ref5; j = ref4 <= ref5 ? ++m1 : --m1) {\n        if (i === j) {\n          continue;\n        }\n\n        p2 = stack[j];\n\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && equal(cadr(p1), cadr(p2))) {\n          push(cadr(p1));\n          push(one);\n          subtract();\n          factorial();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n\n        if (car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL) && equal(p1, cadadr(p2))) {\n          push(p1);\n          push_integer(-1);\n          add();\n          factorial();\n          reciprocate();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n\n        if (car(p2) === symbol(FACTORIAL)) {\n          push(p1);\n          push(cadr(p2));\n          subtract();\n          p3 = pop();\n\n          if (isplusone(p3)) {\n            push(p1);\n            factorial();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n\n        if (car(p1) === symbol(POWER) && isminusone(caddr(p1)) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n\n          if (isplusone(p3)) {\n            push(cadr(p1));\n            factorial();\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n\n          if (isplusone(p3)) {\n            stack[i] = cadr(p1);\n            stack[j] = one;\n            return 1;\n          }\n\n          if (isminusone(p3)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n\n          if (equaln(p3, 2)) {\n            stack[i] = cadr(p1);\n            push(cadr(p1));\n            push_integer(-1);\n            add();\n            stack[j] = pop();\n            return 1;\n          }\n\n          if (equaln(p3, -2)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            push(cadr(cadr(p2)));\n            push_integer(-1);\n            add();\n            reciprocate();\n            stack[j] = pop();\n            return 1;\n          }\n        }\n      }\n    }\n\n    return 0;\n  };\n\n  Eval_simplify = function Eval_simplify() {\n    push(cadr(p1));\n    runUserDefinedSimplifications();\n    Eval();\n    return simplify();\n  };\n\n  runUserDefinedSimplifications = function runUserDefinedSimplifications() {\n    var atLeastOneSuccessInRouldOfRulesApplications, eachConsecutiveRuleApplication, eachSimplification, l1, len, len1, m1, numberOfRulesApplications, originalexpanding, success;\n\n    if (userSimplificationsInListForm.length !== 0 && !_Find(cadr(p1), symbol(INTEGRAL))) {\n      originalexpanding = expanding;\n      expanding = false;\n\n      if (DEBUG) {\n        console.log(\"runUserDefinedSimplifications passed: \" + stack[tos - 1].toString());\n      }\n\n      Eval();\n\n      if (DEBUG) {\n        console.log(\"runUserDefinedSimplifications after eval no expanding: \" + stack[tos - 1].toString());\n      }\n\n      expanding = originalexpanding;\n      p1 = stack[tos - 1];\n\n      if (DEBUG) {\n        console.log(\"patterns to be checked: \");\n      }\n\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        eachSimplification = userSimplificationsInListForm[l1];\n\n        if (DEBUG) {\n          console.log(\"...\" + eachSimplification);\n        }\n      }\n\n      atLeastOneSuccessInRouldOfRulesApplications = true;\n      numberOfRulesApplications = 0;\n\n      while (atLeastOneSuccessInRouldOfRulesApplications && numberOfRulesApplications < MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        atLeastOneSuccessInRouldOfRulesApplications = false;\n        numberOfRulesApplications++;\n\n        for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n          eachSimplification = userSimplificationsInListForm[m1];\n          success = true;\n          eachConsecutiveRuleApplication = 0;\n\n          while (success && eachConsecutiveRuleApplication < MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            eachConsecutiveRuleApplication++;\n\n            if (DEBUG) {\n              console.log(\"simplify - tos: \" + tos + \" checking pattern: \" + eachSimplification + \" on: \" + p1);\n            }\n\n            push_symbol(NIL);\n            success = _transform(eachSimplification, true);\n\n            if (success) {\n              atLeastOneSuccessInRouldOfRulesApplications = true;\n            }\n\n            p1 = stack[tos - 1];\n\n            if (DEBUG) {\n              console.log(\"p1 at this stage of simplification: \" + p1);\n            }\n          }\n\n          if (eachConsecutiveRuleApplication === MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            stop(\"maximum application of single transformation rule exceeded: \" + eachSimplification);\n          }\n        }\n      }\n\n      if (numberOfRulesApplications === MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        stop(\"maximum application of all transformation rules exceeded \");\n      }\n\n      if (DEBUG) {\n        console.log(\"METAX = \" + get_binding(symbol(METAX)));\n        console.log(\"METAA = \" + get_binding(symbol(METAA)));\n        return console.log(\"METAB = \" + get_binding(symbol(METAB)));\n      }\n    }\n  };\n\n  simplifyForCodeGeneration = function simplifyForCodeGeneration() {\n    save();\n    runUserDefinedSimplifications();\n    codeGen = true;\n    simplify_main();\n    codeGen = false;\n    return restore();\n  };\n\n  simplify = function simplify() {\n    save();\n    simplify_main();\n    return restore();\n  };\n\n  simplify_main = function simplify_main() {\n    var args, fbody;\n    p1 = pop();\n\n    if (codeGen && car(p1) === symbol(FUNCTION)) {\n      fbody = cadr(p1);\n      push(fbody);\n      eval();\n      simplify();\n      p3 = pop();\n      args = caddr(p1);\n      push_symbol(FUNCTION);\n      push(p3);\n      push(args);\n      list(3);\n      p1 = pop();\n    }\n\n    if (istensor(p1)) {\n      simplify_tensor();\n      return;\n    }\n\n    if (_Find(p1, symbol(FACTORIAL))) {\n      push(p1);\n      simfac();\n      p2 = pop();\n      push(p1);\n      rationalize();\n      simfac();\n      p3 = pop();\n\n      if (_count(p2) < _count(p3)) {\n        p1 = p2;\n      } else {\n        p1 = p3;\n      }\n    }\n\n    f10();\n    f1();\n    f2();\n    f3();\n    f4();\n    f5();\n    f9();\n    simplify_polarRect();\n\n    if (do_simplify_nested_radicals) {\n      if (simplify_nested_radicals()) {\n        if (DEBUG) {\n          console.log(\"de-nesting successful into: \" + p1.toString());\n        }\n\n        push(p1);\n        simplify();\n        return;\n      }\n    }\n\n    simplify_rectToClock();\n    simplify_rational_expressions();\n    return push(p1);\n  };\n\n  simplify_tensor = function simplify_tensor() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1.tensor.elem[i]);\n      simplify();\n      p2.tensor.elem[i] = pop();\n    }\n\n    check_tensor_dimensions(p2);\n\n    if (isZeroAtomOrTensor(p2)) {\n      p2 = zero;\n    }\n\n    return push(p2);\n  };\n\n  f1 = function f1() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n\n    push(p1);\n    rationalize();\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  f2 = function f2() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n\n    push(p1);\n    Condense();\n    p2 = pop();\n\n    if (_count(p2) <= _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  f3 = function f3() {\n    push(p1);\n    rationalize();\n    negate();\n    rationalize();\n    negate();\n    rationalize();\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  f10 = function f10() {\n    var a, b, carp1, miao, originalexpanding;\n    carp1 = car(p1);\n    miao = cdr(p1);\n\n    if (carp1 === symbol(MULTIPLY) || isinnerordot(p1)) {\n      if (car(car(cdr(p1))) === symbol(TRANSPOSE) && car(car(cdr(cdr(p1)))) === symbol(TRANSPOSE)) {\n        if (DEBUG) {\n          console.log(\"maybe collecting a transpose \" + p1);\n        }\n\n        a = cadr(car(cdr(p1)));\n        b = cadr(car(cdr(cdr(p1))));\n\n        if (carp1 === symbol(MULTIPLY)) {\n          push(a);\n          push(b);\n          multiply();\n        } else if (isinnerordot(p1)) {\n          push(b);\n          push(a);\n\n          _inner();\n        }\n\n        push_integer(1);\n        push_integer(2);\n        originalexpanding = expanding;\n        expanding = false;\n\n        _transpose();\n\n        expanding = originalexpanding;\n        p2 = pop();\n\n        if (_count(p2) < _count(p1)) {\n          p1 = p2;\n        }\n\n        if (DEBUG) {\n          return console.log(\"collecting a transpose \" + p2);\n        }\n      }\n    }\n  };\n\n  f4 = function f4() {\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n\n    push(p1);\n    rationalize();\n    inverse();\n    rationalize();\n    inverse();\n    rationalize();\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_trig = function simplify_trig() {\n    save();\n    p1 = pop();\n    f5();\n    push(p1);\n    return restore();\n  };\n\n  f5 = function f5() {\n    if (_Find(p1, symbol(SIN)) === 0 && _Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n\n    p2 = p1;\n    trigmode = 1;\n    push(p2);\n    Eval();\n    p3 = pop();\n    trigmode = 2;\n    push(p2);\n    Eval();\n    p4 = pop();\n    trigmode = 0;\n\n    if (_count(p4) < _count(p3) || nterms(p4) < nterms(p3)) {\n      p3 = p4;\n    }\n\n    if (_count(p3) < _count(p1) || nterms(p3) < nterms(p1)) {\n      return p1 = p3;\n    }\n  };\n\n  f9 = function f9() {\n    var oldp1, oldp2;\n\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n\n    push_integer(0);\n    p2 = cdr(p1);\n\n    while (iscons(p2)) {\n      push(car(p2));\n      simplify();\n      add();\n      oldp1 = p1;\n      oldp2 = p2;\n      p1 = pop();\n      simplify_rational_expressions();\n      push(p1);\n      p1 = oldp1;\n      p2 = oldp2;\n      p2 = cdr(p2);\n    }\n\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_rational_expressions = function simplify_rational_expressions() {\n    var denom, num, polyVar, sasa, theGCD;\n    push(p1);\n\n    _denominator();\n\n    denom = pop();\n\n    if (isone(denom)) {\n      return;\n    }\n\n    push(p1);\n\n    _numerator();\n\n    num = pop();\n\n    if (isone(num)) {\n      return;\n    }\n\n    if (!(polyVar = areunivarpolysfactoredorexpandedform(num, denom))) {\n      return;\n    }\n\n    push(num);\n    push(denom);\n    gcd();\n    push(polyVar);\n    factor();\n    theGCD = pop();\n\n    if (isone(theGCD)) {\n      return;\n    }\n\n    push(num);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    push(denom);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    divide();\n    Condense();\n    sasa = stack[tos - 1].toString();\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_rectToClock = function simplify_rectToClock() {\n    if (_Find(p1, symbol(SIN)) === 0 && _Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n\n    push(p1);\n    Eval();\n    clockform();\n    p2 = pop();\n\n    if (DEBUG) {\n      console.log(\"before simplification clockform: \" + p1 + \" after: \" + p2);\n    }\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_polarRect = function simplify_polarRect() {\n    push(p1);\n\n    _polarRectAMinusOneBase();\n\n    Eval();\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  _polarRectAMinusOneBase = function polarRectAMinusOneBase() {\n    var h;\n    save();\n    p1 = pop();\n\n    if (isimaginaryunit(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (equal(car(p1), symbol(POWER)) && isminusone(cadr(p1))) {\n      push(one);\n      negate();\n      push(caddr(p1));\n\n      _polarRectAMinusOneBase();\n\n      power();\n      polar();\n\n      _rect();\n    } else if (iscons(p1)) {\n      h = tos;\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _polarRectAMinusOneBase();\n\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n\n    restore();\n  };\n\n  nterms = function nterms(p) {\n    if (car(p) !== symbol(ADD)) {\n      return 1;\n    } else {\n      return length(p) - 1;\n    }\n  };\n\n  simplify_nested_radicals = function simplify_nested_radicals() {\n    var prev_expanding, simplificationWithCondense, simplificationWithoutCondense, somethingSimplified;\n\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n\n      return false;\n    }\n\n    push(p1);\n    somethingSimplified = _take_care_of_nested_radicals();\n    simplificationWithoutCondense = stack[tos - 1];\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    simplificationWithCondense = pop();\n\n    if (_countOccurrencesOfSymbol(symbol(POWER), simplificationWithoutCondense) < _countOccurrencesOfSymbol(symbol(POWER), simplificationWithCondense)) {\n      push(simplificationWithoutCondense);\n    } else {\n      push(simplificationWithCondense);\n    }\n\n    p1 = pop();\n    return somethingSimplified;\n  };\n\n  _take_care_of_nested_radicals = function take_care_of_nested_radicals() {\n    var A, B, C, SOLUTION, anyRadicalSimplificationWorked, base, checkSize, commonBases, commonInnerExponent, countingTerms, eachSolution, exponent, firstTerm, h, i, innerbase, innerexponent, l1, len, len1, len2, len3, lowercase_a, lowercase_b, m1, n1, numberOfTerms, o1, possibleNewExpression, possibleNewExpressionValue, possibleRationalSolutions, possibleSolutions, potentialPower, realOfpossibleRationalSolutions, ref2, secondTerm, secondTermFactor, termsThatAreNotPowers, whichRationalSolution;\n\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n\n      return false;\n    }\n\n    save();\n    p1 = pop();\n\n    if (equal(car(p1), symbol(POWER))) {\n      base = cadr(p1);\n      exponent = caddr(p1);\n\n      if (!isminusone(exponent) && equal(car(base), symbol(ADD)) && isfraction(exponent) && (equalq(exponent, 1, 3) || equalq(exponent, 1, 2))) {\n        firstTerm = cadr(base);\n        push(firstTerm);\n\n        _take_care_of_nested_radicals();\n\n        pop();\n        secondTerm = caddr(base);\n        push(secondTerm);\n\n        _take_care_of_nested_radicals();\n\n        pop();\n        numberOfTerms = 0;\n        countingTerms = base;\n\n        while (cdr(countingTerms) !== symbol(NIL)) {\n          numberOfTerms++;\n          countingTerms = cdr(countingTerms);\n        }\n\n        if (numberOfTerms > 2) {\n          push(p1);\n          restore();\n          return false;\n        }\n\n        commonInnerExponent = null;\n        commonBases = [];\n        termsThatAreNotPowers = [];\n\n        if (car(secondTerm) === symbol(MULTIPLY)) {\n          secondTermFactor = cdr(secondTerm);\n\n          if (iscons(secondTermFactor)) {\n            while (iscons(secondTermFactor)) {\n              potentialPower = car(secondTermFactor);\n\n              if (car(potentialPower) === symbol(POWER)) {\n                innerbase = cadr(potentialPower);\n                innerexponent = caddr(potentialPower);\n\n                if (equalq(innerexponent, 1, 2)) {\n                  if (commonInnerExponent == null) {\n                    commonInnerExponent = innerexponent;\n                    commonBases.push(innerbase);\n                  } else {\n                    if (equal(innerexponent, commonInnerExponent)) {\n                      commonBases.push(innerbase);\n                    } else {}\n                  }\n                }\n              } else {\n                termsThatAreNotPowers.push(potentialPower);\n              }\n\n              secondTermFactor = cdr(secondTermFactor);\n            }\n          }\n        } else if (car(secondTerm) === symbol(POWER)) {\n          innerbase = cadr(secondTerm);\n          innerexponent = caddr(secondTerm);\n\n          if (commonInnerExponent == null && equalq(innerexponent, 1, 2)) {\n            commonInnerExponent = innerexponent;\n            commonBases.push(innerbase);\n          }\n        }\n\n        if (commonBases.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n\n        A = firstTerm;\n        push_integer(1);\n\n        for (l1 = 0, len = commonBases.length; l1 < len; l1++) {\n          i = commonBases[l1];\n          push(i);\n          multiply();\n        }\n\n        C = pop();\n        push_integer(1);\n\n        for (m1 = 0, len1 = termsThatAreNotPowers.length; m1 < len1; m1++) {\n          i = termsThatAreNotPowers[m1];\n          push(i);\n          multiply();\n        }\n\n        B = pop();\n\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          negate();\n          push(C);\n          multiply();\n          push(B);\n          divide();\n          checkSize = pop();\n          push(checkSize);\n          real();\n\n          _yyfloat();\n\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n\n          push(checkSize);\n          push_integer(3);\n          push(C);\n          multiply();\n          checkSize = pop();\n          push(checkSize);\n          real();\n\n          _yyfloat();\n\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n\n          push(checkSize);\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(-3);\n          push(A);\n          multiply();\n          push(B);\n          divide();\n          checkSize = pop();\n          push(checkSize);\n          real();\n\n          _yyfloat();\n\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n\n          push(checkSize);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push_integer(1);\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          multiply();\n          add();\n          add();\n          add();\n        } else if (equalq(exponent, 1, 2)) {\n          push(C);\n          checkSize = pop();\n          push(checkSize);\n          real();\n\n          _yyfloat();\n\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n\n          push(checkSize);\n          push_integer(-2);\n          push(A);\n          multiply();\n          push(B);\n          divide();\n          checkSize = pop();\n          push(checkSize);\n          real();\n\n          _yyfloat();\n\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n\n          push(checkSize);\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(1);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n        }\n\n        push(symbol(SECRETX));\n        recursionLevelNestedRadicalsRemoval++;\n        roots();\n        recursionLevelNestedRadicalsRemoval--;\n\n        if (equal(stack[tos - 1], symbol(NIL))) {\n          if (DEBUG) {\n            console.log(\"roots bailed out because of too much recursion\");\n          }\n\n          pop();\n          push(p1);\n          restore();\n          return false;\n        }\n\n        possibleSolutions = [];\n        ref2 = stack[tos - 1].tensor.elem;\n\n        for (n1 = 0, len2 = ref2.length; n1 < len2; n1++) {\n          eachSolution = ref2[n1];\n\n          if (!_Find(eachSolution, symbol(POWER))) {\n            possibleSolutions.push(eachSolution);\n          }\n        }\n\n        pop();\n\n        if (possibleSolutions.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n\n        possibleRationalSolutions = [];\n        realOfpossibleRationalSolutions = [];\n\n        for (o1 = 0, len3 = possibleSolutions.length; o1 < len3; o1++) {\n          i = possibleSolutions[o1];\n          push(i);\n          real();\n\n          _yyfloat();\n\n          possibleRationalSolutions.push(i);\n          realOfpossibleRationalSolutions.push(pop().d);\n        }\n\n        whichRationalSolution = realOfpossibleRationalSolutions.indexOf(Math.max.apply(Math, realOfpossibleRationalSolutions));\n        SOLUTION = possibleRationalSolutions[whichRationalSolution];\n        /*\n        #possibleNewExpressions = []\n        #realOfPossibleNewExpressions = []\n         * pick the solution which cubic root has no radicals\n        lowercase_b = null\n        for SOLUTION in possibleSolutions\n          console.log(\"testing solution: \" + SOLUTION.toString())\n        \n          debugger\n          if equalq(exponent,1,3)\n            push(A)\n            push(SOLUTION)\n            push_integer(3)\n            power()\n            push_integer(3)\n            push(C)\n            multiply()\n            push(SOLUTION)\n            multiply()\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,3)\n            power()\n          else if equalq(exponent,1,2)\n            push(A)\n            push(SOLUTION)\n            push_integer(2)\n            power()\n            push(C)\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,2)\n            power()\n          console.log(\"b is: \" + stack[tos-1].toString())\n        \n          lowercase_b = pop()\n        \n          if !Find(lowercase_b, symbol(POWER))\n            break\n         */\n\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(3);\n          power();\n          push_integer(3);\n          push(C);\n          multiply();\n          push(SOLUTION);\n          multiply();\n          add();\n          divide();\n          push_rational(1, 3);\n          power();\n        } else if (equalq(exponent, 1, 2)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(2);\n          power();\n          push(C);\n          add();\n          divide();\n          push_rational(1, 2);\n          power();\n        }\n\n        lowercase_b = pop();\n\n        if (lowercase_b == null) {\n          push(p1);\n          restore();\n          return false;\n        }\n\n        push(lowercase_b);\n        push(SOLUTION);\n        multiply();\n\n        if (equalq(exponent, 1, 3)) {\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n        } else if (equalq(exponent, 1, 2)) {\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n          possibleNewExpression = pop();\n          push(possibleNewExpression);\n          real();\n\n          _yyfloat();\n\n          possibleNewExpressionValue = pop();\n\n          if (!isnegativenumber(possibleNewExpressionValue)) {\n            push(possibleNewExpression);\n          } else {\n            push(lowercase_b);\n            negate();\n            lowercase_b = pop();\n            push(lowercase_a);\n            negate();\n            lowercase_a = pop();\n            push(lowercase_b);\n            push(C);\n            push_rational(1, 2);\n            power();\n            multiply();\n            push(lowercase_a);\n            add();\n            simplify();\n          }\n        }\n\n        p1 = pop();\n        push(p1);\n        restore();\n        return true;\n      } else {\n        push(p1);\n        restore();\n        return false;\n      }\n    } else if (iscons(p1)) {\n      h = tos;\n      anyRadicalSimplificationWorked = false;\n\n      while (iscons(p1)) {\n        push(car(p1));\n        anyRadicalSimplificationWorked = anyRadicalSimplificationWorked || _take_care_of_nested_radicals();\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n      restore();\n      return anyRadicalSimplificationWorked;\n    } else {\n      push(p1);\n      restore();\n      return false;\n    }\n\n    throw new Error(\"control flow should never reach here\");\n  };\n\n  Eval_sin = function Eval_sin() {\n    push(cadr(p1));\n    Eval();\n    return sine();\n  };\n\n  sine = function sine() {\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(ADD)) {\n      sine_of_angle_sum();\n    } else {\n      sine_of_angle();\n    }\n\n    return restore();\n  };\n\n  sine_of_angle_sum = function sine_of_angle_sum() {\n    p2 = cdr(p1);\n\n    while (iscons(p2)) {\n      p4 = car(p2);\n\n      if (isnpi(p4)) {\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        sine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        cosine();\n        push(p4);\n        sine();\n        multiply();\n        add();\n        return;\n      }\n\n      p2 = cdr(p2);\n    }\n\n    return sine_of_angle();\n  };\n\n  sine_of_angle = function sine_of_angle() {\n    var d, n;\n\n    if (car(p1) === symbol(ARCSIN)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.sin(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      sine();\n      negate();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      multiply();\n      return;\n    }\n\n    push(p1);\n    push_integer(180);\n    multiply();\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n\n    divide();\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push(symbol(SIN));\n      push(p1);\n      list(2);\n      return;\n    }\n\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n\n      case 30:\n      case 150:\n        return push_rational(1, 2);\n\n      case 210:\n      case 330:\n        return push_rational(-1, 2);\n\n      case 45:\n      case 135:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 225:\n      case 315:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 60:\n      case 120:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 240:\n      case 300:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 90:\n        return push_integer(1);\n\n      case 270:\n        return push_integer(-1);\n\n      default:\n        push(symbol(SIN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  Eval_sinh = function Eval_sinh() {\n    push(cadr(p1));\n    Eval();\n    return ysinh();\n  };\n\n  ysinh = function ysinh() {\n    save();\n    yysinh();\n    return restore();\n  };\n\n  yysinh = function yysinh() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (car(p1) === symbol(ARCSINH)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.sinh(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n\n    push_symbol(SINH);\n    push(p1);\n    return list(2);\n  };\n  /*\n    Substitute new expr for old expr in expr.\n  \n    Input:  push  expr\n  \n      push  old expr\n  \n      push  new expr\n  \n    Output:  Result on stack\n   */\n\n\n  _subst = function subst() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    save();\n    p3 = pop();\n    p2 = pop();\n\n    if (p2 === symbol(NIL) || p3 === symbol(NIL)) {\n      restore();\n      return;\n    }\n\n    p1 = pop();\n\n    if (istensor(p1)) {\n      p4 = alloc_tensor(p1.tensor.nelem);\n      p4.tensor.ndim = p1.tensor.ndim;\n\n      for (i = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        p4.tensor.dim[i] = p1.tensor.dim[i];\n      }\n\n      for (i = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n        push(p1.tensor.elem[i]);\n        push(p2);\n        push(p3);\n\n        _subst();\n\n        p4.tensor.elem[i] = pop();\n        check_tensor_dimensions(p4);\n      }\n\n      push(p4);\n    } else if (equal(p1, p2)) {\n      push(p3);\n    } else if (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      push(p3);\n\n      _subst();\n\n      push(cdr(p1));\n      push(p2);\n      push(p3);\n\n      _subst();\n\n      cons();\n    } else {\n      push(p1);\n    }\n\n    return restore();\n  };\n\n  Eval_sum = function Eval_sum() {\n    var body, i, indexVariable, j, k, l1, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    body = cadr(p1);\n    indexVariable = caddr(p1);\n\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n\n    p4 = get_binding(indexVariable);\n    push_integer(0);\n\n    for (i = l1 = ref2 = j, ref3 = k; ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n      add();\n    }\n\n    return set_binding(indexVariable, p4);\n  };\n\n  Eval_tan = function Eval_tan() {\n    push(cadr(p1));\n    Eval();\n    return tangent();\n  };\n\n  tangent = function tangent() {\n    save();\n    yytangent();\n    return restore();\n  };\n\n  yytangent = function yytangent() {\n    var d, n;\n    n = 0;\n    d = 0.0;\n    p1 = pop();\n\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.tan(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      tangent();\n      negate();\n      return;\n    }\n\n    push(p1);\n    push_integer(180);\n    multiply();\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n\n    divide();\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push(symbol(TAN));\n      push(p1);\n      list(2);\n      return;\n    }\n\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n\n      case 30:\n      case 210:\n        push_rational(1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 150:\n      case 330:\n        push_rational(-1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 45:\n      case 225:\n        return push_integer(1);\n\n      case 135:\n      case 315:\n        return push_integer(-1);\n\n      case 60:\n      case 240:\n        push_integer(3);\n        push_rational(1, 2);\n        return power();\n\n      case 120:\n      case 300:\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return negate();\n\n      default:\n        push(symbol(TAN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  Eval_tanh = function Eval_tanh() {\n    var d;\n    d = 0.0;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n\n    if (car(p1) === symbol(ARCTANH)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.tanh(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n\n    push_symbol(TANH);\n    push(p1);\n    return list(2);\n  };\n  /*\n  Taylor expansion of a function\n  \n    push(F)\n    push(X)\n    push(N)\n    push(A)\n    taylor()\n   */\n\n\n  Eval_taylor = function Eval_taylor() {\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      push_integer(24);\n    } else {\n      push(p2);\n    }\n\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n\n    return taylor();\n  };\n\n  taylor = function taylor() {\n    var i, k, l1, ref2;\n    i = 0;\n    k = 0;\n    save();\n    p4 = pop();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p3);\n    k = pop_integer();\n\n    if (isNaN(k)) {\n      push_symbol(TAYLOR);\n      push(p1);\n      push(p2);\n      push(p3);\n      push(p4);\n      list(5);\n      restore();\n      return;\n    }\n\n    push(p1);\n    push(p2);\n    push(p4);\n\n    _subst();\n\n    Eval();\n    push_integer(1);\n    p5 = pop();\n\n    for (i = l1 = 1, ref2 = k; 1 <= ref2 ? l1 <= ref2 : l1 >= ref2; i = 1 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(p2);\n      derivative();\n      p1 = pop();\n\n      if (isZeroAtomOrTensor(p1)) {\n        break;\n      }\n\n      push(p5);\n      push(p2);\n      push(p4);\n      subtract();\n      multiply();\n      p5 = pop();\n      push(p1);\n      push(p2);\n      push(p4);\n\n      _subst();\n\n      Eval();\n      push(p5);\n      multiply();\n      push_integer(i);\n      factorial();\n      divide();\n      add();\n    }\n\n    return restore();\n  };\n  /* tensor =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  General description\n  -------------------\n  Tensors are a strange in-between of matrices and \"computer\"\n  rectangular data structures.\n  \n  Tensors, unlike matrices, and like rectangular data structures,\n  can have an arbitrary number of dimensions (rank), although a tensor with\n  rank zero is just a scalar.\n  \n  Tensors, like matrices and unlike many computer rectangular data structures,\n  must be \"contiguous\" i.e. have no empty spaces within its size, and \"uniform\",\n  i.e. each element must have the same shape and hence the same rank.\n  \n  Also tensors have necessarily to make a distinction between row vectors,\n  column vectors (which have a rank of 2) and uni-dimensional vectors (rank 1).\n  They look very similar but they are fundamentally different.\n  \n  Tensors are 1-indexed, as per general math notation, and like Fortran,\n  Lua, Mathematica, SASL, MATLAB, Julia, Erlang and APL.\n  \n  Tensors with elements that are also tensors get promoted to a higher rank\n  , this is so we can represent and get the rank of a matrix correctly.\n  Example:\n  Start with a tensor of rank 1 with 2 elements (i.e. shape: 2)\n  if you put in both its elements another 2 tensors\n  of rank 1 with 2 elements (i.e. shape: 2)\n  then the result is a tensor of rank 2 with shape 2,2\n  i.e. the dimension of a tensor at all times must be\n  the number of nested tensors in it.\n  Also, all tensors must be \"uniform\" i.e. they must be accessed\n  uniformly, which means that all existing elements of a tensor\n  must be contiguous and have the same shape.\n  Implication of it all is that you can't put arbitrary\n  tensors inside tensors (like you would do to represent block matrices)\n  Rather, all tensors inside tensors must have same shape (and hence, rank)\n  \n  Limitations\n  -----------\n  n.a.\n  \n  Implementation info\n  -------------------\n  Tensors are implemented...\n   */\n\n\n  Eval_tensor = function Eval_tensor() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    check_tensor_dimensions(p1);\n    nelem = p1.tensor.nelem;\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n\n    for (i = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    check_tensor_dimensions(p2);\n\n    for (i = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      Eval();\n      b[i] = pop();\n    }\n\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    push(p2);\n    return promote_tensor();\n  };\n\n  tensor_plus_tensor = function tensor_plus_tensor() {\n    var a, b, c, i, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p1.tensor.ndim;\n\n    if (ndim !== p2.tensor.ndim) {\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n\n    for (i = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] !== p2.tensor.dim[i]) {\n        push(symbol(NIL));\n        restore();\n        return;\n      }\n    }\n\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n\n    for (i = m1 = 0, ref3 = ndim; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n\n    for (i = n1 = 0, ref4 = nelem; 0 <= ref4 ? n1 < ref4 : n1 > ref4; i = 0 <= ref4 ? ++n1 : --n1) {\n      push(a[i]);\n      push(b[i]);\n      add();\n      c[i] = pop();\n    }\n\n    push(p3);\n    return restore();\n  };\n\n  tensor_times_scalar = function tensor_times_scalar() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n\n    for (i = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n\n    for (i = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      multiply();\n      b[i] = pop();\n    }\n\n    push(p3);\n    return restore();\n  };\n\n  scalar_times_tensor = function scalar_times_tensor() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p2.tensor.ndim;\n    nelem = p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n\n    for (i = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p2.tensor.dim[i];\n    }\n\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n\n    for (i = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n      push(a[i]);\n      multiply();\n      b[i] = pop();\n    }\n\n    push(p3);\n    return restore();\n  };\n\n  check_tensor_dimensions = function check_tensor_dimensions(p) {\n    if (p.tensor.nelem !== p.tensor.elem.length) {\n      console.log(\"something wrong in tensor dimensions\");\n      debugger;\n    }\n  };\n\n  is_square_matrix = function is_square_matrix(p) {\n    if (istensor(p) && p.tensor.ndim === 2 && p.tensor.dim[0] === p.tensor.dim[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  d_tensor_tensor = function d_tensor_tensor() {\n    var a, b, c, i, j, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    ndim = 0;\n    nelem = 0;\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n\n    if (ndim + 1 >= MAXDIM) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    p3 = alloc_tensor(nelem * p2.tensor.nelem);\n    p3.tensor.ndim = ndim + 1;\n\n    for (i = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    p3.tensor.dim[ndim] = p2.tensor.dim[0];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n\n    for (i = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      for (j = n1 = 0, ref4 = p2.tensor.nelem; 0 <= ref4 ? n1 < ref4 : n1 > ref4; j = 0 <= ref4 ? ++n1 : --n1) {\n        push(a[i]);\n        push(b[j]);\n        derivative();\n        c[i * p2.tensor.nelem + j] = pop();\n      }\n    }\n\n    return push(p3);\n  };\n\n  d_scalar_tensor = function d_scalar_tensor() {\n    var a, b, i, l1, ref2;\n    p3 = alloc_tensor(p2.tensor.nelem);\n    p3.tensor.ndim = 1;\n    p3.tensor.dim[0] = p2.tensor.dim[0];\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n\n    for (i = l1 = 0, ref2 = p2.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(a[i]);\n      derivative();\n      b[i] = pop();\n    }\n\n    return push(p3);\n  };\n\n  d_tensor_scalar = function d_tensor_scalar() {\n    var a, b, i, l1, m1, ref2, ref3;\n    i = 0;\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      derivative();\n      b[i] = pop();\n    }\n\n    return push(p3);\n  };\n\n  compare_tensors = function compare_tensors(p1, p2) {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n\n    if (p1.tensor.ndim < p2.tensor.ndim) {\n      return -1;\n    }\n\n    if (p1.tensor.ndim > p2.tensor.ndim) {\n      return 1;\n    }\n\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n        return -1;\n      }\n\n      if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n        return 1;\n      }\n    }\n\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      if (equal(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        continue;\n      }\n\n      if (lessp(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    return 0;\n  };\n\n  power_tensor = function power_tensor() {\n    var i, k, l1, m1, n, ref2, ref3, results;\n    i = 0;\n    k = 0;\n    n = 0;\n    k = p1.tensor.ndim - 1;\n\n    if (p1.tensor.dim[0] !== p1.tensor.dim[k]) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    push(p2);\n    n = pop_integer();\n\n    if (isNaN(n)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    if (n === 0) {\n      if (p1.tensor.ndim !== 2) {\n        stop(\"power(tensor,0) with tensor rank not equal to 2\");\n      }\n\n      n = p1.tensor.dim[0];\n      p1 = alloc_tensor(n * n);\n      p1.tensor.ndim = 2;\n      p1.tensor.dim[0] = n;\n      p1.tensor.dim[1] = n;\n\n      for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        p1.tensor.elem[n * i + i] = one;\n      }\n\n      check_tensor_dimensions(p1);\n      push(p1);\n      return;\n    }\n\n    if (n < 0) {\n      n = -n;\n      push(p1);\n\n      _inv();\n\n      p1 = pop();\n    }\n\n    push(p1);\n    results = [];\n\n    for (i = m1 = 1, ref3 = n; 1 <= ref3 ? m1 < ref3 : m1 > ref3; i = 1 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n\n      _inner();\n\n      if (isZeroAtomOrTensor(stack[tos - 1])) {\n        break;\n      } else {\n        results.push(void 0);\n      }\n    }\n\n    return results;\n  };\n\n  copy_tensor = function copy_tensor() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    save();\n    p1 = pop();\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[i];\n    }\n\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    push(p2);\n    return restore();\n  };\n\n  promote_tensor = function promote_tensor() {\n    var i, j, k, l1, m1, n1, ndim, nelem, o1, q1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    j = 0;\n    k = 0;\n    nelem = 0;\n    ndim = 0;\n    save();\n    p1 = pop();\n\n    if (!istensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    p2 = p1.tensor.elem[0];\n\n    for (i = l1 = 1, ref2 = p1.tensor.nelem; 1 <= ref2 ? l1 < ref2 : l1 > ref2; i = 1 <= ref2 ? ++l1 : --l1) {\n      if (!compatible(p2, p1.tensor.elem[i])) {\n        stop(\"Cannot promote tensor due to inconsistent tensor components.\");\n      }\n    }\n\n    if (!istensor(p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n\n    if (ndim > MAXDIM) {\n      stop(\"tensor rank > \" + MAXDIM);\n    }\n\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n\n    for (i = m1 = 0, ref3 = p1.tensor.ndim; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    for (j = n1 = 0, ref4 = p2.tensor.ndim; 0 <= ref4 ? n1 < ref4 : n1 > ref4; j = 0 <= ref4 ? ++n1 : --n1) {\n      p3.tensor.dim[i + j] = p2.tensor.dim[j];\n    }\n\n    k = 0;\n\n    for (i = o1 = 0, ref5 = p1.tensor.nelem; 0 <= ref5 ? o1 < ref5 : o1 > ref5; i = 0 <= ref5 ? ++o1 : --o1) {\n      p2 = p1.tensor.elem[i];\n\n      for (j = q1 = 0, ref6 = p2.tensor.nelem; 0 <= ref6 ? q1 < ref6 : q1 > ref6; j = 0 <= ref6 ? ++q1 : --q1) {\n        p3.tensor.elem[k++] = p2.tensor.elem[j];\n      }\n    }\n\n    check_tensor_dimensions(p2);\n    check_tensor_dimensions(p3);\n    push(p3);\n    return restore();\n  };\n\n  compatible = function compatible(p, q) {\n    var i, l1, ref2;\n\n    if (!istensor(p) && !istensor(q)) {\n      return 1;\n    }\n\n    if (!istensor(p) || !istensor(q)) {\n      return 0;\n    }\n\n    if (p.tensor.ndim !== q.tensor.ndim) {\n      return 0;\n    }\n\n    for (i = l1 = 0, ref2 = p.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p.tensor.dim[i] !== q.tensor.dim[i]) {\n        return 0;\n      }\n    }\n\n    return 1;\n  };\n\n  Eval_test = function Eval_test() {\n    var checkResult, orig;\n    orig = p1;\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      if (cdr(p1) === symbol(NIL)) {\n        push(car(p1));\n        Eval();\n        return;\n      }\n\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(p1));\n\n      if (checkResult == null) {\n        push(orig);\n        return;\n      } else if (checkResult) {\n        push(cadr(p1));\n        Eval();\n        return;\n      } else {\n        p1 = cddr(p1);\n      }\n    }\n\n    return push_integer(0);\n  };\n\n  Eval_testeq = function Eval_testeq() {\n    var checkResult, orig, subtractionResult;\n    orig = p1;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    subtract();\n    subtractionResult = pop();\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if (checkResult != null && !checkResult) {\n      push_integer(1);\n      return;\n    }\n\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    subtractionResult = pop();\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if (checkResult != null && !checkResult) {\n      push_integer(1);\n      return;\n    }\n\n    return push(orig);\n  };\n\n  Eval_testge = function Eval_testge() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n\n    if (comparison >= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testgt = function Eval_testgt() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n\n    if (comparison > 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testle = function Eval_testle() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n\n    if (comparison <= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testlt = function Eval_testlt() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n\n    if (comparison < 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_not = function Eval_not() {\n    var checkResult, wholeAndExpression;\n    wholeAndExpression = p1;\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n\n    if (checkResult == null) {\n      return push(wholeAndExpression);\n    } else if (checkResult) {\n      return push_integer(0);\n    } else {\n      return push_integer(1);\n    }\n  };\n  /* and =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  a,b,...\n  \n  General description\n  -------------------\n  Logical-and of predicate expressions.\n   */\n\n\n  Eval_and = function Eval_and() {\n    var andPredicates, checkResult, somePredicateUnknown, wholeAndExpression;\n    wholeAndExpression = p1;\n    andPredicates = cdr(wholeAndExpression);\n    somePredicateUnknown = false;\n\n    while (iscons(andPredicates)) {\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(andPredicates));\n\n      if (checkResult == null) {\n        somePredicateUnknown = true;\n        andPredicates = cdr(andPredicates);\n      } else if (checkResult) {\n        andPredicates = cdr(andPredicates);\n      } else if (!checkResult) {\n        push_integer(0);\n        return;\n      }\n    }\n\n    if (somePredicateUnknown) {\n      return push(wholeAndExpression);\n    } else {\n      return push_integer(1);\n    }\n  };\n\n  Eval_or = function Eval_or() {\n    var checkResult, orPredicates, somePredicateUnknown, wholeOrExpression;\n    wholeOrExpression = p1;\n    orPredicates = cdr(wholeOrExpression);\n    somePredicateUnknown = false;\n\n    while (iscons(orPredicates)) {\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(orPredicates));\n\n      if (checkResult == null) {\n        somePredicateUnknown = true;\n        orPredicates = cdr(orPredicates);\n      } else if (checkResult) {\n        push_integer(1);\n        return;\n      } else if (!checkResult) {\n        orPredicates = cdr(orPredicates);\n      }\n    }\n\n    if (somePredicateUnknown) {\n      return push(wholeOrExpression);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  cmp_args = function cmp_args() {\n    var t;\n    t = 0;\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    p1 = pop();\n\n    if (p1.k !== NUM && p1.k !== DOUBLE) {\n      push(p1);\n\n      _yyfloat();\n\n      Eval();\n      p1 = pop();\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      return 0;\n    }\n\n    switch (p1.k) {\n      case NUM:\n        if (MSIGN(p1.q.a) === -1) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p1.d < 0.0) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n\n        break;\n\n      default:\n        t = null;\n    }\n\n    return t;\n  };\n  /*\n  Transform an expression using a pattern. The\n  pattern can come from the integrals table or\n  the user-defined patterns.\n  \n  The expression and free variable are on the stack.\n  \n  The argument s is a null terminated list of transform rules.\n  \n  For example, see the itab (integrals table)\n  \n  Internally, the following symbols are used:\n  \n    F  input expression\n  \n    X  free variable, i.e. F of X\n  \n    A  template expression\n  \n    B  result expression\n  \n    C  list of conditional expressions\n  \n  Puts the final expression on top of stack\n  (whether it's transformed or not) and returns\n  true is successful, false if not.\n   */\n\n\n  _transform = function transform(s, generalTransform) {\n    var bookmarkTosToPrintDecomps, eachTransformEntry, i, l1, len, len1, m1, n1, numberOfDecomps, ref2, restTerm, secondTerm, success, theTransform, transform_h, transformationSuccessful, transformedTerms;\n    transform_h = 0;\n    save();\n    p1 = null;\n    p4 = pop();\n    p3 = pop();\n\n    if (DEBUG) {\n      console.log(\"         !!!!!!!!!   transform on: \" + p3);\n    }\n\n    saveMetaBindings();\n    set_binding(symbol(METAX), p4);\n    transform_h = tos;\n    push_integer(1);\n    push(p3);\n    push(p4);\n\n    _polyform();\n\n    push(p4);\n    bookmarkTosToPrintDecomps = tos - 2;\n\n    _decomp(generalTransform);\n\n    numberOfDecomps = tos - bookmarkTosToPrintDecomps;\n\n    if (DEBUG) {\n      console.log(\"  \" + numberOfDecomps + \" decomposed elements ====== \");\n\n      for (i = l1 = 0, ref2 = numberOfDecomps; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        console.log(\"  decomposition element \" + i + \": \" + stack[tos - 1 - i]);\n      }\n    }\n\n    transformationSuccessful = false;\n\n    if (generalTransform) {\n      if (!isNumericAtom(p3)) {\n        theTransform = s;\n\n        if (DEBUG) {\n          console.log(\"applying transform: \" + theTransform);\n        }\n\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + theTransform);\n        }\n\n        push(theTransform);\n        push(symbol(SYMBOL_A_UNDERSCORE));\n        push(symbol(METAA));\n\n        _subst();\n\n        push(symbol(SYMBOL_B_UNDERSCORE));\n        push(symbol(METAB));\n\n        _subst();\n\n        push(symbol(SYMBOL_X_UNDERSCORE));\n        push(symbol(METAX));\n\n        _subst();\n\n        p1 = pop();\n        p5 = car(p1);\n\n        if (DEBUG) {\n          console.log(\"template expression: \" + p5);\n        }\n\n        p6 = cadr(p1);\n        p7 = cddr(p1);\n        /*\n        p5 = p1.tensor.elem[0]\n        p6 = p1.tensor.elem[1]\n        for i in [2..(p1.tensor.elem.length-1)]\n          push p1.tensor.elem[i]\n        list(p1.tensor.elem.length - 2)\n        p7 = pop()\n         */\n\n        if (f_equals_a(transform_h, generalTransform)) {\n          transformationSuccessful = true;\n        } else {\n          if (DEBUG) {\n            console.log(\"p3 at this point: \" + p3);\n          }\n\n          transformedTerms = [];\n\n          if (DEBUG) {\n            console.log(\"car(p3): \" + car(p3));\n          }\n\n          restTerm = p3;\n\n          if (iscons(restTerm)) {\n            transformedTerms.push(car(p3));\n            restTerm = cdr(p3);\n          }\n\n          while (iscons(restTerm)) {\n            secondTerm = car(restTerm);\n            restTerm = cdr(restTerm);\n\n            if (DEBUG) {\n              console.log(\"tos before recursive transform: \" + tos);\n            }\n\n            push(secondTerm);\n            push_symbol(NIL);\n\n            if (DEBUG) {\n              console.log(\"testing: \" + secondTerm);\n            }\n\n            if (DEBUG) {\n              console.log(\"about to try to simplify other term: \" + secondTerm);\n            }\n\n            success = _transform(s, generalTransform);\n            transformationSuccessful = transformationSuccessful || success;\n            transformedTerms.push(pop());\n\n            if (DEBUG) {\n              console.log(\"tried to simplify other term: \" + secondTerm + \" ...successful?: \" + success + \" ...transformed: \" + transformedTerms[transformedTerms.length - 1]);\n            }\n          }\n\n          if (transformedTerms.length !== 0) {\n            for (m1 = 0, len = transformedTerms.length; m1 < len; m1++) {\n              i = transformedTerms[m1];\n              push(i);\n            }\n\n            list(transformedTerms.length);\n            p6 = pop();\n          }\n        }\n      }\n    } else {\n      for (n1 = 0, len1 = s.length; n1 < len1; n1++) {\n        eachTransformEntry = s[n1];\n\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + eachTransformEntry);\n\n          if ((eachTransformEntry + \"\").indexOf(\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\") !== -1) {\n            debugger;\n          }\n        }\n\n        if (eachTransformEntry) {\n          scan_meta(eachTransformEntry);\n          p1 = pop();\n          p5 = cadr(p1);\n          p6 = caddr(p1);\n          p7 = cdddr(p1);\n          /*\n          p5 = p1.tensor.elem[0]\n          p6 = p1.tensor.elem[1]\n          for i in [2..(p1.tensor.elem.length-1)]\n            push p1.tensor.elem[i]\n          list(p1.tensor.elem.length - 2)\n          p7 = pop()\n           */\n\n          if (f_equals_a(transform_h, generalTransform)) {\n            transformationSuccessful = true;\n            break;\n          }\n        }\n      }\n    }\n\n    moveTos(transform_h);\n\n    if (transformationSuccessful) {\n      push(p6);\n      Eval();\n      p1 = pop();\n      transformationSuccessful = true;\n    } else {\n      if (generalTransform) {\n        p1 = p3;\n      } else {\n        p1 = symbol(NIL);\n      }\n    }\n\n    restoreMetaBindings();\n    push(p1);\n    restore();\n    return transformationSuccessful;\n  };\n\n  saveMetaBindings = function saveMetaBindings() {\n    push(get_binding(symbol(METAA)));\n    push(get_binding(symbol(METAB)));\n    return push(get_binding(symbol(METAX)));\n  };\n\n  restoreMetaBindings = function restoreMetaBindings() {\n    set_binding(symbol(METAX), pop());\n    set_binding(symbol(METAB), pop());\n    return set_binding(symbol(METAA), pop());\n  };\n\n  f_equals_a = function f_equals_a(h, generalTransform) {\n    var fea_i, fea_j, l1, m1, originalexpanding, ref2, ref3, ref4, ref5;\n    fea_i = 0;\n    fea_j = 0;\n\n    for (fea_i = l1 = ref2 = h, ref3 = tos; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; fea_i = ref2 <= ref3 ? ++l1 : --l1) {\n      set_binding(symbol(METAA), stack[fea_i]);\n\n      if (DEBUG) {\n        console.log(\"  binding METAA to \" + get_binding(symbol(METAA)));\n      }\n\n      for (fea_j = m1 = ref4 = h, ref5 = tos; ref4 <= ref5 ? m1 < ref5 : m1 > ref5; fea_j = ref4 <= ref5 ? ++m1 : --m1) {\n        set_binding(symbol(METAB), stack[fea_j]);\n\n        if (DEBUG) {\n          console.log(\"  binding METAB to \" + get_binding(symbol(METAB)));\n        }\n\n        p1 = p7;\n\n        while (iscons(p1)) {\n          push(car(p1));\n          Eval();\n          p2 = pop();\n\n          if (isZeroAtomOrTensor(p2)) {\n            break;\n          }\n\n          p1 = cdr(p1);\n        }\n\n        if (iscons(p1)) {\n          continue;\n        }\n\n        push(p3);\n\n        if (DEBUG) {\n          console.log(\"about to evaluate template expression: \" + p5 + \" binding METAA to \" + get_binding(symbol(METAA)) + \" and binding METAB to \" + get_binding(symbol(METAB)) + \" and binding METAX to \" + get_binding(symbol(METAX)));\n        }\n\n        push(p5);\n\n        if (generalTransform) {\n          originalexpanding = expanding;\n          expanding = false;\n        }\n\n        Eval();\n\n        if (generalTransform) {\n          expanding = originalexpanding;\n        }\n\n        if (DEBUG) {\n          console.log(\"  comparing \" + stack[tos - 1] + \" to: \" + stack[tos - 2]);\n        }\n\n        subtract();\n        p1 = pop();\n\n        if (isZeroAtomOrTensor(p1)) {\n          if (DEBUG) {\n            console.log(\"binding METAA to \" + get_binding(symbol(METAA)));\n            console.log(\"binding METAB to \" + get_binding(symbol(METAB)));\n            console.log(\"binding METAX to \" + get_binding(symbol(METAX)));\n            console.log(\"comparing \" + p3 + \" to: \" + p5);\n          }\n\n          return 1;\n        }\n      }\n    }\n\n    return 0;\n  };\n\n  Eval_transpose = function Eval_transpose() {\n    push(cadr(p1));\n    Eval();\n\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n\n    return _transpose();\n  };\n\n  _transpose = function transpose() {\n    var a, accumulator, ai, an, b, eachEntry, i, innerTranspSwitch1, innerTranspSwitch2, j, k, l, l1, m, m1, n1, ndim, nelem, o1, q1, r1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, s1, t;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    ai = [];\n    an = [];\n\n    for (i = l1 = 0, ref2 = MAXDIM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n\n    if (isNumericAtom(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (isplusone(p2) && isplustwo(p3) || isplusone(p3) && isplustwo(p2)) {\n      if (isidentitymatrix(p1)) {\n        push(p1);\n        restore();\n        return;\n      }\n    }\n\n    if (istranspose(p1)) {\n      innerTranspSwitch1 = car(cdr(cdr(p1)));\n      innerTranspSwitch2 = car(cdr(cdr(cdr(p1))));\n\n      if (equal(innerTranspSwitch1, p3) && equal(innerTranspSwitch2, p2) || equal(innerTranspSwitch2, p3) && equal(innerTranspSwitch1, p2) || equal(innerTranspSwitch1, symbol(NIL)) && equal(innerTranspSwitch2, symbol(NIL)) && (isplusone(p3) && isplustwo(p2) || isplusone(p2) && isplustwo(p3))) {\n        push(car(cdr(p1)));\n        restore();\n        return;\n      }\n    }\n\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n      push(zero);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        push(p3);\n\n        _transpose();\n\n        add();\n        p1 = cdr(p1);\n      }\n\n      restore();\n      return;\n    }\n\n    if (expanding && ismultiply(p1)) {\n      p1 = cdr(p1);\n      push(one);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        push(p3);\n\n        _transpose();\n\n        multiply();\n        p1 = cdr(p1);\n      }\n\n      restore();\n      return;\n    }\n\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n\n      while (iscons(p1)) {\n        accumulator.push([car(p1), p2, p3]);\n        p1 = cdr(p1);\n      }\n\n      for (eachEntry = m1 = ref3 = accumulator.length - 1; ref3 <= 0 ? m1 <= 0 : m1 >= 0; eachEntry = ref3 <= 0 ? ++m1 : --m1) {\n        push(accumulator[eachEntry][0]);\n        push(accumulator[eachEntry][1]);\n        push(accumulator[eachEntry][2]);\n\n        _transpose();\n\n        if (eachEntry !== accumulator.length - 1) {\n          _inner();\n        }\n      }\n\n      restore();\n      return;\n    }\n\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        push_symbol(TRANSPOSE);\n        push(p1);\n\n        if ((!isplusone(p2) || !isplustwo(p3)) && (!isplusone(p3) || !isplustwo(p2))) {\n          push(p2);\n          push(p3);\n          list(4);\n        } else {\n          list(2);\n        }\n\n        restore();\n        return;\n      }\n\n      push(zero);\n      restore();\n      return;\n    }\n\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n\n    if (ndim === 1) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n\n    if (l < 1 || l > ndim || m < 1 || m > ndim) {\n      stop(\"transpose: index out of range\");\n    }\n\n    l--;\n    m--;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n\n    for (i = n1 = 0, ref4 = ndim; 0 <= ref4 ? n1 < ref4 : n1 > ref4; i = 0 <= ref4 ? ++n1 : --n1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    p2.tensor.dim[l] = p1.tensor.dim[m];\n    p2.tensor.dim[m] = p1.tensor.dim[l];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n\n    for (i = o1 = 0, ref5 = ndim; 0 <= ref5 ? o1 < ref5 : o1 > ref5; i = 0 <= ref5 ? ++o1 : --o1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n\n    for (i = q1 = 0, ref6 = nelem; 0 <= ref6 ? q1 < ref6 : q1 > ref6; i = 0 <= ref6 ? ++q1 : --q1) {\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      k = 0;\n\n      for (j = r1 = 0, ref7 = ndim; 0 <= ref7 ? r1 < ref7 : r1 > ref7; j = 0 <= ref7 ? ++r1 : --r1) {\n        k = k * an[j] + ai[j];\n      }\n\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      b[k] = a[i];\n\n      for (j = s1 = ref8 = ndim - 1; ref8 <= 0 ? s1 <= 0 : s1 >= 0; j = ref8 <= 0 ? ++s1 : --s1) {\n        if (++ai[j] < an[j]) {\n          break;\n        }\n\n        ai[j] = 0;\n      }\n    }\n\n    push(p2);\n    return restore();\n  };\n  /* d =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  f,x\n  \n  General description\n  -------------------\n  Returns the partial derivative of f with respect to x. x can be a vector e.g. [x,y].\n   */\n\n\n  Eval_user_function = function Eval_user_function() {\n    var bodyAndFormalArguments, h;\n\n    if (DEBUG) {\n      console.log(\"Eval_user_function evaluating: \" + car(p1));\n    }\n\n    if (car(p1) === symbol(SYMBOL_D) && get_binding(symbol(SYMBOL_D)) === symbol(SYMBOL_D)) {\n      Eval_derivative();\n      return;\n    }\n\n    push(car(p1));\n    Eval();\n    bodyAndFormalArguments = pop();\n\n    if (isNumericAtom(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found multiplication instead. Use '*' symbol explicitly for multiplication.\");\n    } else if (istensor(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found tensor product instead. Use 'dot/inner' explicitly.\");\n    } else if (isstr(bodyAndFormalArguments)) {\n      stop(\"expected function, found string instead.\");\n    }\n\n    p3 = car(cdr(bodyAndFormalArguments));\n    p4 = car(cdr(cdr(bodyAndFormalArguments)));\n    p5 = cdr(p1);\n\n    if (car(bodyAndFormalArguments) !== symbol(FUNCTION) || bodyAndFormalArguments === car(p1)) {\n      h = tos;\n      push(bodyAndFormalArguments);\n      p1 = p5;\n\n      while (iscons(p1)) {\n        push(car(p1));\n        Eval();\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n      return;\n    }\n\n    p1 = p4;\n    p2 = p5;\n    h = tos;\n\n    while (iscons(p1) && iscons(p2)) {\n      push(car(p1));\n      push(car(p2));\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n\n    list(tos - h);\n    p6 = pop();\n    push(p3);\n\n    if (iscons(p6)) {\n      push(p6);\n\n      _rewrite_args();\n    }\n\n    return Eval();\n  };\n\n  _rewrite_args = function rewrite_args() {\n    var h, n;\n    n = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (istensor(p1)) {\n      n = rewrite_args_tensor();\n      restore();\n      return n;\n    }\n\n    if (iscons(p1)) {\n      h = tos;\n\n      if (car(p1) === car(p2)) {\n        push_symbol(EVAL);\n        push(car(cdr(p2)));\n        list(2);\n      } else {\n        push(car(p1));\n      }\n\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        n += _rewrite_args();\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n      restore();\n      return n;\n    }\n\n    if (!issymbol(p1)) {\n      push(p1);\n      restore();\n      return 0;\n    }\n\n    p3 = p2;\n\n    while (iscons(p3)) {\n      if (p1 === car(p3)) {\n        push(cadr(p3));\n        restore();\n        return 1;\n      }\n\n      p3 = cddr(p3);\n    }\n\n    p3 = get_binding(p1);\n    push(p3);\n\n    if (p1 !== p3) {\n      push(p2);\n      n = _rewrite_args();\n\n      if (n === 0) {\n        pop();\n        push(p1);\n      }\n    }\n\n    restore();\n    return n;\n  };\n\n  rewrite_args_tensor = function rewrite_args_tensor() {\n    var i, l1, n, ref2;\n    n = 0;\n    i = 0;\n    push(p1);\n    copy_tensor();\n    p1 = pop();\n\n    for (i = l1 = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      n += _rewrite_args();\n      p1.tensor.elem[i] = pop();\n    }\n\n    check_tensor_dimensions(p1);\n    push(p1);\n    return n;\n  };\n\n  Eval_zero = function Eval_zero() {\n    var i, k, l1, m, m1, n, ref2, ref3;\n    i = 0;\n    k = [];\n    m = 0;\n    n = 0;\n\n    for (i = l1 = 0, ref2 = MAXDIM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      k[i] = 0;\n    }\n\n    m = 1;\n    n = 0;\n    p2 = cdr(p1);\n\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      i = pop_integer();\n\n      if (i < 1 || isNaN(i)) {\n        push(zero);\n        return;\n      }\n\n      m *= i;\n      k[n++] = i;\n      p2 = cdr(p2);\n    }\n\n    if (n === 0) {\n      push(zero);\n      return;\n    }\n\n    p1 = alloc_tensor(m);\n    p1.tensor.ndim = n;\n\n    for (i = m1 = 0, ref3 = n; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      p1.tensor.dim[i] = k[i];\n    }\n\n    return push(p1);\n  };\n  /*\n  // up to 100 blocks of 100,000 atoms\n  \n  #define M 100\n  #define N 100000\n  \n  U *mem[M]\n  int mcount\n  \n  U *free_list\n  int free_count\n  \n  U *\n  alloc(void)\n  {\n    U *p\n    if (free_count == 0) {\n      if (mcount == 0)\n        alloc_mem()\n      else {\n        gc()\n        if (free_count < N * mcount / 2)\n          alloc_mem()\n      }\n      if (free_count == 0)\n        stop(\"atom space exhausted\")\n    }\n    p = free_list\n    free_list = free_list->u.cons.cdr\n    free_count--\n    return p\n  }\n   */\n\n\n  allocatedId = 0;\n\n  alloc_tensor = function alloc_tensor(nelem) {\n    var i, l1, p, ref2;\n    i = 0;\n    p = new U();\n    p.k = TENSOR;\n    p.tensor = new tensor();\n    p.tensor.nelem = nelem;\n\n    for (i = l1 = 0, ref2 = nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p.tensor.elem[i] = zero;\n    }\n\n    p.tensor.allocatedId = allocatedId;\n    allocatedId++;\n    check_tensor_dimensions(p);\n    return p;\n  };\n  /*\n  // garbage collector\n  \n  void\n  gc(void)\n  {\n    int i, j\n    U *p\n  \n    // tag everything\n  \n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++)\n        p[j].tag = 1\n    }\n  \n    // untag what's used\n  \n    untag(p0)\n    untag(p1)\n    untag(p2)\n    untag(p3)\n    untag(p4)\n    untag(p5)\n    untag(p6)\n    untag(p7)\n    untag(p8)\n    untag(p9)\n  \n    untag(one)\n    untag(zero)\n    untag(imaginaryunit)\n  \n    for (i = 0; i < NSYM; i++) {\n      untag(binding[i])\n      untag(arglist[i])\n    }\n  \n    for (i = 0; i < tos; i++)\n      untag(stack[i])\n  \n    for (i = (int) (frame - stack); i < TOS; i++)\n      untag(stack[i])\n  \n    // collect everything that's still tagged\n  \n    free_count = 0\n  \n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++) {\n        if (p[j].tag == 0)\n          continue\n        // still tagged so it's unused, put on free list\n        switch (p[j].k) {\n        case TENSOR:\n          free(p[j].u.tensor)\n          break\n        case STR:\n          free(p[j].u.str)\n          break\n        case NUM:\n          mfree(p[j].u.q.a)\n          mfree(p[j].u.q.b)\n          break\n        }\n        p[j].k = CONS; // so no double free occurs above\n        p[j].u.cons.cdr = free_list\n        free_list = p + j\n        free_count++\n      }\n    }\n  }\n  \n  void\n  untag(U *p)\n  {\n    int i\n  \n    if (iscons(p)) {\n      do {\n        if (p->tag == 0)\n          return\n        p->tag = 0\n        untag(p->u.cons.car)\n        p = p->u.cons.cdr\n      } while (iscons(p))\n      untag(p)\n      return\n    }\n  \n    if (p->tag) {\n      p->tag = 0\n       if (istensor(p)) {\n        for (i = 0; i < p->u.tensor->nelem; i++)\n          untag(p->u.tensor->elem[i])\n      }\n    }\n  }\n  \n  // get memory for 100,000 atoms\n  \n  void\n  alloc_mem(void)\n  {\n    int i\n    U *p\n    if (mcount == M)\n      return\n    p = (U *) malloc(N * sizeof (struct U))\n    if (p == NULL)\n      return\n    mem[mcount++] = p\n    for (i = 0; i < N; i++) {\n      p[i].k = CONS; // so no free in gc\n      p[i].u.cons.cdr = p + i + 1\n    }\n    p[N - 1].u.cons.cdr = free_list\n    free_list = p\n    free_count += N\n  }\n  \n  void\n  print_mem_info(void)\n  {\n    char buf[100]\n  \n    sprintf(buf, \"%d blocks (%d bytes/block)\\n\", N * mcount, (int) sizeof (U))\n    printstr(buf)\n  \n    sprintf(buf, \"%d free\\n\", free_count)\n    printstr(buf)\n  \n    sprintf(buf, \"%d used\\n\", N * mcount - free_count)\n    printstr(buf)\n  }\n   */\n\n\n  _Find = function Find(p, q) {\n    var i, l1, ref2;\n    i = 0;\n\n    if (equal(p, q)) {\n      return 1;\n    }\n\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        if (_Find(p.tensor.elem[i], q)) {\n          return 1;\n        }\n      }\n\n      return 0;\n    }\n\n    while (iscons(p)) {\n      if (_Find(car(p), q)) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n\n  _findPossibleClockForm = function findPossibleClockForm(p) {\n    var i, l1, ref2;\n    i = 0;\n\n    if (isimaginaryunit(p)) {\n      return 0;\n    }\n\n    if (car(p) === symbol(POWER) && !isinteger(caddr(p1))) {\n      if (_Find(cadr(p), imaginaryunit)) {\n        return 1;\n      }\n    }\n\n    if (car(p) === symbol(POWER) && equaln(cadr(p), -1) && !isinteger(caddr(p1))) {\n      return 1;\n    }\n\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        if (_findPossibleClockForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n\n      return 0;\n    }\n\n    while (iscons(p)) {\n      if (_findPossibleClockForm(car(p))) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n\n  _findPossibleExponentialForm = function findPossibleExponentialForm(p) {\n    var i, l1, ref2;\n    i = 0;\n\n    if (car(p) === symbol(POWER) && cadr(p) === symbol(E)) {\n      return _Find(caddr(p), imaginaryunit);\n    }\n\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        if (_findPossibleExponentialForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n\n      return 0;\n    }\n\n    while (iscons(p)) {\n      if (_findPossibleExponentialForm(car(p))) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n\n  $.Find = _Find;\n\n  init = function init() {\n    var i, l1, ref2;\n    i = 0;\n    flag = 0;\n    reset_after_error();\n    chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n\n    if (flag) {\n      return;\n    }\n\n    flag = 1;\n\n    for (i = l1 = 0, ref2 = NSYM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      isSymbolReclaimable[i] = false;\n    }\n\n    return defn();\n  };\n  /* cross =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n  \n  Parameters\n  ----------\n  u,v\n  \n  General description\n  -------------------\n  Returns the cross product of vectors u and v.\n   */\n\n  /* curl =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n  \n  Parameters\n  ----------\n  u\n  \n  General description\n  -------------------\n  Returns the curl of vector u.\n   */\n\n\n  defn_str = [\"version=\\\"\" + version + \"\\\"\", \"e=exp(1)\", \"i=sqrt(-1)\", \"autoexpand=1\", \"assumeRealVariables=1\", \"trange=[-pi,pi]\", \"xrange=[-10,10]\", \"yrange=[-10,10]\", \"last=0\", \"trace=0\", \"forceFixedPrintout=1\", \"maxFixedPrintoutDigits=6\", \"printLeaveEAlone=1\", \"printLeaveXAlone=0\", \"cross(u,v)=[u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1]]\", \"curl(v)=[d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y)]\", \"div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)\", \"ln(x)=log(x)\"];\n\n  defn = function defn() {\n    var definitionOfInterest, defn_i, l1, originalCodeGen, ref2;\n    p0 = symbol(NIL);\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n    p3 = symbol(NIL);\n    p4 = symbol(NIL);\n    p5 = symbol(NIL);\n    p6 = symbol(NIL);\n    p7 = symbol(NIL);\n    p8 = symbol(NIL);\n    p9 = symbol(NIL);\n    std_symbol(\"abs\", ABS);\n    std_symbol(\"add\", ADD);\n    std_symbol(\"adj\", ADJ);\n    std_symbol(\"and\", AND);\n    std_symbol(\"approxratio\", APPROXRATIO);\n    std_symbol(\"arccos\", ARCCOS);\n    std_symbol(\"arccosh\", ARCCOSH);\n    std_symbol(\"arcsin\", ARCSIN);\n    std_symbol(\"arcsinh\", ARCSINH);\n    std_symbol(\"arctan\", ARCTAN);\n    std_symbol(\"arctanh\", ARCTANH);\n    std_symbol(\"arg\", ARG);\n    std_symbol(\"atomize\", ATOMIZE);\n    std_symbol(\"besselj\", BESSELJ);\n    std_symbol(\"bessely\", BESSELY);\n    std_symbol(\"binding\", BINDING);\n    std_symbol(\"binomial\", BINOMIAL);\n    std_symbol(\"ceiling\", CEILING);\n    std_symbol(\"check\", CHECK);\n    std_symbol(\"choose\", CHOOSE);\n    std_symbol(\"circexp\", CIRCEXP);\n    std_symbol(\"clear\", CLEAR);\n    std_symbol(\"clearall\", CLEARALL);\n    std_symbol(\"clearpatterns\", CLEARPATTERNS);\n    std_symbol(\"clock\", CLOCK);\n    std_symbol(\"coeff\", COEFF);\n    std_symbol(\"cofactor\", COFACTOR);\n    std_symbol(\"condense\", CONDENSE);\n    std_symbol(\"conj\", CONJ);\n    std_symbol(\"contract\", CONTRACT);\n    std_symbol(\"cos\", COS);\n    std_symbol(\"cosh\", COSH);\n    std_symbol(\"decomp\", DECOMP);\n    std_symbol(\"defint\", DEFINT);\n    std_symbol(\"deg\", DEGREE);\n    std_symbol(\"denominator\", DENOMINATOR);\n    std_symbol(\"det\", DET);\n    std_symbol(\"derivative\", DERIVATIVE);\n    std_symbol(\"dim\", DIM);\n    std_symbol(\"dirac\", DIRAC);\n    std_symbol(\"divisors\", DIVISORS);\n    std_symbol(\"do\", DO);\n    std_symbol(\"dot\", DOT);\n    std_symbol(\"draw\", DRAW);\n    std_symbol(\"dsolve\", DSOLVE);\n    std_symbol(\"erf\", ERF);\n    std_symbol(\"erfc\", ERFC);\n    std_symbol(\"eigen\", EIGEN);\n    std_symbol(\"eigenval\", EIGENVAL);\n    std_symbol(\"eigenvec\", EIGENVEC);\n    std_symbol(\"eval\", EVAL);\n    std_symbol(\"exp\", EXP);\n    std_symbol(\"expand\", EXPAND);\n    std_symbol(\"expcos\", EXPCOS);\n    std_symbol(\"expsin\", EXPSIN);\n    std_symbol(\"factor\", FACTOR);\n    std_symbol(\"factorial\", FACTORIAL);\n    std_symbol(\"factorpoly\", FACTORPOLY);\n    std_symbol(\"filter\", FILTER);\n    std_symbol(\"float\", FLOATF);\n    std_symbol(\"floor\", FLOOR);\n    std_symbol(\"for\", FOR);\n    std_symbol(\"function\", FUNCTION);\n    std_symbol(\"Gamma\", GAMMA);\n    std_symbol(\"gcd\", GCD);\n    std_symbol(\"hermite\", HERMITE);\n    std_symbol(\"hilbert\", HILBERT);\n    std_symbol(\"imag\", IMAG);\n    std_symbol(\"component\", INDEX);\n    std_symbol(\"inner\", INNER);\n    std_symbol(\"integral\", INTEGRAL);\n    std_symbol(\"inv\", INV);\n    std_symbol(\"invg\", INVG);\n    std_symbol(\"isinteger\", ISINTEGER);\n    std_symbol(\"isprime\", ISPRIME);\n    std_symbol(\"laguerre\", LAGUERRE);\n    std_symbol(\"lcm\", LCM);\n    std_symbol(\"leading\", LEADING);\n    std_symbol(\"legendre\", LEGENDRE);\n    std_symbol(\"log\", LOG);\n    std_symbol(\"lookup\", LOOKUP);\n    std_symbol(\"mod\", MOD);\n    std_symbol(\"multiply\", MULTIPLY);\n    std_symbol(\"not\", NOT);\n    std_symbol(\"nroots\", NROOTS);\n    std_symbol(\"number\", NUMBER);\n    std_symbol(\"numerator\", NUMERATOR);\n    std_symbol(\"operator\", OPERATOR);\n    std_symbol(\"or\", OR);\n    std_symbol(\"outer\", OUTER);\n    std_symbol(\"pattern\", PATTERN);\n    std_symbol(\"patternsinfo\", PATTERNSINFO);\n    std_symbol(\"polar\", POLAR);\n    std_symbol(\"power\", POWER);\n    std_symbol(\"prime\", PRIME);\n    std_symbol(\"print\", PRINT);\n    std_symbol(\"print2dascii\", PRINT2DASCII);\n    std_symbol(\"printcomputer\", PRINTFULL);\n    std_symbol(\"printlatex\", PRINTLATEX);\n    std_symbol(\"printlist\", PRINTLIST);\n    std_symbol(\"printhuman\", PRINTPLAIN);\n    std_symbol(\"printLeaveEAlone\", PRINT_LEAVE_E_ALONE);\n    std_symbol(\"printLeaveXAlone\", PRINT_LEAVE_X_ALONE);\n    std_symbol(\"product\", PRODUCT);\n    std_symbol(\"quote\", QUOTE);\n    std_symbol(\"quotient\", QUOTIENT);\n    std_symbol(\"rank\", RANK);\n    std_symbol(\"rationalize\", RATIONALIZE);\n    std_symbol(\"real\", REAL);\n    std_symbol(\"rect\", YYRECT);\n    std_symbol(\"roots\", ROOTS);\n    std_symbol(\"round\", ROUND);\n    std_symbol(\"equals\", SETQ);\n    std_symbol(\"sgn\", SGN);\n    std_symbol(\"silentpattern\", SILENTPATTERN);\n    std_symbol(\"simplify\", SIMPLIFY);\n    std_symbol(\"sin\", SIN);\n    std_symbol(\"sinh\", SINH);\n    std_symbol(\"shape\", SHAPE);\n    std_symbol(\"sqrt\", SQRT);\n    std_symbol(\"stop\", STOP);\n    std_symbol(\"subst\", SUBST);\n    std_symbol(\"sum\", SUM);\n    std_symbol(\"symbolsinfo\", SYMBOLSINFO);\n    std_symbol(\"tan\", TAN);\n    std_symbol(\"tanh\", TANH);\n    std_symbol(\"taylor\", TAYLOR);\n    std_symbol(\"test\", TEST);\n    std_symbol(\"testeq\", TESTEQ);\n    std_symbol(\"testge\", TESTGE);\n    std_symbol(\"testgt\", TESTGT);\n    std_symbol(\"testle\", TESTLE);\n    std_symbol(\"testlt\", TESTLT);\n    std_symbol(\"transpose\", TRANSPOSE);\n    std_symbol(\"unit\", UNIT);\n    std_symbol(\"zero\", ZERO);\n    std_symbol(\"nil\", NIL);\n    std_symbol(\"autoexpand\", AUTOEXPAND);\n    std_symbol(\"bake\", BAKE);\n    std_symbol(\"assumeRealVariables\", ASSUME_REAL_VARIABLES);\n    std_symbol(\"last\", LAST);\n    std_symbol(\"lastprint\", LAST_PRINT);\n    std_symbol(\"last2dasciiprint\", LAST_2DASCII_PRINT);\n    std_symbol(\"lastfullprint\", LAST_FULL_PRINT);\n    std_symbol(\"lastlatexprint\", LAST_LATEX_PRINT);\n    std_symbol(\"lastlistprint\", LAST_LIST_PRINT);\n    std_symbol(\"lastplainprint\", LAST_PLAIN_PRINT);\n    std_symbol(\"trace\", TRACE);\n    std_symbol(\"forceFixedPrintout\", FORCE_FIXED_PRINTOUT);\n    std_symbol(\"maxFixedPrintoutDigits\", MAX_FIXED_PRINTOUT_DIGITS);\n    std_symbol(\"~\", YYE);\n    std_symbol(\"$DRAWX\", DRAWX);\n    std_symbol(\"$METAA\", METAA);\n    std_symbol(\"$METAB\", METAB);\n    std_symbol(\"$METAX\", METAX);\n    std_symbol(\"$SECRETX\", SECRETX);\n    std_symbol(\"version\", VERSION);\n    std_symbol(\"pi\", PI);\n    std_symbol(\"a\", SYMBOL_A);\n    std_symbol(\"b\", SYMBOL_B);\n    std_symbol(\"c\", SYMBOL_C);\n    std_symbol(\"d\", SYMBOL_D);\n    std_symbol(\"i\", SYMBOL_I);\n    std_symbol(\"j\", SYMBOL_J);\n    std_symbol(\"n\", SYMBOL_N);\n    std_symbol(\"r\", SYMBOL_R);\n    std_symbol(\"s\", SYMBOL_S);\n    std_symbol(\"t\", SYMBOL_T);\n    std_symbol(\"x\", SYMBOL_X);\n    std_symbol(\"y\", SYMBOL_Y);\n    std_symbol(\"z\", SYMBOL_Z);\n    std_symbol(\"I\", SYMBOL_IDENTITY_MATRIX);\n    std_symbol(\"a_\", SYMBOL_A_UNDERSCORE);\n    std_symbol(\"b_\", SYMBOL_B_UNDERSCORE);\n    std_symbol(\"x_\", SYMBOL_X_UNDERSCORE);\n    std_symbol(\"$C1\", C1);\n    std_symbol(\"$C2\", C2);\n    std_symbol(\"$C3\", C3);\n    std_symbol(\"$C4\", C4);\n    std_symbol(\"$C5\", C5);\n    std_symbol(\"$C6\", C6);\n    defineSomeHandyConstants();\n    originalCodeGen = codeGen;\n    codeGen = false;\n\n    for (defn_i = l1 = 0, ref2 = defn_str.length; 0 <= ref2 ? l1 < ref2 : l1 > ref2; defn_i = 0 <= ref2 ? ++l1 : --l1) {\n      definitionOfInterest = defn_str[defn_i];\n      scan(definitionOfInterest);\n\n      if (DEBUG) {\n        console.log(\"... evaling \" + definitionOfInterest);\n        console.log(\"top of stack:\");\n        console.log(_print_list(stack[tos - 1]));\n      }\n\n      Eval();\n      pop();\n    }\n\n    return codeGen = originalCodeGen;\n  };\n\n  defineSomeHandyConstants = function defineSomeHandyConstants() {\n    push_integer(0);\n    zero = pop();\n    push_integer(1);\n    one = pop();\n    push_double(1.0);\n    one_as_double = pop();\n    push_symbol(POWER);\n\n    if (DEBUG) {\n      console.log(_print_list(stack[tos - 1]));\n    }\n\n    push_integer(-1);\n\n    if (DEBUG) {\n      console.log(_print_list(stack[tos - 1]));\n    }\n\n    push_rational(1, 2);\n\n    if (DEBUG) {\n      console.log(_print_list(stack[tos - 1]));\n    }\n\n    list(3);\n\n    if (DEBUG) {\n      console.log(_print_list(stack[tos - 1]));\n    }\n\n    return imaginaryunit = pop();\n  };\n\n  mcmp = function mcmp(a, b) {\n    return a.compare(b);\n  };\n\n  mcmpint = function mcmpint(a, n) {\n    var b, t;\n    b = bigInt(n);\n    t = mcmp(a, b);\n    return t;\n  };\n\n  strcmp = function strcmp(str1, str2) {\n    if (str1 === str2) {\n      return 0;\n    } else if (str1 > str2) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n\n  doubleToReasonableString = function doubleToReasonableString(d) {\n    var maxFixedPrintoutDigits, stringRepresentation;\n\n    if (codeGen) {\n      return \"\" + d;\n    }\n\n    if (isZeroAtomOrTensor(get_binding(symbol(FORCE_FIXED_PRINTOUT)))) {\n      stringRepresentation = \"\" + d;\n\n      if (printMode === PRINTMODE_LATEX) {\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"\\\\mathrm{e}{$1}\");\n        } else {\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0\\\\mathrm{e}{$2}\");\n        }\n      } else {\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"*10^($1)\");\n        } else {\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0*10^($2)\");\n        }\n      }\n    } else {\n      push(get_binding(symbol(MAX_FIXED_PRINTOUT_DIGITS)));\n      maxFixedPrintoutDigits = pop_integer();\n      stringRepresentation = \"\" + d.toFixed(maxFixedPrintoutDigits);\n      stringRepresentation = stringRepresentation.replace(/(\\.\\d*?[1-9])0+$/gm, \"$1\");\n      stringRepresentation = stringRepresentation.replace(/\\.0+$/gm, \"\");\n\n      if (stringRepresentation.indexOf(\".\") === -1) {\n        stringRepresentation += \".0\";\n      }\n\n      if (parseFloat(stringRepresentation) !== d) {\n        stringRepresentation = d.toFixed(maxFixedPrintoutDigits) + \"...\";\n      }\n    }\n\n    return stringRepresentation;\n  };\n\n  clear_term = function clear_term() {};\n\n  isspace = function isspace(s) {\n    if (s == null) {\n      return false;\n    }\n\n    return s === ' ' || s === '\\t' || s === '\\n' || s === '\\v' || s === '\\f' || s === '\\r';\n  };\n\n  isdigit = function isdigit(str) {\n    if (str == null) {\n      return false;\n    }\n\n    return /^\\d+$/.test(str);\n  };\n\n  isalpha = function isalpha(str) {\n    if (str == null) {\n      return false;\n    }\n\n    return str.search(/[^A-Za-z]/) === -1;\n  };\n\n  isalphaOrUnderscore = function isalphaOrUnderscore(str) {\n    if (str == null) {\n      return false;\n    }\n\n    return str.search(/[^A-Za-z_]/) === -1;\n  };\n\n  isunderscore = function isunderscore(str) {\n    if (str == null) {\n      return false;\n    }\n\n    return str.search(/_/) === -1;\n  };\n\n  isalnumorunderscore = function isalnumorunderscore(str) {\n    if (str == null) {\n      return false;\n    }\n\n    return isalphaOrUnderscore(str) || isdigit(str);\n  };\n\n  _count = function count(p) {\n    var n;\n\n    if (iscons(p)) {\n      n = 0;\n\n      while (iscons(p)) {\n        n += _count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n\n    return n;\n  };\n\n  _countOccurrencesOfSymbol = function countOccurrencesOfSymbol(needle, p) {\n    var n;\n    n = 0;\n\n    if (iscons(p)) {\n      while (iscons(p)) {\n        n += _countOccurrencesOfSymbol(needle, car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (equal(needle, p)) {\n        n = 1;\n      }\n    }\n\n    return n;\n  };\n\n  countsize = function countsize(p) {\n    var i, l1, n, ref2;\n    n = 0;\n\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        n += p.tensor.elem[i];\n      }\n    } else if (iscons(p)) {\n      while (iscons(p)) {\n        n += _count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n\n    return n;\n  };\n\n  stop = function stop(s) {\n    var message;\n    errorMessage += \"Stop: \";\n    errorMessage += s;\n    message = errorMessage;\n    errorMessage = '';\n    moveTos(0);\n    throw new Error(message);\n  };\n\n  findDependenciesInScript = function findDependenciesInScript(stringToBeParsed, dontGenerateCode) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, bodyForReadableSummaryOfGeneratedCode, cyclesDescriptions, deQuotedDep, dependencyInfo, eachDependency, error, generatedBody, generatedCode, i, indexOfEachReplacement, indexOfPartRemainingToBeParsed, inited, key, l1, len, len1, len2, len3, len4, len5, len6, len7, m1, n, n1, newUserSymbol, o1, origPrintMode, originalUserSymbol, parameters, q1, r1, readableSummaryOfGeneratedCode, recursedDependencies, ref2, replacementsFrom, replacementsTo, s1, scriptEvaluation, stringToBeRun, t1, testableString, timeStartFromAlgebra, toBePrinted, u1, userVariablesMentioned, value, variablesWithCycles;\n\n    if (DEBUG) {\n      console.log(\"stringToBeParsed: \" + stringToBeParsed);\n    }\n\n    timeStartFromAlgebra = new Date().getTime();\n    inited = true;\n    codeGen = true;\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    symbolsInExpressionsWithoutAssignments = [];\n    patternHasBeenFound = false;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    n = 0;\n    dependencyInfo = {\n      affectsVariables: [],\n      affectedBy: []\n    };\n    stringToBeRun = stringToBeParsed;\n\n    while (1) {\n      try {\n        errorMessage = \"\";\n        check_stack();\n\n        if (DEBUG) {\n          console.log(\"findDependenciesInScript: scanning\");\n        }\n\n        n = scan(stringToBeParsed.substring(indexOfPartRemainingToBeParsed));\n\n        if (DEBUG) {\n          console.log(\"scanned\");\n        }\n\n        pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n\n        errorMessage = error + \"\";\n        reset_after_error();\n        break;\n      }\n\n      if (n === 0) {\n        break;\n      }\n\n      indexOfPartRemainingToBeParsed += n;\n    }\n\n    testableString = \"\";\n\n    if (DEBUG) {\n      console.log(\"all local dependencies ----------------\");\n    }\n\n    testableString += \"All local dependencies: \";\n\n    for (key in symbolsDependencies) {\n      value = symbolsDependencies[key];\n\n      if (DEBUG) {\n        console.log(\"variable \" + key + \" depends on: \");\n      }\n\n      dependencyInfo.affectsVariables.push(key);\n      testableString += \" variable \" + key + \" depends on: \";\n\n      for (l1 = 0, len = value.length; l1 < len; l1++) {\n        i = value[l1];\n\n        if (DEBUG) {\n          console.log(\"    \" + i);\n        }\n\n        if (i[0] !== \"'\") {\n          dependencyInfo.affectedBy.push(i);\n        }\n\n        testableString += i + \", \";\n      }\n\n      testableString += \"; \";\n    }\n\n    testableString += \". \";\n\n    if (DEBUG) {\n      console.log(\"Symbols with reassignments ----------------\");\n    }\n\n    testableString += \"Symbols with reassignments: \";\n\n    for (m1 = 0, len1 = symbolsHavingReassignments.length; m1 < len1; m1++) {\n      key = symbolsHavingReassignments[m1];\n\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n\n    testableString += \". \";\n\n    if (DEBUG) {\n      console.log(\"Symbols in expressions without assignments ----------------\");\n    }\n\n    testableString += \"Symbols in expressions without assignments: \";\n\n    for (n1 = 0, len2 = symbolsInExpressionsWithoutAssignments.length; n1 < len2; n1++) {\n      key = symbolsInExpressionsWithoutAssignments[n1];\n\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n\n    testableString += \". \";\n    dependencyInfo.affectedBy.push(\"PATTERN_DEPENDENCY\");\n\n    if (patternHasBeenFound) {\n      dependencyInfo.affectsVariables.push(\"PATTERN_DEPENDENCY\");\n      testableString += \" - PATTERN_DEPENDENCY inserted - \";\n    }\n\n    if (DEBUG) {\n      console.log(\"All dependencies recursively ----------------\");\n    }\n\n    testableString += \"All dependencies recursively: \";\n    scriptEvaluation = [\"\", \"\"];\n    generatedCode = \"\";\n    readableSummaryOfGeneratedCode = \"\";\n\n    if (errorMessage === \"\" && !dontGenerateCode) {\n      try {\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n        scriptEvaluation = run(stringToBeParsed, true);\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n      } catch (error1) {\n        error = error1;\n\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n\n        errorMessage = error + \"\";\n        init();\n      }\n\n      if (errorMessage === \"\") {\n        for (key in symbolsDependencies) {\n          codeGen = true;\n\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n\n          codeGen = false;\n\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" depends on: \");\n          }\n\n          testableString += \" variable \" + key + \" depends on: \";\n          recursedDependencies = [];\n          variablesWithCycles = [];\n          cyclesDescriptions = [];\n\n          _recursiveDependencies(key, recursedDependencies, [], variablesWithCycles, [], cyclesDescriptions);\n\n          for (o1 = 0, len3 = variablesWithCycles.length; o1 < len3; o1++) {\n            i = variablesWithCycles[o1];\n\n            if (DEBUG) {\n              console.log(\"    --> cycle through \" + i);\n            }\n          }\n\n          for (q1 = 0, len4 = recursedDependencies.length; q1 < len4; q1++) {\n            i = recursedDependencies[q1];\n\n            if (DEBUG) {\n              console.log(\"    \" + i);\n            }\n\n            testableString += i + \", \";\n          }\n\n          testableString += \"; \";\n\n          for (r1 = 0, len5 = cyclesDescriptions.length; r1 < len5; r1++) {\n            i = cyclesDescriptions[r1];\n            testableString += \" \" + i + \", \";\n          }\n\n          if (DEBUG) {\n            console.log(\"  code generation:\" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n\n          push(get_binding(usr_symbol(key)));\n          replacementsFrom = [];\n          replacementsTo = [];\n\n          for (s1 = 0, len6 = recursedDependencies.length; s1 < len6; s1++) {\n            eachDependency = recursedDependencies[s1];\n\n            if (eachDependency[0] === \"'\") {\n              deQuotedDep = eachDependency.substring(1);\n              originalUserSymbol = usr_symbol(deQuotedDep);\n              newUserSymbol = usr_symbol(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\" + deQuotedDep);\n              replacementsFrom.push(originalUserSymbol);\n              replacementsTo.push(newUserSymbol);\n              push(originalUserSymbol);\n              push(newUserSymbol);\n\n              _subst();\n\n              if (DEBUG) {\n                console.log(\"after substitution: \" + stack[tos - 1]);\n              }\n            }\n          }\n\n          try {\n            simplifyForCodeGeneration();\n          } catch (error1) {\n            error = error1;\n\n            if (PRINTOUTRESULT) {\n              console.log(error);\n            }\n\n            errorMessage = error + \"\";\n            init();\n          }\n\n          for (indexOfEachReplacement = t1 = 0, ref2 = replacementsFrom.length; 0 <= ref2 ? t1 < ref2 : t1 > ref2; indexOfEachReplacement = 0 <= ref2 ? ++t1 : --t1) {\n            push(replacementsTo[indexOfEachReplacement]);\n            push(replacementsFrom[indexOfEachReplacement]);\n\n            _subst();\n          }\n\n          clearRenamedVariablesToAvoidBindingToExternalScope();\n\n          if (errorMessage === \"\") {\n            toBePrinted = pop();\n            userVariablesMentioned = [];\n\n            _collectUserSymbols(toBePrinted, userVariablesMentioned);\n\n            allReturnedPlainStrings = \"\";\n            allReturnedLatexStrings = \"\";\n            codeGen = true;\n            generatedBody = toBePrinted.toString();\n            codeGen = false;\n            origPrintMode = printMode;\n            printMode = PRINTMODE_LATEX;\n            bodyForReadableSummaryOfGeneratedCode = toBePrinted.toString();\n            printMode = origPrintMode;\n\n            if (variablesWithCycles.indexOf(key) !== -1) {\n              generatedCode += \"// \" + key + \" is part of a cyclic dependency, no code generated.\";\n              readableSummaryOfGeneratedCode += \"#\" + key + \" is part of a cyclic dependency, no code generated.\";\n            } else {\n              /*\n               * using this paragraph instead of the following one\n               * creates methods signatures that\n               * are slightly less efficient\n               * i.e. variables compare even if they are\n               * simplified away.\n               * In theory these signatures are more stable, but\n               * in practice signatures vary quite a bit anyways\n               * depending on previous assignments for example,\n               * so it's unclear whether going for stability\n               * is sensible at all..\n              if recursedDependencies.length != 0\n                parameters = \"(\"\n                for i in recursedDependencies\n                  if i.indexOf(\"'\") != 0\n                    parameters += i + \", \"\n                  else\n                    if recursedDependencies.indexOf(i.substring(1)) == -1\n                      parameters += i.substring(1) + \", \"\n               */\n              userVariablesMentioned = userVariablesMentioned.filter(function (x) {\n                return predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(x + \"\") === -1;\n              });\n              userVariablesMentioned = userVariablesMentioned.filter(function (x) {\n                return recursedDependencies.indexOf(x + \"\") !== -1 || recursedDependencies.indexOf(\"\\'\" + x + \"\") !== -1;\n              });\n\n              if (userVariablesMentioned.length !== 0) {\n                parameters = \"(\";\n\n                for (u1 = 0, len7 = userVariablesMentioned.length; u1 < len7; u1++) {\n                  i = userVariablesMentioned[u1];\n\n                  if (i.printname !== key) {\n                    parameters += i.printname + \", \";\n                  }\n                }\n\n                parameters = parameters.replace(/, $/gm, \"\");\n                parameters += \")\";\n                generatedCode += key + \" = function \" + parameters + \" { return ( \" + generatedBody + \" ); }\";\n                readableSummaryOfGeneratedCode += key + parameters + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              } else {\n                generatedCode += key + \" = \" + generatedBody + \";\";\n                readableSummaryOfGeneratedCode += key + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              }\n            }\n\n            generatedCode += \"\\n\";\n            readableSummaryOfGeneratedCode += \"\\n\";\n\n            if (DEBUG) {\n              console.log(\"    \" + generatedCode);\n            }\n          }\n        }\n      }\n    }\n\n    generatedCode = generatedCode.replace(/\\n$/gm, \"\");\n    readableSummaryOfGeneratedCode = readableSummaryOfGeneratedCode.replace(/\\n$/gm, \"\");\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    patternHasBeenFound = false;\n    symbolsInExpressionsWithoutAssignments = [];\n\n    if (DEBUG) {\n      console.log(\"testable string: \" + testableString);\n    }\n\n    if (TIMING_DEBUGS) {\n      console.log(\"findDependenciesInScript time for: \" + stringToBeRun + \" : \" + (new Date().getTime() - timeStartFromAlgebra) + \"ms\");\n    }\n\n    return [testableString, scriptEvaluation[0], generatedCode, readableSummaryOfGeneratedCode, scriptEvaluation[1], errorMessage, dependencyInfo];\n  };\n\n  _recursiveDependencies = function recursiveDependencies(variableToBeChecked, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions) {\n    var cyclesDescription, i, k, l1, len, len1, m1, ref2;\n    variablesAlreadyFleshedOut.push(variableToBeChecked);\n\n    if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]] != null) {\n      if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]].indexOf(\"'\" + variableToBeChecked) !== -1) {\n        if (DEBUG) {\n          console.log(\"can't keep following the chain of \" + variableToBeChecked + \" because it's actually a variable bound to a parameter\");\n        }\n\n        if (arrayWhereDependenciesWillBeAdded.indexOf(\"'\" + variableToBeChecked) === -1 && arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n          arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n        }\n\n        return arrayWhereDependenciesWillBeAdded;\n      }\n    }\n\n    chainBeingChecked.push(variableToBeChecked);\n\n    if (symbolsDependencies[variableToBeChecked] == null) {\n      if (arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n        arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n      }\n\n      return arrayWhereDependenciesWillBeAdded;\n    } else {\n      ref2 = symbolsDependencies[variableToBeChecked];\n\n      for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n        i = ref2[l1];\n\n        if (chainBeingChecked.indexOf(i) !== -1) {\n          if (DEBUG) {\n            console.log(\"  found cycle:\");\n          }\n\n          cyclesDescription = \"\";\n\n          for (m1 = 0, len1 = chainBeingChecked.length; m1 < len1; m1++) {\n            k = chainBeingChecked[m1];\n\n            if (variablesWithCycles.indexOf(k) === -1) {\n              variablesWithCycles.push(k);\n            }\n\n            if (DEBUG) {\n              console.log(k + \" --> \");\n            }\n\n            cyclesDescription += k + \" --> \";\n          }\n\n          if (DEBUG) {\n            console.log(\" ... then \" + i + \" again\");\n          }\n\n          cyclesDescription += \" ... then \" + i + \" again\";\n          cyclesDescriptions.push(cyclesDescription);\n\n          if (variablesWithCycles.indexOf(i) === -1) {\n            variablesWithCycles.push(i);\n          }\n        } else {\n          _recursiveDependencies(i, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions);\n\n          chainBeingChecked.pop();\n        }\n      }\n\n      return arrayWhereDependenciesWillBeAdded;\n    }\n  };\n\n  inited = false;\n  latexErrorSign = \"\\\\rlap{\\\\large\\\\color{red}\\\\bigtriangleup}{\\\\ \\\\ \\\\tiny\\\\color{red}!}\";\n\n  turnErrorMessageToLatex = function turnErrorMessageToLatex(theErrorMessage) {\n    theErrorMessage = theErrorMessage.replace(/\\n/g, \"\");\n    theErrorMessage = theErrorMessage.replace(/_/g, \"} \\\\_ \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(transpose_unicode), 'g'), \"}{}^{T}\\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(dotprod_unicode), 'g'), \"}\\\\cdot \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"Stop:\", \"}  \\\\quad \\\\text{Stop:\");\n    theErrorMessage = theErrorMessage.replace(\"->\", \"}  \\\\rightarrow \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"?\", \"}\\\\enspace \" + latexErrorSign + \" \\\\enspace  \\\\text{\");\n    theErrorMessage = \"$$\\\\text{\" + theErrorMessage.replace(/\\n/g, \"\") + \"}$$\";\n    return theErrorMessage;\n  };\n\n  normaliseDots = function normaliseDots(stringToNormalise) {\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8901), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8226), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(12539), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(55296), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(65381), 'g'), String.fromCharCode(dotprod_unicode));\n    return stringToNormalise;\n  };\n\n  TIMING_DEBUGS = false;\n\n  run = function run(stringToBeRun, generateLatex) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, collectedLatexResult, collectedPlainResult, error, errorWhileExecution, i, indexOfPartRemainingToBeParsed, n, stringToBeReturned, theErrorMessage, timeStart, timingDebugWrite;\n\n    if (generateLatex == null) {\n      generateLatex = false;\n    }\n\n    timeStart = new Date().getTime();\n    stringToBeRun = normaliseDots(stringToBeRun);\n\n    if (stringToBeRun === \"selftest\") {\n      selftest();\n      return;\n    }\n\n    if (!inited) {\n      inited = true;\n      init();\n    }\n\n    i = 0;\n    n = 0;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n\n    while (1) {\n      try {\n        errorMessage = \"\";\n        check_stack();\n        n = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));\n        p1 = pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n\n        allReturnedPlainStrings += error.message;\n\n        if (generateLatex) {\n          theErrorMessage = turnErrorMessageToLatex(error.message);\n          allReturnedLatexStrings += theErrorMessage;\n        }\n\n        reset_after_error();\n        break;\n      }\n\n      if (n === 0) {\n        break;\n      }\n\n      indexOfPartRemainingToBeParsed += n;\n      push(p1);\n      errorWhileExecution = false;\n\n      try {\n        stringsEmittedByUserPrintouts = \"\";\n        top_level_eval();\n        p2 = pop();\n        check_stack();\n\n        if (isstr(p2)) {\n          if (DEBUG) {\n            console.log(p2.str);\n          }\n\n          if (DEBUG) {\n            console.log(\"\\n\");\n          }\n        }\n\n        if (p2 === symbol(NIL)) {\n          collectedPlainResult = stringsEmittedByUserPrintouts;\n\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + stringsEmittedByUserPrintouts + \"$$\";\n          }\n        } else {\n          collectedPlainResult = print_expr(p2);\n          collectedPlainResult += \"\\n\";\n\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + collectLatexStringFromReturnValue(p2) + \"$$\";\n\n            if (DEBUG) {\n              console.log(\"collectedLatexResult: \" + collectedLatexResult);\n            }\n          }\n        }\n\n        allReturnedPlainStrings += collectedPlainResult;\n\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n        }\n\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"printline\");\n          }\n\n          if (DEBUG) {\n            console.log(collectedPlainResult);\n          }\n        }\n\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"display:\");\n          }\n\n          print2dascii(p2);\n        }\n\n        if (generateLatex) {\n          allReturnedLatexStrings += \"\\n\";\n        }\n      } catch (error1) {\n        error = error1;\n        errorWhileExecution = true;\n        collectedPlainResult = error.message;\n\n        if (generateLatex) {\n          collectedLatexResult = turnErrorMessageToLatex(error.message);\n        }\n\n        if (PRINTOUTRESULT) {\n          console.log(collectedPlainResult);\n        }\n\n        allReturnedPlainStrings += collectedPlainResult;\n\n        if (collectedPlainResult !== \"\") {\n          allReturnedPlainStrings += \"\\n\";\n        }\n\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n          allReturnedLatexStrings += \"\\n\";\n        }\n\n        init();\n      }\n    }\n\n    if (allReturnedPlainStrings[allReturnedPlainStrings.length - 1] === \"\\n\") {\n      allReturnedPlainStrings = allReturnedPlainStrings.substring(0, allReturnedPlainStrings.length - 1);\n    }\n\n    if (generateLatex) {\n      if (allReturnedLatexStrings[allReturnedLatexStrings.length - 1] === \"\\n\") {\n        allReturnedLatexStrings = allReturnedLatexStrings.substring(0, allReturnedLatexStrings.length - 1);\n      }\n    }\n\n    if (generateLatex) {\n      if (DEBUG) {\n        console.log(\"allReturnedLatexStrings: \" + allReturnedLatexStrings);\n      }\n\n      stringToBeReturned = [allReturnedPlainStrings, allReturnedLatexStrings];\n    } else {\n      stringToBeReturned = allReturnedPlainStrings;\n    }\n\n    if (TIMING_DEBUGS) {\n      timingDebugWrite = \"run time on: \" + stringToBeRun + \" : \" + (new Date().getTime() - timeStart) + \"ms\";\n      console.log(timingDebugWrite);\n    }\n\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    return stringToBeReturned;\n  };\n\n  check_stack = function check_stack() {\n    if (tos !== 0) {\n      debugger;\n      stop(\"stack error\");\n    }\n\n    if (frame !== TOS) {\n      debugger;\n      stop(\"frame error\");\n    }\n\n    if (chainOfUserSymbolsNotFunctionsBeingEvaluated.length !== 0) {\n      debugger;\n      stop(\"symbols evaluation still ongoing?\");\n    }\n\n    if (evaluatingAsFloats !== 0) {\n      debugger;\n      stop(\"numeric evaluation still ongoing?\");\n    }\n\n    if (evaluatingPolar !== 0) {\n      debugger;\n      return stop(\"evaluation of polar still ongoing?\");\n    }\n  };\n\n  top_level_eval = function top_level_eval() {\n    var evalledArgument, originalArgument, shouldAutoexpand;\n\n    if (DEBUG) {\n      console.log(\"#### top level eval\");\n    }\n\n    trigmode = 0;\n    shouldAutoexpand = symbol(AUTOEXPAND);\n\n    if (isZeroAtomOrTensor(get_binding(shouldAutoexpand))) {\n      expanding = 0;\n    } else {\n      expanding = 1;\n    }\n\n    originalArgument = top();\n    Eval();\n    evalledArgument = top();\n\n    if (evalledArgument === symbol(NIL)) {\n      return;\n    }\n\n    set_binding(symbol(LAST), evalledArgument);\n\n    if (!isZeroAtomOrTensor(get_binding(symbol(BAKE)))) {\n      _bake();\n\n      evalledArgument = top();\n    }\n\n    if ((originalArgument === symbol(SYMBOL_I) || originalArgument === symbol(SYMBOL_J)) && isimaginaryunit(evalledArgument)) {} else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_J);\n      return _subst();\n    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_I);\n      return _subst();\n    }\n  };\n\n  check_esc_flag = function check_esc_flag() {\n    if (esc_flag) {\n      return stop(\"esc key\");\n    }\n  };\n\n  clearAlgebraEnvironment = function clearAlgebraEnvironment() {\n    return do_clearall();\n  };\n\n  computeDependenciesFromAlgebra = function computeDependenciesFromAlgebra(codeFromAlgebraBlock) {\n    var i, keepState, l1, len, len1, m1, originalcodeFromAlgebraBlock, userSimplificationsInProgramForm;\n\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra!!!\");\n    }\n\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra: patterns in the list --------------- \");\n\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n\n      console.log(\"...end of list --------------- \");\n    }\n\n    called_from_Algebra_block = false;\n    return findDependenciesInScript(codeFromAlgebraBlock, true)[6];\n  };\n\n  computeResultsAndJavaScriptFromAlgebra = function computeResultsAndJavaScriptFromAlgebra(codeFromAlgebraBlock) {\n    var code, dependencyInfo, i, keepState, l1, latexResult, len, len1, m1, originalcodeFromAlgebraBlock, readableSummaryOfCode, ref2, result, stringToBeRun, testableStringIsIgnoredHere, timeStartFromAlgebra, userSimplificationsInProgramForm;\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    timeStartFromAlgebra = new Date().getTime();\n\n    if (TIMING_DEBUGS) {\n      console.log(\" --------- computeResultsAndJavaScriptFromAlgebra input: \" + codeFromAlgebraBlock + \" at: \" + new Date());\n    }\n\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n    stringToBeRun = codeFromAlgebraBlock;\n\n    if (DEBUG) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra: patterns in the list --------------- \");\n\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n\n      console.log(\"...end of list --------------- \");\n    }\n\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n\n    ref2 = findDependenciesInScript(codeFromAlgebraBlock), testableStringIsIgnoredHere = ref2[0], result = ref2[1], code = ref2[2], readableSummaryOfCode = ref2[3], latexResult = ref2[4], errorMessage = ref2[5], dependencyInfo = ref2[6];\n    called_from_Algebra_block = false;\n\n    if (readableSummaryOfCode !== \"\" || errorMessage !== \"\") {\n      result += \"\\n\" + readableSummaryOfCode;\n\n      if (errorMessage !== \"\") {\n        result += \"\\n\" + errorMessage;\n      }\n\n      result = result.replace(/\\n/g, \"\\n\\n\");\n      latexResult += \"\\n\" + \"$$\" + readableSummaryOfCode + \"$$\";\n\n      if (errorMessage !== \"\") {\n        latexResult += turnErrorMessageToLatex(errorMessage);\n      }\n\n      latexResult = latexResult.replace(/\\n/g, \"\\n\\n\");\n    }\n\n    latexResult = latexResult.replace(/\\n*/, \"\");\n    latexResult = latexResult.replace(/\\$\\$\\$\\$\\n*/g, \"\");\n    code = code.replace(/Math\\./g, \"\");\n    code = code.replace(/\\n/g, \"\\n\\n\");\n\n    if (TIMING_DEBUGS) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra time (total time from notebook and back) for: \" + stringToBeRun + \" : \" + (new Date().getTime() - timeStartFromAlgebra) + \"ms\");\n    }\n\n    return {\n      code: code,\n      result: latexResult,\n      latexResult: latexResult,\n      dependencyInfo: dependencyInfo\n    };\n  };\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).run = run;\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).findDependenciesInScript = findDependenciesInScript;\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeDependenciesFromAlgebra = computeDependenciesFromAlgebra;\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeResultsAndJavaScriptFromAlgebra = computeResultsAndJavaScriptFromAlgebra;\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).clearAlgebraEnvironment = clearAlgebraEnvironment;\n  tos = 0;\n  nil_symbols = 0;\n\n  push = function push(p) {\n    if (p == null) {\n      debugger;\n    }\n\n    if (p.isZero != null) {\n      debugger;\n    }\n\n    if (p === symbol(NIL)) {\n      nil_symbols++;\n\n      if (DEBUG) {\n        console.log(\"pushing symbol(NIL) #\" + nil_symbols);\n      }\n    }\n\n    if (tos >= frame) {\n      stop(\"stack overflow\");\n    }\n\n    return stack[tos++] = p;\n  };\n\n  moveTos = function moveTos(stackPos) {\n    if (tos <= stackPos) {\n      tos = stackPos;\n      return;\n    }\n\n    while (tos > stackPos) {\n      stack[tos] = null;\n      tos--;\n    }\n  };\n\n  top = function top() {\n    return stack[tos - 1];\n  };\n\n  pop = function pop() {\n    var elementToBeReturned;\n\n    if (tos === 0) {\n      debugger;\n      stop(\"stack underflow\");\n    }\n\n    if (stack[tos - 1] == null) {\n      debugger;\n    }\n\n    elementToBeReturned = stack[--tos];\n    stack[tos] = null;\n    return elementToBeReturned;\n  };\n\n  push_frame = function push_frame(n) {\n    var i, l1, ref2, results;\n    i = 0;\n    frame -= n;\n\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n\n    results = [];\n\n    for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      results.push(stack[frame + i] = symbol(NIL));\n    }\n\n    return results;\n  };\n\n  pop_frame = function pop_frame(n) {\n    frame += n;\n\n    if (frame > TOS) {\n      return stop(\"frame underflow\");\n    }\n  };\n\n  save = function save() {\n    frame -= 10;\n\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n\n    stack[frame + 0] = p0;\n    stack[frame + 1] = p1;\n    stack[frame + 2] = p2;\n    stack[frame + 3] = p3;\n    stack[frame + 4] = p4;\n    stack[frame + 5] = p5;\n    stack[frame + 6] = p6;\n    stack[frame + 7] = p7;\n    stack[frame + 8] = p8;\n    return stack[frame + 9] = p9;\n  };\n\n  restore = function restore() {\n    if (frame > TOS - 10) {\n      stop(\"frame underflow\");\n    }\n\n    p0 = stack[frame + 0];\n    p1 = stack[frame + 1];\n    p2 = stack[frame + 2];\n    p3 = stack[frame + 3];\n    p4 = stack[frame + 4];\n    p5 = stack[frame + 5];\n    p6 = stack[frame + 6];\n    p7 = stack[frame + 7];\n    p8 = stack[frame + 8];\n    p9 = stack[frame + 9];\n    return frame += 10;\n  };\n\n  swap = function swap() {\n    var p, q;\n    p = pop();\n    q = pop();\n    push(p);\n    return push(q);\n  };\n\n  dupl = function dupl() {\n    var p;\n    p = pop();\n    push(p);\n    return push(p);\n  };\n\n  $.dupl = dupl;\n  $.swap = swap;\n  $.restore = restore;\n  $.save = save;\n  $.push = push;\n  $.pop = pop;\n\n  Eval_symbolsinfo = function Eval_symbolsinfo() {\n    var symbolsinfoToBePrinted;\n    symbolsinfoToBePrinted = symbolsinfo();\n\n    if (symbolsinfoToBePrinted !== \"\") {\n      return new_string(symbolsinfoToBePrinted);\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  symbolsinfo = function symbolsinfo() {\n    var bindingi, i, l1, ref2, ref3, symbolsinfoToBePrinted, symtabi;\n    symbolsinfoToBePrinted = \"\";\n\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n\n      symtabi = symtab[i] + \"\";\n      bindingi = (binding[i] + \"\").substring(0, 4);\n      symbolsinfoToBePrinted += \"symbol: \" + symtabi + \" size: \" + countsize(binding[i]) + \" value: \" + bindingi + \"...\\n\";\n    }\n\n    return symbolsinfoToBePrinted;\n  };\n\n  std_symbol = function std_symbol(s, n, latexPrint) {\n    var p;\n    p = symtab[n];\n\n    if (p == null) {\n      debugger;\n    }\n\n    p.printname = s;\n\n    if (latexPrint != null) {\n      return p.latexPrint = latexPrint;\n    } else {\n      return p.latexPrint = s;\n    }\n  };\n\n  usr_symbol = function usr_symbol(s) {\n    var i, l1, ref2;\n    i = 0;\n\n    for (i = l1 = 0, ref2 = NSYM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (s === symtab[i].printname) {\n        return symtab[i];\n      }\n\n      if (symtab[i].printname === \"\") {\n        break;\n      }\n    }\n\n    if (i === NSYM) {\n      stop(\"symbol table overflow\");\n    }\n\n    symtab[i] = new U();\n    symtab[i].k = SYM;\n    symtab[i].printname = s;\n    binding[i] = symtab[i];\n    isSymbolReclaimable[i] = false;\n    return symtab[i];\n  };\n\n  get_printname = function get_printname(p) {\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n\n    return p.printname;\n  };\n\n  set_binding = function set_binding(p, q) {\n    var indexFound;\n\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n     */\n\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n\n    if (DEBUG) {\n      console.log(\"lookup >> set_binding lookup \" + indexFound);\n    }\n\n    isSymbolReclaimable[indexFound] = false;\n    return binding[indexFound] = q;\n  };\n\n  get_binding = function get_binding(p) {\n    var indexFound;\n\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n     */\n\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n\n    if (DEBUG) {\n      console.log(\"lookup >> get_binding lookup \" + indexFound);\n    }\n\n    return binding[indexFound];\n  };\n\n  is_usr_symbol = function is_usr_symbol(p) {\n    var theSymnum;\n\n    if (p.k !== SYM) {\n      return false;\n    }\n\n    theSymnum = symnum(p);\n\n    if (theSymnum > PI && theSymnum !== SYMBOL_I && theSymnum !== SYMBOL_IDENTITY_MATRIX) {\n      return true;\n    }\n\n    return false;\n  };\n\n  lookupsTotal = 0;\n\n  symnum = function symnum(p) {\n    var indexFound;\n    lookupsTotal++;\n\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n\n    indexFound = symtab.indexOf(p);\n\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n\n    if (DEBUG) {\n      console.log(\"lookup >> symnum lookup \" + indexFound + \" lookup # \" + lookupsTotal);\n    }\n\n    return indexFound;\n  };\n\n  push_symbol = function push_symbol(k) {\n    return push(symtab[k]);\n  };\n\n  clear_symbols = function clear_symbols() {\n    var i, l1, ref2, ref3, results;\n    results = [];\n\n    for (i = l1 = ref2 = NIL + 1, ref3 = NSYM; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      results.push(isSymbolReclaimable[i] = false);\n    }\n\n    return results;\n  };\n\n  _collectUserSymbols = function collectUserSymbols(p, accumulator) {\n    var i, l1, ref2;\n\n    if (accumulator == null) {\n      accumulator = [];\n    }\n\n    if (is_usr_symbol(p)) {\n      if (accumulator.indexOf(p) === -1) {\n        accumulator.push(p);\n        return;\n      }\n    }\n\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        _collectUserSymbols(p.tensor.elem[i], accumulator);\n      }\n\n      return;\n    }\n\n    while (iscons(p)) {\n      _collectUserSymbols(car(p), accumulator);\n\n      p = cdr(p);\n    }\n  };\n\n  $.get_binding = get_binding;\n  $.set_binding = set_binding;\n  $.usr_symbol = usr_symbol;\n  $.symbolsinfo = symbolsinfo;\n  $.collectUserSymbols = _collectUserSymbols;\n\n  if (!inited) {\n    inited = true;\n    init();\n  }\n\n  $.init = init;\n\n  parse_internal = function parse_internal(argu) {\n    if (typeof argu === 'string') {\n      return scan(argu);\n    } else if (typeof argu === 'number') {\n      if (argu % 1 === 0) {\n        return push_integer(argu);\n      } else {\n        return push_double(argu);\n      }\n    } else if (argu instanceof U) {\n      return push(argu);\n    } else {\n      console.warn('unknown argument type', argu);\n      return push(symbol(NIL));\n    }\n  };\n\n  parse = function parse(argu) {\n    var data, error;\n\n    try {\n      parse_internal(argu);\n      data = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n\n    return data;\n  };\n\n  exec = function exec() {\n    var argu, argus, error, fn, l1, len, name, result;\n    name = arguments[0], argus = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    fn = get_binding(usr_symbol(name));\n    check_stack();\n    push(fn);\n\n    for (l1 = 0, len = argus.length; l1 < len; l1++) {\n      argu = argus[l1];\n      parse_internal(argu);\n    }\n\n    list(1 + argus.length);\n    p1 = pop();\n    push(p1);\n\n    try {\n      top_level_eval();\n      result = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n\n    return result;\n  };\n\n  $.exec = exec;\n  $.parse = parse;\n\n  (function () {\n    var builtin_fns, fn, l1, len, results;\n    builtin_fns = [\"abs\", \"add\", \"adj\", \"and\", \"approxratio\", \"arccos\", \"arccosh\", \"arcsin\", \"arcsinh\", \"arctan\", \"arctanh\", \"arg\", \"atomize\", \"besselj\", \"bessely\", \"binding\", \"binomial\", \"ceiling\", \"check\", \"choose\", \"circexp\", \"clear\", \"clearall\", \"clearpatterns\", \"clock\", \"coeff\", \"cofactor\", \"condense\", \"conj\", \"contract\", \"cos\", \"cosh\", \"decomp\", \"defint\", \"deg\", \"denominator\", \"det\", \"derivative\", \"dim\", \"dirac\", \"divisors\", \"do\", \"dot\", \"draw\", \"dsolve\", \"eigen\", \"eigenval\", \"eigenvec\", \"erf\", \"erfc\", \"eval\", \"exp\", \"expand\", \"expcos\", \"expsin\", \"factor\", \"factorial\", \"factorpoly\", \"filter\", \"float\", \"floor\", \"for\", \"Gamma\", \"gcd\", \"hermite\", \"hilbert\", \"imag\", \"component\", \"inner\", \"integral\", \"inv\", \"invg\", \"isinteger\", \"isprime\", \"laguerre\", \"lcm\", \"leading\", \"legendre\", \"log\", \"mod\", \"multiply\", \"not\", \"nroots\", \"number\", \"numerator\", \"operator\", \"or\", \"outer\", \"pattern\", \"patternsinfo\", \"polar\", \"power\", \"prime\", \"print\", \"print2dascii\", \"printcomputer\", \"printlatex\", \"printlist\", \"printhuman\", \"product\", \"quote\", \"quotient\", \"rank\", \"rationalize\", \"real\", \"rect\", \"roots\", \"round\", \"equals\", \"shape\", \"sgn\", \"silentpattern\", \"simplify\", \"sin\", \"sinh\", \"sqrt\", \"stop\", \"subst\", \"sum\", \"symbolsinfo\", \"tan\", \"tanh\", \"taylor\", \"test\", \"testeq\", \"testge\", \"testgt\", \"testle\", \"testlt\", \"transpose\", \"unit\", \"zero\"];\n    results = [];\n\n    for (l1 = 0, len = builtin_fns.length; l1 < len; l1++) {\n      fn = builtin_fns[l1];\n      results.push($[fn] = exec.bind(this, fn));\n    }\n\n    return results;\n  })();\n\n  freeze = function freeze() {\n    var frozenContents, frozenHash, frozenPatterns, frozenSymbols, i, l1, ref2;\n    frozenSymbols = [];\n    frozenContents = [];\n    frozenPatterns = [];\n    frozenHash = \"\";\n\n    for (i = l1 = 0, ref2 = symtab.length; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (isSymbolReclaimable[i] === false) {\n        frozenSymbols.push(symtab[i]);\n        frozenContents.push(binding[i]);\n      }\n    }\n\n    frozenPatterns = userSimplificationsInListForm.slice(0);\n    return [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit, getStateHash()];\n  };\n\n  unfreeze = function unfreeze(frozen) {\n    var frozenContents, frozenPatterns, frozenSymbols, i, l1, ref2;\n    frozenSymbols = frozen[0], frozenContents = frozen[1], frozenPatterns = frozen[2], zero = frozen[3], one = frozen[4], imaginaryunit = frozen[5];\n\n    for (i = l1 = 0, ref2 = frozenSymbols.length; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = frozenSymbols[i];\n      binding[i] = frozenContents[i];\n    }\n\n    return userSimplificationsInListForm = frozenPatterns.slice(0);\n  };\n\n  compareState = function compareState(previousHash) {\n    var frozenHash;\n    frozenHash = getStateHash();\n\n    if (frozenHash === previousHash) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  getStateHash = function getStateHash() {\n    var bindingi, frozenHash, i, l1, len, m1, ref2, ref3, symtabi;\n    frozenHash = \"\";\n\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n\n      symtabi = _print_list(symtab[i]);\n      bindingi = _print_list(binding[i]);\n      frozenHash += \" //\" + symtabi + \" : \" + bindingi;\n    }\n\n    for (m1 = 0, len = userSimplificationsInListForm.length; m1 < len; m1++) {\n      i = userSimplificationsInListForm[m1];\n      frozenHash += \" pattern: \" + i;\n    }\n\n    if (DEBUG) {\n      console.log(\"frozenHash: \" + frozenHash);\n    }\n\n    return frozenHash;\n  };\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}